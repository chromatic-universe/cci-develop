/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "curator_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_PathChildrenCacheStartMode(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PATH_CHILDREN_CACHE_START_MODE_NORMAL:return "PATH_CHILDREN_CACHE_START_MODE_NORMAL";
  case PATH_CHILDREN_CACHE_START_MODE_BUILD_INITIAL_CACHE:return "PATH_CHILDREN_CACHE_START_MODE_BUILD_INITIAL_CACHE";
  case PATH_CHILDREN_CACHE_START_MODE_POST_INITIALIZED_EVENT:return "PATH_CHILDREN_CACHE_START_MODE_POST_INITIALIZED_EVENT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_CreateMode(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CREATE_MODE_PERSISTENT:return "CREATE_MODE_PERSISTENT";
  case CREATE_MODE_PERSISTENT_SEQUENTIAL:return "CREATE_MODE_PERSISTENT_SEQUENTIAL";
  case CREATE_MODE_EPHEMERAL:return "CREATE_MODE_EPHEMERAL";
  case CREATE_MODE_EPHEMERAL_SEQUENTIAL:return "CREATE_MODE_EPHEMERAL_SEQUENTIAL";
  case CREATE_MODE_CONTAINER:return "CREATE_MODE_CONTAINER";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_CuratorEventType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CURATOR_EVENT_TYPE_PING:return "CURATOR_EVENT_TYPE_PING";
  case CURATOR_EVENT_TYPE_CREATE:return "CURATOR_EVENT_TYPE_CREATE";
  case CURATOR_EVENT_TYPE_DELETE:return "CURATOR_EVENT_TYPE_DELETE";
  case CURATOR_EVENT_TYPE_EXISTS:return "CURATOR_EVENT_TYPE_EXISTS";
  case CURATOR_EVENT_TYPE_GET_DATA:return "CURATOR_EVENT_TYPE_GET_DATA";
  case CURATOR_EVENT_TYPE_SET_DATA:return "CURATOR_EVENT_TYPE_SET_DATA";
  case CURATOR_EVENT_TYPE_CHILDREN:return "CURATOR_EVENT_TYPE_CHILDREN";
  case CURATOR_EVENT_TYPE_SYNC:return "CURATOR_EVENT_TYPE_SYNC";
  case CURATOR_EVENT_TYPE_GET_ACL:return "CURATOR_EVENT_TYPE_GET_ACL";
  case CURATOR_EVENT_TYPE_SET_ACL:return "CURATOR_EVENT_TYPE_SET_ACL";
  case CURATOR_EVENT_TYPE_WATCHED:return "CURATOR_EVENT_TYPE_WATCHED";
  case CURATOR_EVENT_TYPE_CLOSING:return "CURATOR_EVENT_TYPE_CLOSING";
  case CURATOR_EVENT_TYPE_CONNECTION_CONNECTED:return "CURATOR_EVENT_TYPE_CONNECTION_CONNECTED";
  case CURATOR_EVENT_TYPE_CONNECTION_SUSPENDED:return "CURATOR_EVENT_TYPE_CONNECTION_SUSPENDED";
  case CURATOR_EVENT_TYPE_CONNECTION_RECONNECTED:return "CURATOR_EVENT_TYPE_CONNECTION_RECONNECTED";
  case CURATOR_EVENT_TYPE_CONNECTION_LOST:return "CURATOR_EVENT_TYPE_CONNECTION_LOST";
  case CURATOR_EVENT_TYPE_CONNECTION_READ_ONLY:return "CURATOR_EVENT_TYPE_CONNECTION_READ_ONLY";
  case CURATOR_EVENT_TYPE_LEADER:return "CURATOR_EVENT_TYPE_LEADER";
  case CURATOR_EVENT_TYPE_PATH_CHILDREN_CACHE:return "CURATOR_EVENT_TYPE_PATH_CHILDREN_CACHE";
  case CURATOR_EVENT_TYPE_NODE_CACHE:return "CURATOR_EVENT_TYPE_NODE_CACHE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_EventType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case EVENT_TYPE_None:return "EVENT_TYPE_None";
  case EVENT_TYPE_NodeCreated:return "EVENT_TYPE_NodeCreated";
  case EVENT_TYPE_NodeDeleted:return "EVENT_TYPE_NodeDeleted";
  case EVENT_TYPE_NodeDataChanged:return "EVENT_TYPE_NodeDataChanged";
  case EVENT_TYPE_NodeChildrenChanged:return "EVENT_TYPE_NodeChildrenChanged";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_KeeperState(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case KEEPER_STATE_Unknown:return "KEEPER_STATE_Unknown";
  case KEEPER_STATE_Disconnected:return "KEEPER_STATE_Disconnected";
  case KEEPER_STATE_NoSyncConnected:return "KEEPER_STATE_NoSyncConnected";
  case KEEPER_STATE_SyncConnected:return "KEEPER_STATE_SyncConnected";
  case KEEPER_STATE_AuthFailed:return "KEEPER_STATE_AuthFailed";
  case KEEPER_STATE_ConnectedReadOnly:return "KEEPER_STATE_ConnectedReadOnly";
  case KEEPER_STATE_SaslAuthenticated:return "KEEPER_STATE_SaslAuthenticated";
  case KEEPER_STATE_Expired:return "KEEPER_STATE_Expired";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_PathChildrenCacheEventType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PATH_CHILDREN_CACHE_EVENT_TYPE_CHILD_ADDED:return "PATH_CHILDREN_CACHE_EVENT_TYPE_CHILD_ADDED";
  case PATH_CHILDREN_CACHE_EVENT_TYPE_CHILD_UPDATED:return "PATH_CHILDREN_CACHE_EVENT_TYPE_CHILD_UPDATED";
  case PATH_CHILDREN_CACHE_EVENT_TYPE_CHILD_REMOVED:return "PATH_CHILDREN_CACHE_EVENT_TYPE_CHILD_REMOVED";
  case PATH_CHILDREN_CACHE_EVENT_TYPE_CONNECTION_SUSPENDED:return "PATH_CHILDREN_CACHE_EVENT_TYPE_CONNECTION_SUSPENDED";
  case PATH_CHILDREN_CACHE_EVENT_TYPE_CONNECTION_RECONNECTED:return "PATH_CHILDREN_CACHE_EVENT_TYPE_CONNECTION_RECONNECTED";
  case PATH_CHILDREN_CACHE_EVENT_TYPE_CONNECTION_LOST:return "PATH_CHILDREN_CACHE_EVENT_TYPE_CONNECTION_LOST";
  case PATH_CHILDREN_CACHE_EVENT_TYPE_INITIALIZED:return "PATH_CHILDREN_CACHE_EVENT_TYPE_INITIALIZED";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_PersistentEphemeralNodeMode(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PERSISTENT_EPHEMERAL_NODE_MODE_EPHEMERAL:return "PERSISTENT_EPHEMERAL_NODE_MODE_EPHEMERAL";
  case PERSISTENT_EPHEMERAL_NODE_MODE_EPHEMERAL_SEQUENTIAL:return "PERSISTENT_EPHEMERAL_NODE_MODE_EPHEMERAL_SEQUENTIAL";
  case PERSISTENT_EPHEMERAL_NODE_MODE_PROTECTED_EPHEMERAL:return "PERSISTENT_EPHEMERAL_NODE_MODE_PROTECTED_EPHEMERAL";
  case PERSISTENT_EPHEMERAL_NODE_MODE_PROTECTED_EPHEMERAL_SEQUENTIAL:return "PERSISTENT_EPHEMERAL_NODE_MODE_PROTECTED_EPHEMERAL_SEQUENTIAL";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ExceptionType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case EXCEPTION_TYPE_GENERAL:return "EXCEPTION_TYPE_GENERAL";
  case EXCEPTION_TYPE_ZOOKEEPER:return "EXCEPTION_TYPE_ZOOKEEPER";
  case EXCEPTION_TYPE_NODE:return "EXCEPTION_TYPE_NODE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_NodeExceptionType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case NODE_EXCEPTION_TYPE_NONODE:return "NODE_EXCEPTION_TYPE_NONODE";
  case NODE_EXCEPTION_TYPE_BADVERSION:return "NODE_EXCEPTION_TYPE_BADVERSION";
  case NODE_EXCEPTION_TYPE_NODEEXISTS:return "NODE_EXCEPTION_TYPE_NODEEXISTS";
  case NODE_EXCEPTION_TYPE_NOTEMPTY:return "NODE_EXCEPTION_TYPE_NOTEMPTY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ZooKeeperExceptionType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case ZOO_KEEPER_EXCEPTION_TYPE_SYSTEMERROR:return "ZOO_KEEPER_EXCEPTION_TYPE_SYSTEMERROR";
  case ZOO_KEEPER_EXCEPTION_TYPE_RUNTIMEINCONSISTENCY:return "ZOO_KEEPER_EXCEPTION_TYPE_RUNTIMEINCONSISTENCY";
  case ZOO_KEEPER_EXCEPTION_TYPE_DATAINCONSISTENCY:return "ZOO_KEEPER_EXCEPTION_TYPE_DATAINCONSISTENCY";
  case ZOO_KEEPER_EXCEPTION_TYPE_CONNECTIONLOSS:return "ZOO_KEEPER_EXCEPTION_TYPE_CONNECTIONLOSS";
  case ZOO_KEEPER_EXCEPTION_TYPE_MARSHALLINGERROR:return "ZOO_KEEPER_EXCEPTION_TYPE_MARSHALLINGERROR";
  case ZOO_KEEPER_EXCEPTION_TYPE_UNIMPLEMENTED:return "ZOO_KEEPER_EXCEPTION_TYPE_UNIMPLEMENTED";
  case ZOO_KEEPER_EXCEPTION_TYPE_OPERATIONTIMEOUT:return "ZOO_KEEPER_EXCEPTION_TYPE_OPERATIONTIMEOUT";
  case ZOO_KEEPER_EXCEPTION_TYPE_BADARGUMENTS:return "ZOO_KEEPER_EXCEPTION_TYPE_BADARGUMENTS";
  case ZOO_KEEPER_EXCEPTION_TYPE_APIERROR:return "ZOO_KEEPER_EXCEPTION_TYPE_APIERROR";
  case ZOO_KEEPER_EXCEPTION_TYPE_NOAUTH:return "ZOO_KEEPER_EXCEPTION_TYPE_NOAUTH";
  case ZOO_KEEPER_EXCEPTION_TYPE_NOCHILDRENFOREPHEMERALS:return "ZOO_KEEPER_EXCEPTION_TYPE_NOCHILDRENFOREPHEMERALS";
  case ZOO_KEEPER_EXCEPTION_TYPE_INVALIDACL:return "ZOO_KEEPER_EXCEPTION_TYPE_INVALIDACL";
  case ZOO_KEEPER_EXCEPTION_TYPE_AUTHFAILED:return "ZOO_KEEPER_EXCEPTION_TYPE_AUTHFAILED";
  case ZOO_KEEPER_EXCEPTION_TYPE_SESSIONEXPIRED:return "ZOO_KEEPER_EXCEPTION_TYPE_SESSIONEXPIRED";
  case ZOO_KEEPER_EXCEPTION_TYPE_INVALIDCALLBACK:return "ZOO_KEEPER_EXCEPTION_TYPE_INVALIDCALLBACK";
  case ZOO_KEEPER_EXCEPTION_TYPE_SESSIONMOVED:return "ZOO_KEEPER_EXCEPTION_TYPE_SESSIONMOVED";
  case ZOO_KEEPER_EXCEPTION_TYPE_NOTREADONLY:return "ZOO_KEEPER_EXCEPTION_TYPE_NOTREADONLY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_DiscoveryInstanceType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case DISCOVERY_INSTANCE_TYPE_DYNAMIC:return "DISCOVERY_INSTANCE_TYPE_DYNAMIC";
  case DISCOVERY_INSTANCE_TYPE_STATIC:return "DISCOVERY_INSTANCE_TYPE_STATIC";
  case DISCOVERY_INSTANCE_TYPE_PERMANENT:return "DISCOVERY_INSTANCE_TYPE_PERMANENT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProviderStrategyType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROVIDER_STRATEGY_TYPE_RANDOM:return "PROVIDER_STRATEGY_TYPE_RANDOM";
  case PROVIDER_STRATEGY_TYPE_STICKY_RANDOM:return "PROVIDER_STRATEGY_TYPE_STICKY_RANDOM";
  case PROVIDER_STRATEGY_TYPE_STICKY_ROUND_ROBIN:return "PROVIDER_STRATEGY_TYPE_STICKY_ROUND_ROBIN";
  case PROVIDER_STRATEGY_TYPE_ROUND_ROBIN:return "PROVIDER_STRATEGY_TYPE_ROUND_ROBIN";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _CuratorProjectionProperties
{
  PROP_CURATOR_PROJECTION_0,
  PROP_CURATOR_PROJECTION_ID
};

/* reads a curator_projection object */
static gint32
curator_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorProjection * this_object = CURATOR_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorProjection * this_object = CURATOR_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_projection_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  CuratorProjection *self = CURATOR_PROJECTION (object);

  switch (property_id)
  {
    case PROP_CURATOR_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_projection_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  CuratorProjection *self = CURATOR_PROJECTION (object);

  switch (property_id)
  {
    case PROP_CURATOR_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_projection_instance_init (CuratorProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
curator_projection_finalize (GObject *object)
{
  CuratorProjection *tobject = CURATOR_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
curator_projection_class_init (CuratorProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_projection_read;
  struct_class->write = curator_projection_write;

  gobject_class->finalize = curator_projection_finalize;
  gobject_class->get_property = curator_projection_get_property;
  gobject_class->set_property = curator_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
curator_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ExistsSpecProperties
{
  PROP_EXISTS_SPEC_0,
  PROP_EXISTS_SPEC_PATH,
  PROP_EXISTS_SPEC_WATCHED,
  PROP_EXISTS_SPEC_ASYNC_CONTEXT
};

/* reads a exists_spec object */
static gint32
exists_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ExistsSpec * this_object = EXISTS_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->watched, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_watched = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->asyncContext != NULL)
          {
            g_free(this_object->asyncContext);
            this_object->asyncContext = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->asyncContext, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asyncContext = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
exists_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ExistsSpec * this_object = EXISTS_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ExistsSpec", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "watched", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->watched, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asyncContext", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->asyncContext, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
exists_spec_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  ExistsSpec *self = EXISTS_SPEC (object);

  switch (property_id)
  {
    case PROP_EXISTS_SPEC_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_EXISTS_SPEC_WATCHED:
      self->watched = g_value_get_boolean (value);
      self->__isset_watched = TRUE;
      break;

    case PROP_EXISTS_SPEC_ASYNC_CONTEXT:
      if (self->asyncContext != NULL)
        g_free (self->asyncContext);
      self->asyncContext = g_value_dup_string (value);
      self->__isset_asyncContext = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
exists_spec_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  ExistsSpec *self = EXISTS_SPEC (object);

  switch (property_id)
  {
    case PROP_EXISTS_SPEC_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_EXISTS_SPEC_WATCHED:
      g_value_set_boolean (value, self->watched);
      break;

    case PROP_EXISTS_SPEC_ASYNC_CONTEXT:
      g_value_set_string (value, self->asyncContext);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
exists_spec_instance_init (ExistsSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->watched = 0;
  object->__isset_watched = FALSE;
  object->asyncContext = NULL;
  object->__isset_asyncContext = FALSE;
}

static void 
exists_spec_finalize (GObject *object)
{
  ExistsSpec *tobject = EXISTS_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->asyncContext != NULL)
  {
    g_free(tobject->asyncContext);
    tobject->asyncContext = NULL;
  }
}

static void
exists_spec_class_init (ExistsSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = exists_spec_read;
  struct_class->write = exists_spec_write;

  gobject_class->finalize = exists_spec_finalize;
  gobject_class->get_property = exists_spec_get_property;
  gobject_class->set_property = exists_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_EXISTS_SPEC_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_EXISTS_SPEC_WATCHED,
     g_param_spec_boolean ("watched",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_EXISTS_SPEC_ASYNC_CONTEXT,
     g_param_spec_string ("asyncContext",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
exists_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ExistsSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) exists_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ExistsSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) exists_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ExistsSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _GetChildrenSpecProperties
{
  PROP_GET_CHILDREN_SPEC_0,
  PROP_GET_CHILDREN_SPEC_PATH,
  PROP_GET_CHILDREN_SPEC_WATCHED,
  PROP_GET_CHILDREN_SPEC_ASYNC_CONTEXT
};

/* reads a get_children_spec object */
static gint32
get_children_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  GetChildrenSpec * this_object = GET_CHILDREN_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->watched, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_watched = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->asyncContext != NULL)
          {
            g_free(this_object->asyncContext);
            this_object->asyncContext = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->asyncContext, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asyncContext = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
get_children_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  GetChildrenSpec * this_object = GET_CHILDREN_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "GetChildrenSpec", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "watched", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->watched, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asyncContext", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->asyncContext, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
get_children_spec_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  GetChildrenSpec *self = GET_CHILDREN_SPEC (object);

  switch (property_id)
  {
    case PROP_GET_CHILDREN_SPEC_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_GET_CHILDREN_SPEC_WATCHED:
      self->watched = g_value_get_boolean (value);
      self->__isset_watched = TRUE;
      break;

    case PROP_GET_CHILDREN_SPEC_ASYNC_CONTEXT:
      if (self->asyncContext != NULL)
        g_free (self->asyncContext);
      self->asyncContext = g_value_dup_string (value);
      self->__isset_asyncContext = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
get_children_spec_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  GetChildrenSpec *self = GET_CHILDREN_SPEC (object);

  switch (property_id)
  {
    case PROP_GET_CHILDREN_SPEC_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_GET_CHILDREN_SPEC_WATCHED:
      g_value_set_boolean (value, self->watched);
      break;

    case PROP_GET_CHILDREN_SPEC_ASYNC_CONTEXT:
      g_value_set_string (value, self->asyncContext);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
get_children_spec_instance_init (GetChildrenSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->watched = 0;
  object->__isset_watched = FALSE;
  object->asyncContext = NULL;
  object->__isset_asyncContext = FALSE;
}

static void 
get_children_spec_finalize (GObject *object)
{
  GetChildrenSpec *tobject = GET_CHILDREN_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->asyncContext != NULL)
  {
    g_free(tobject->asyncContext);
    tobject->asyncContext = NULL;
  }
}

static void
get_children_spec_class_init (GetChildrenSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = get_children_spec_read;
  struct_class->write = get_children_spec_write;

  gobject_class->finalize = get_children_spec_finalize;
  gobject_class->get_property = get_children_spec_get_property;
  gobject_class->set_property = get_children_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_GET_CHILDREN_SPEC_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_GET_CHILDREN_SPEC_WATCHED,
     g_param_spec_boolean ("watched",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_GET_CHILDREN_SPEC_ASYNC_CONTEXT,
     g_param_spec_string ("asyncContext",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
get_children_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (GetChildrenSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) get_children_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (GetChildrenSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) get_children_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "GetChildrenSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _GetDataSpecProperties
{
  PROP_GET_DATA_SPEC_0,
  PROP_GET_DATA_SPEC_PATH,
  PROP_GET_DATA_SPEC_WATCHED,
  PROP_GET_DATA_SPEC_ASYNC_CONTEXT,
  PROP_GET_DATA_SPEC_DECOMPRESSED
};

/* reads a get_data_spec object */
static gint32
get_data_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  GetDataSpec * this_object = GET_DATA_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->watched, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_watched = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->asyncContext != NULL)
          {
            g_free(this_object->asyncContext);
            this_object->asyncContext = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->asyncContext, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asyncContext = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->decompressed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_decompressed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
get_data_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  GetDataSpec * this_object = GET_DATA_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "GetDataSpec", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "watched", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->watched, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asyncContext", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->asyncContext, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "decompressed", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->decompressed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
get_data_spec_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  GetDataSpec *self = GET_DATA_SPEC (object);

  switch (property_id)
  {
    case PROP_GET_DATA_SPEC_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_GET_DATA_SPEC_WATCHED:
      self->watched = g_value_get_boolean (value);
      self->__isset_watched = TRUE;
      break;

    case PROP_GET_DATA_SPEC_ASYNC_CONTEXT:
      if (self->asyncContext != NULL)
        g_free (self->asyncContext);
      self->asyncContext = g_value_dup_string (value);
      self->__isset_asyncContext = TRUE;
      break;

    case PROP_GET_DATA_SPEC_DECOMPRESSED:
      self->decompressed = g_value_get_boolean (value);
      self->__isset_decompressed = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
get_data_spec_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  GetDataSpec *self = GET_DATA_SPEC (object);

  switch (property_id)
  {
    case PROP_GET_DATA_SPEC_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_GET_DATA_SPEC_WATCHED:
      g_value_set_boolean (value, self->watched);
      break;

    case PROP_GET_DATA_SPEC_ASYNC_CONTEXT:
      g_value_set_string (value, self->asyncContext);
      break;

    case PROP_GET_DATA_SPEC_DECOMPRESSED:
      g_value_set_boolean (value, self->decompressed);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
get_data_spec_instance_init (GetDataSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->watched = 0;
  object->__isset_watched = FALSE;
  object->asyncContext = NULL;
  object->__isset_asyncContext = FALSE;
  object->decompressed = 0;
  object->__isset_decompressed = FALSE;
}

static void 
get_data_spec_finalize (GObject *object)
{
  GetDataSpec *tobject = GET_DATA_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->asyncContext != NULL)
  {
    g_free(tobject->asyncContext);
    tobject->asyncContext = NULL;
  }
}

static void
get_data_spec_class_init (GetDataSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = get_data_spec_read;
  struct_class->write = get_data_spec_write;

  gobject_class->finalize = get_data_spec_finalize;
  gobject_class->get_property = get_data_spec_get_property;
  gobject_class->set_property = get_data_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_GET_DATA_SPEC_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_GET_DATA_SPEC_WATCHED,
     g_param_spec_boolean ("watched",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_GET_DATA_SPEC_ASYNC_CONTEXT,
     g_param_spec_string ("asyncContext",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_GET_DATA_SPEC_DECOMPRESSED,
     g_param_spec_boolean ("decompressed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
get_data_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (GetDataSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) get_data_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (GetDataSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) get_data_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "GetDataSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _LeaderEventProperties
{
  PROP_LEADER_EVENT_0,
  PROP_LEADER_EVENT_PATH,
  PROP_LEADER_EVENT_PARTICIPANT_ID,
  PROP_LEADER_EVENT_IS_LEADER
};

/* reads a leader_event object */
static gint32
leader_event_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LeaderEvent * this_object = LEADER_EVENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->participantId != NULL)
          {
            g_free(this_object->participantId);
            this_object->participantId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->participantId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_participantId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isLeader, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_isLeader = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
leader_event_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LeaderEvent * this_object = LEADER_EVENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LeaderEvent", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "participantId", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->participantId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isLeader", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isLeader, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
leader_event_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  LeaderEvent *self = LEADER_EVENT (object);

  switch (property_id)
  {
    case PROP_LEADER_EVENT_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_LEADER_EVENT_PARTICIPANT_ID:
      if (self->participantId != NULL)
        g_free (self->participantId);
      self->participantId = g_value_dup_string (value);
      self->__isset_participantId = TRUE;
      break;

    case PROP_LEADER_EVENT_IS_LEADER:
      self->isLeader = g_value_get_boolean (value);
      self->__isset_isLeader = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
leader_event_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  LeaderEvent *self = LEADER_EVENT (object);

  switch (property_id)
  {
    case PROP_LEADER_EVENT_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_LEADER_EVENT_PARTICIPANT_ID:
      g_value_set_string (value, self->participantId);
      break;

    case PROP_LEADER_EVENT_IS_LEADER:
      g_value_set_boolean (value, self->isLeader);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
leader_event_instance_init (LeaderEvent * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->participantId = NULL;
  object->__isset_participantId = FALSE;
  object->isLeader = 0;
  object->__isset_isLeader = FALSE;
}

static void 
leader_event_finalize (GObject *object)
{
  LeaderEvent *tobject = LEADER_EVENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->participantId != NULL)
  {
    g_free(tobject->participantId);
    tobject->participantId = NULL;
  }
}

static void
leader_event_class_init (LeaderEventClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = leader_event_read;
  struct_class->write = leader_event_write;

  gobject_class->finalize = leader_event_finalize;
  gobject_class->get_property = leader_event_get_property;
  gobject_class->set_property = leader_event_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LEADER_EVENT_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LEADER_EVENT_PARTICIPANT_ID,
     g_param_spec_string ("participantId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LEADER_EVENT_IS_LEADER,
     g_param_spec_boolean ("isLeader",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
leader_event_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LeaderEventClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) leader_event_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LeaderEvent),
      0, /* n_preallocs */
      (GInstanceInitFunc) leader_event_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LeaderEventType",
                                   &type_info, 0);
  }

  return type;
}

enum _LeaderProjectionProperties
{
  PROP_LEADER_PROJECTION_0,
  PROP_LEADER_PROJECTION_ID
};

/* reads a leader_projection object */
static gint32
leader_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LeaderProjection * this_object = LEADER_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
leader_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LeaderProjection * this_object = LEADER_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LeaderProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
leader_projection_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  LeaderProjection *self = LEADER_PROJECTION (object);

  switch (property_id)
  {
    case PROP_LEADER_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
leader_projection_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  LeaderProjection *self = LEADER_PROJECTION (object);

  switch (property_id)
  {
    case PROP_LEADER_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
leader_projection_instance_init (LeaderProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
leader_projection_finalize (GObject *object)
{
  LeaderProjection *tobject = LEADER_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
leader_projection_class_init (LeaderProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = leader_projection_read;
  struct_class->write = leader_projection_write;

  gobject_class->finalize = leader_projection_finalize;
  gobject_class->get_property = leader_projection_get_property;
  gobject_class->set_property = leader_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LEADER_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
leader_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LeaderProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) leader_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LeaderProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) leader_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LeaderProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _LeaderResultProperties
{
  PROP_LEADER_RESULT_0,
  PROP_LEADER_RESULT_PROJECTION,
  PROP_LEADER_RESULT_IS_LEADER
};

/* reads a leader_result object */
static gint32
leader_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LeaderResult * this_object = LEADER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isLeader, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_isLeader = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
leader_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LeaderResult * this_object = LEADER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LeaderResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isLeader", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isLeader, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
leader_result_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  LeaderResult *self = LEADER_RESULT (object);

  switch (property_id)
  {
    case PROP_LEADER_RESULT_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_LEADER_RESULT_IS_LEADER:
      self->isLeader = g_value_get_boolean (value);
      self->__isset_isLeader = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
leader_result_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  LeaderResult *self = LEADER_RESULT (object);

  switch (property_id)
  {
    case PROP_LEADER_RESULT_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_LEADER_RESULT_IS_LEADER:
      g_value_set_boolean (value, self->isLeader);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
leader_result_instance_init (LeaderResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_LEADER_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->isLeader = 0;
  object->__isset_isLeader = FALSE;
}

static void 
leader_result_finalize (GObject *object)
{
  LeaderResult *tobject = LEADER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
}

static void
leader_result_class_init (LeaderResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = leader_result_read;
  struct_class->write = leader_result_write;

  gobject_class->finalize = leader_result_finalize;
  gobject_class->get_property = leader_result_get_property;
  gobject_class->set_property = leader_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LEADER_RESULT_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_LEADER_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LEADER_RESULT_IS_LEADER,
     g_param_spec_boolean ("isLeader",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
leader_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LeaderResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) leader_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LeaderResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) leader_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LeaderResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _LeaseProjectionProperties
{
  PROP_LEASE_PROJECTION_0,
  PROP_LEASE_PROJECTION_ID
};

/* reads a lease_projection object */
static gint32
lease_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LeaseProjection * this_object = LEASE_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
lease_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LeaseProjection * this_object = LEASE_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LeaseProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
lease_projection_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  LeaseProjection *self = LEASE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_LEASE_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
lease_projection_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  LeaseProjection *self = LEASE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_LEASE_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
lease_projection_instance_init (LeaseProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
lease_projection_finalize (GObject *object)
{
  LeaseProjection *tobject = LEASE_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
lease_projection_class_init (LeaseProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = lease_projection_read;
  struct_class->write = lease_projection_write;

  gobject_class->finalize = lease_projection_finalize;
  gobject_class->get_property = lease_projection_get_property;
  gobject_class->set_property = lease_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LEASE_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
lease_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LeaseProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) lease_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LeaseProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) lease_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LeaseProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _LockProjectionProperties
{
  PROP_LOCK_PROJECTION_0,
  PROP_LOCK_PROJECTION_ID
};

/* reads a lock_projection object */
static gint32
lock_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LockProjection * this_object = LOCK_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
lock_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LockProjection * this_object = LOCK_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LockProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
lock_projection_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  LockProjection *self = LOCK_PROJECTION (object);

  switch (property_id)
  {
    case PROP_LOCK_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
lock_projection_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  LockProjection *self = LOCK_PROJECTION (object);

  switch (property_id)
  {
    case PROP_LOCK_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
lock_projection_instance_init (LockProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
lock_projection_finalize (GObject *object)
{
  LockProjection *tobject = LOCK_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
lock_projection_class_init (LockProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = lock_projection_read;
  struct_class->write = lock_projection_write;

  gobject_class->finalize = lock_projection_finalize;
  gobject_class->get_property = lock_projection_get_property;
  gobject_class->set_property = lock_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LOCK_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
lock_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LockProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) lock_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LockProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) lock_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LockProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _NodeCacheProjectionProperties
{
  PROP_NODE_CACHE_PROJECTION_0,
  PROP_NODE_CACHE_PROJECTION_ID
};

/* reads a node_cache_projection object */
static gint32
node_cache_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NodeCacheProjection * this_object = NODE_CACHE_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_cache_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NodeCacheProjection * this_object = NODE_CACHE_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NodeCacheProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_cache_projection_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  NodeCacheProjection *self = NODE_CACHE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_NODE_CACHE_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_cache_projection_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  NodeCacheProjection *self = NODE_CACHE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_NODE_CACHE_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_cache_projection_instance_init (NodeCacheProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
node_cache_projection_finalize (GObject *object)
{
  NodeCacheProjection *tobject = NODE_CACHE_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
node_cache_projection_class_init (NodeCacheProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_cache_projection_read;
  struct_class->write = node_cache_projection_write;

  gobject_class->finalize = node_cache_projection_finalize;
  gobject_class->get_property = node_cache_projection_get_property;
  gobject_class->set_property = node_cache_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_CACHE_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
node_cache_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeCacheProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_cache_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NodeCacheProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_cache_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeCacheProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _OptionalChildrenListProperties
{
  PROP_OPTIONAL_CHILDREN_LIST_0,
  PROP_OPTIONAL_CHILDREN_LIST_CHILDREN
};

/* reads a optional_children_list object */
static gint32
optional_children_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  OptionalChildrenList * this_object = OPTIONAL_CHILDREN_LIST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem0 = NULL;
              if (_elem0 != NULL)
              {
                g_free(_elem0);
                _elem0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->children, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_children = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
optional_children_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  OptionalChildrenList * this_object = OPTIONAL_CHILDREN_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OptionalChildrenList", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "children", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->children->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < this_object->children->len; i1++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->children, i1)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
optional_children_list_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  OptionalChildrenList *self = OPTIONAL_CHILDREN_LIST (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_CHILDREN_LIST_CHILDREN:
      if (self->children != NULL)
        g_ptr_array_unref (self->children);
      self->children = g_value_dup_boxed (value);
      self->__isset_children = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
optional_children_list_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  OptionalChildrenList *self = OPTIONAL_CHILDREN_LIST (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_CHILDREN_LIST_CHILDREN:
      g_value_set_boxed (value, self->children);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
optional_children_list_instance_init (OptionalChildrenList * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->children = g_ptr_array_new_with_free_func (g_free);
  object->__isset_children = FALSE;
}

static void 
optional_children_list_finalize (GObject *object)
{
  OptionalChildrenList *tobject = OPTIONAL_CHILDREN_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->children != NULL)
  {
    g_ptr_array_unref (tobject->children);
    tobject->children = NULL;
  }
}

static void
optional_children_list_class_init (OptionalChildrenListClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = optional_children_list_read;
  struct_class->write = optional_children_list_write;

  gobject_class->finalize = optional_children_list_finalize;
  gobject_class->get_property = optional_children_list_get_property;
  gobject_class->set_property = optional_children_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_OPTIONAL_CHILDREN_LIST_CHILDREN,
     g_param_spec_boxed ("children",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
optional_children_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (OptionalChildrenListClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) optional_children_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (OptionalChildrenList),
      0, /* n_preallocs */
      (GInstanceInitFunc) optional_children_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "OptionalChildrenListType",
                                   &type_info, 0);
  }

  return type;
}

enum _OptionalDataProperties
{
  PROP_OPTIONAL_DATA_0,
  PROP_OPTIONAL_DATA_DATA
};

/* reads a optional_data object */
static gint32
optional_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  OptionalData * this_object = OPTIONAL_DATA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
optional_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  OptionalData * this_object = OPTIONAL_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OptionalData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->data)->data, ((GByteArray *) this_object->data)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
optional_data_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  OptionalData *self = OPTIONAL_DATA (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_DATA_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
optional_data_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  OptionalData *self = OPTIONAL_DATA (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_DATA_DATA:
      g_value_set_boxed (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
optional_data_instance_init (OptionalData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->data = NULL;
  object->__isset_data = FALSE;
}

static void 
optional_data_finalize (GObject *object)
{
  OptionalData *tobject = OPTIONAL_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
}

static void
optional_data_class_init (OptionalDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = optional_data_read;
  struct_class->write = optional_data_write;

  gobject_class->finalize = optional_data_finalize;
  gobject_class->get_property = optional_data_get_property;
  gobject_class->set_property = optional_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_OPTIONAL_DATA_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
optional_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (OptionalDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) optional_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (OptionalData),
      0, /* n_preallocs */
      (GInstanceInitFunc) optional_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "OptionalDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _OptionalLockProjectionProperties
{
  PROP_OPTIONAL_LOCK_PROJECTION_0,
  PROP_OPTIONAL_LOCK_PROJECTION_LOCK_PROJECTION
};

/* reads a optional_lock_projection object */
static gint32
optional_lock_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  OptionalLockProjection * this_object = OPTIONAL_LOCK_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->lockProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_lockProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
optional_lock_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  OptionalLockProjection * this_object = OPTIONAL_LOCK_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OptionalLockProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "lockProjection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->lockProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
optional_lock_projection_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  OptionalLockProjection *self = OPTIONAL_LOCK_PROJECTION (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_LOCK_PROJECTION_LOCK_PROJECTION:
      if (self->lockProjection != NULL)
        g_object_unref (self->lockProjection);
      self->lockProjection = g_value_dup_object (value);
      self->__isset_lockProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
optional_lock_projection_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  OptionalLockProjection *self = OPTIONAL_LOCK_PROJECTION (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_LOCK_PROJECTION_LOCK_PROJECTION:
      g_value_set_object (value, self->lockProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
optional_lock_projection_instance_init (OptionalLockProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->lockProjection = g_object_new (TYPE_LOCK_PROJECTION, NULL);
  object->__isset_lockProjection = FALSE;
}

static void 
optional_lock_projection_finalize (GObject *object)
{
  OptionalLockProjection *tobject = OPTIONAL_LOCK_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->lockProjection != NULL)
  {
    g_object_unref(tobject->lockProjection);
    tobject->lockProjection = NULL;
  }
}

static void
optional_lock_projection_class_init (OptionalLockProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = optional_lock_projection_read;
  struct_class->write = optional_lock_projection_write;

  gobject_class->finalize = optional_lock_projection_finalize;
  gobject_class->get_property = optional_lock_projection_get_property;
  gobject_class->set_property = optional_lock_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_OPTIONAL_LOCK_PROJECTION_LOCK_PROJECTION,
     g_param_spec_object ("lockProjection",
                         NULL,
                         NULL,
                         TYPE_LOCK_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
optional_lock_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (OptionalLockProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) optional_lock_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (OptionalLockProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) optional_lock_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "OptionalLockProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _OptionalPathProperties
{
  PROP_OPTIONAL_PATH_0,
  PROP_OPTIONAL_PATH_PATH
};

/* reads a optional_path object */
static gint32
optional_path_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  OptionalPath * this_object = OPTIONAL_PATH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
optional_path_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  OptionalPath * this_object = OPTIONAL_PATH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OptionalPath", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
optional_path_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  OptionalPath *self = OPTIONAL_PATH (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_PATH_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
optional_path_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  OptionalPath *self = OPTIONAL_PATH (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_PATH_PATH:
      g_value_set_string (value, self->path);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
optional_path_instance_init (OptionalPath * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
}

static void 
optional_path_finalize (GObject *object)
{
  OptionalPath *tobject = OPTIONAL_PATH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
optional_path_class_init (OptionalPathClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = optional_path_read;
  struct_class->write = optional_path_write;

  gobject_class->finalize = optional_path_finalize;
  gobject_class->get_property = optional_path_get_property;
  gobject_class->set_property = optional_path_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_OPTIONAL_PATH_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
optional_path_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (OptionalPathClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) optional_path_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (OptionalPath),
      0, /* n_preallocs */
      (GInstanceInitFunc) optional_path_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "OptionalPathType",
                                   &type_info, 0);
  }

  return type;
}

enum _PathChildrenCacheProjectionProperties
{
  PROP_PATH_CHILDREN_CACHE_PROJECTION_0,
  PROP_PATH_CHILDREN_CACHE_PROJECTION_ID
};

/* reads a path_children_cache_projection object */
static gint32
path_children_cache_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PathChildrenCacheProjection * this_object = PATH_CHILDREN_CACHE_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
path_children_cache_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PathChildrenCacheProjection * this_object = PATH_CHILDREN_CACHE_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PathChildrenCacheProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
path_children_cache_projection_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  PathChildrenCacheProjection *self = PATH_CHILDREN_CACHE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_PATH_CHILDREN_CACHE_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
path_children_cache_projection_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  PathChildrenCacheProjection *self = PATH_CHILDREN_CACHE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_PATH_CHILDREN_CACHE_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
path_children_cache_projection_instance_init (PathChildrenCacheProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
path_children_cache_projection_finalize (GObject *object)
{
  PathChildrenCacheProjection *tobject = PATH_CHILDREN_CACHE_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
path_children_cache_projection_class_init (PathChildrenCacheProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = path_children_cache_projection_read;
  struct_class->write = path_children_cache_projection_write;

  gobject_class->finalize = path_children_cache_projection_finalize;
  gobject_class->get_property = path_children_cache_projection_get_property;
  gobject_class->set_property = path_children_cache_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PATH_CHILDREN_CACHE_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
path_children_cache_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PathChildrenCacheProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) path_children_cache_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PathChildrenCacheProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) path_children_cache_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PathChildrenCacheProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _PersistentEphemeralNodeProjectionProperties
{
  PROP_PERSISTENT_EPHEMERAL_NODE_PROJECTION_0,
  PROP_PERSISTENT_EPHEMERAL_NODE_PROJECTION_ID
};

/* reads a persistent_ephemeral_node_projection object */
static gint32
persistent_ephemeral_node_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PersistentEphemeralNodeProjection * this_object = PERSISTENT_EPHEMERAL_NODE_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
persistent_ephemeral_node_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PersistentEphemeralNodeProjection * this_object = PERSISTENT_EPHEMERAL_NODE_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PersistentEphemeralNodeProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
persistent_ephemeral_node_projection_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  PersistentEphemeralNodeProjection *self = PERSISTENT_EPHEMERAL_NODE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_PERSISTENT_EPHEMERAL_NODE_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
persistent_ephemeral_node_projection_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  PersistentEphemeralNodeProjection *self = PERSISTENT_EPHEMERAL_NODE_PROJECTION (object);

  switch (property_id)
  {
    case PROP_PERSISTENT_EPHEMERAL_NODE_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
persistent_ephemeral_node_projection_instance_init (PersistentEphemeralNodeProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
persistent_ephemeral_node_projection_finalize (GObject *object)
{
  PersistentEphemeralNodeProjection *tobject = PERSISTENT_EPHEMERAL_NODE_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
persistent_ephemeral_node_projection_class_init (PersistentEphemeralNodeProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = persistent_ephemeral_node_projection_read;
  struct_class->write = persistent_ephemeral_node_projection_write;

  gobject_class->finalize = persistent_ephemeral_node_projection_finalize;
  gobject_class->get_property = persistent_ephemeral_node_projection_get_property;
  gobject_class->set_property = persistent_ephemeral_node_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PERSISTENT_EPHEMERAL_NODE_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
persistent_ephemeral_node_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PersistentEphemeralNodeProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) persistent_ephemeral_node_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PersistentEphemeralNodeProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) persistent_ephemeral_node_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PersistentEphemeralNodeProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _IdProperties
{
  PROP_ID_0,
  PROP_ID_SCHEME,
  PROP_ID_ID
};

/* reads a id object */
static gint32
id_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Id * this_object = ID(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->scheme != NULL)
          {
            g_free(this_object->scheme);
            this_object->scheme = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->scheme, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_scheme = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
id_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Id * this_object = ID(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Id", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "scheme", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->scheme, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
id_set_property (GObject *object,
                 guint property_id,
                 const GValue *value,
                 GParamSpec *pspec)
{
  Id *self = ID (object);

  switch (property_id)
  {
    case PROP_ID_SCHEME:
      if (self->scheme != NULL)
        g_free (self->scheme);
      self->scheme = g_value_dup_string (value);
      self->__isset_scheme = TRUE;
      break;

    case PROP_ID_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
id_get_property (GObject *object,
                 guint property_id,
                 GValue *value,
                 GParamSpec *pspec)
{
  Id *self = ID (object);

  switch (property_id)
  {
    case PROP_ID_SCHEME:
      g_value_set_string (value, self->scheme);
      break;

    case PROP_ID_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
id_instance_init (Id * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->scheme = NULL;
  object->__isset_scheme = FALSE;
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
id_finalize (GObject *object)
{
  Id *tobject = ID (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->scheme != NULL)
  {
    g_free(tobject->scheme);
    tobject->scheme = NULL;
  }
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
id_class_init (IdClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = id_read;
  struct_class->write = id_write;

  gobject_class->finalize = id_finalize;
  gobject_class->get_property = id_get_property;
  gobject_class->set_property = id_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ID_SCHEME,
     g_param_spec_string ("scheme",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ID_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
id_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IdClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) id_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Id),
      0, /* n_preallocs */
      (GInstanceInitFunc) id_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IdType",
                                   &type_info, 0);
  }

  return type;
}

enum _ParticipantProperties
{
  PROP_PARTICIPANT_0,
  PROP_PARTICIPANT_ID,
  PROP_PARTICIPANT_IS_LEADER
};

/* reads a participant object */
static gint32
participant_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Participant * this_object = PARTICIPANT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isLeader, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_isLeader = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
participant_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Participant * this_object = PARTICIPANT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Participant", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isLeader", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isLeader, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
participant_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  Participant *self = PARTICIPANT (object);

  switch (property_id)
  {
    case PROP_PARTICIPANT_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    case PROP_PARTICIPANT_IS_LEADER:
      self->isLeader = g_value_get_boolean (value);
      self->__isset_isLeader = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
participant_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  Participant *self = PARTICIPANT (object);

  switch (property_id)
  {
    case PROP_PARTICIPANT_ID:
      g_value_set_string (value, self->id);
      break;

    case PROP_PARTICIPANT_IS_LEADER:
      g_value_set_boolean (value, self->isLeader);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
participant_instance_init (Participant * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
  object->isLeader = 0;
  object->__isset_isLeader = FALSE;
}

static void 
participant_finalize (GObject *object)
{
  Participant *tobject = PARTICIPANT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
participant_class_init (ParticipantClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = participant_read;
  struct_class->write = participant_write;

  gobject_class->finalize = participant_finalize;
  gobject_class->get_property = participant_get_property;
  gobject_class->set_property = participant_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PARTICIPANT_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PARTICIPANT_IS_LEADER,
     g_param_spec_boolean ("isLeader",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
participant_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ParticipantClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) participant_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Participant),
      0, /* n_preallocs */
      (GInstanceInitFunc) participant_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ParticipantType",
                                   &type_info, 0);
  }

  return type;
}

enum _StatProperties
{
  PROP_STAT_0,
  PROP_STAT_CZXID,
  PROP_STAT_MZXID,
  PROP_STAT_CTIME,
  PROP_STAT_MTIME,
  PROP_STAT_VERSION,
  PROP_STAT_CVERSION,
  PROP_STAT_AVERSION,
  PROP_STAT_EPHEMERAL_OWNER,
  PROP_STAT_DATA_LENGTH,
  PROP_STAT_NUM_CHILDREN,
  PROP_STAT_PZXID
};

/* reads a stat object */
static gint32
stat_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Stat * this_object = STAT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->czxid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_czxid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->mzxid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mzxid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ctime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ctime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->mtime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mtime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cversion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cversion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->aversion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_aversion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ephemeralOwner, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ephemeralOwner = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->dataLength, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dataLength = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numChildren, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_numChildren = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->pzxid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pzxid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
stat_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Stat * this_object = STAT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Stat", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "czxid", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->czxid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mzxid", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->mzxid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ctime", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ctime, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mtime", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->mtime, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->version, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cversion", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->cversion, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aversion", T_I32, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->aversion, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ephemeralOwner", T_I64, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ephemeralOwner, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "dataLength", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->dataLength, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numChildren", T_I32, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numChildren, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pzxid", T_I64, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->pzxid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
stat_set_property (GObject *object,
                   guint property_id,
                   const GValue *value,
                   GParamSpec *pspec)
{
  Stat *self = STAT (object);

  switch (property_id)
  {
    case PROP_STAT_CZXID:
      self->czxid = g_value_get_int64 (value);
      self->__isset_czxid = TRUE;
      break;

    case PROP_STAT_MZXID:
      self->mzxid = g_value_get_int64 (value);
      self->__isset_mzxid = TRUE;
      break;

    case PROP_STAT_CTIME:
      self->ctime = g_value_get_int64 (value);
      self->__isset_ctime = TRUE;
      break;

    case PROP_STAT_MTIME:
      self->mtime = g_value_get_int64 (value);
      self->__isset_mtime = TRUE;
      break;

    case PROP_STAT_VERSION:
      self->version = g_value_get_int (value);
      self->__isset_version = TRUE;
      break;

    case PROP_STAT_CVERSION:
      self->cversion = g_value_get_int (value);
      self->__isset_cversion = TRUE;
      break;

    case PROP_STAT_AVERSION:
      self->aversion = g_value_get_int (value);
      self->__isset_aversion = TRUE;
      break;

    case PROP_STAT_EPHEMERAL_OWNER:
      self->ephemeralOwner = g_value_get_int64 (value);
      self->__isset_ephemeralOwner = TRUE;
      break;

    case PROP_STAT_DATA_LENGTH:
      self->dataLength = g_value_get_int (value);
      self->__isset_dataLength = TRUE;
      break;

    case PROP_STAT_NUM_CHILDREN:
      self->numChildren = g_value_get_int (value);
      self->__isset_numChildren = TRUE;
      break;

    case PROP_STAT_PZXID:
      self->pzxid = g_value_get_int64 (value);
      self->__isset_pzxid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
stat_get_property (GObject *object,
                   guint property_id,
                   GValue *value,
                   GParamSpec *pspec)
{
  Stat *self = STAT (object);

  switch (property_id)
  {
    case PROP_STAT_CZXID:
      g_value_set_int64 (value, self->czxid);
      break;

    case PROP_STAT_MZXID:
      g_value_set_int64 (value, self->mzxid);
      break;

    case PROP_STAT_CTIME:
      g_value_set_int64 (value, self->ctime);
      break;

    case PROP_STAT_MTIME:
      g_value_set_int64 (value, self->mtime);
      break;

    case PROP_STAT_VERSION:
      g_value_set_int (value, self->version);
      break;

    case PROP_STAT_CVERSION:
      g_value_set_int (value, self->cversion);
      break;

    case PROP_STAT_AVERSION:
      g_value_set_int (value, self->aversion);
      break;

    case PROP_STAT_EPHEMERAL_OWNER:
      g_value_set_int64 (value, self->ephemeralOwner);
      break;

    case PROP_STAT_DATA_LENGTH:
      g_value_set_int (value, self->dataLength);
      break;

    case PROP_STAT_NUM_CHILDREN:
      g_value_set_int (value, self->numChildren);
      break;

    case PROP_STAT_PZXID:
      g_value_set_int64 (value, self->pzxid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
stat_instance_init (Stat * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->czxid = 0;
  object->__isset_czxid = FALSE;
  object->mzxid = 0;
  object->__isset_mzxid = FALSE;
  object->ctime = 0;
  object->__isset_ctime = FALSE;
  object->mtime = 0;
  object->__isset_mtime = FALSE;
  object->version = 0;
  object->__isset_version = FALSE;
  object->cversion = 0;
  object->__isset_cversion = FALSE;
  object->aversion = 0;
  object->__isset_aversion = FALSE;
  object->ephemeralOwner = 0;
  object->__isset_ephemeralOwner = FALSE;
  object->dataLength = 0;
  object->__isset_dataLength = FALSE;
  object->numChildren = 0;
  object->__isset_numChildren = FALSE;
  object->pzxid = 0;
  object->__isset_pzxid = FALSE;
}

static void 
stat_finalize (GObject *object)
{
  Stat *tobject = STAT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
stat_class_init (StatClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = stat_read;
  struct_class->write = stat_write;

  gobject_class->finalize = stat_finalize;
  gobject_class->get_property = stat_get_property;
  gobject_class->set_property = stat_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_CZXID,
     g_param_spec_int64 ("czxid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_MZXID,
     g_param_spec_int64 ("mzxid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_CTIME,
     g_param_spec_int64 ("ctime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_MTIME,
     g_param_spec_int64 ("mtime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_VERSION,
     g_param_spec_int ("version",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_CVERSION,
     g_param_spec_int ("cversion",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_AVERSION,
     g_param_spec_int ("aversion",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_EPHEMERAL_OWNER,
     g_param_spec_int64 ("ephemeralOwner",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_DATA_LENGTH,
     g_param_spec_int ("dataLength",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_NUM_CHILDREN,
     g_param_spec_int ("numChildren",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STAT_PZXID,
     g_param_spec_int64 ("pzxid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
stat_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (StatClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) stat_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Stat),
      0, /* n_preallocs */
      (GInstanceInitFunc) stat_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "StatType",
                                   &type_info, 0);
  }

  return type;
}

enum _WatchedEventProperties
{
  PROP_WATCHED_EVENT_0,
  PROP_WATCHED_EVENT_KEEPER_STATE,
  PROP_WATCHED_EVENT_EVENT_TYPE,
  PROP_WATCHED_EVENT_PATH
};

/* reads a watched_event object */
static gint32
watched_event_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WatchedEvent * this_object = WATCHED_EVENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast2;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->keeperState = (KeeperState)ecast2;
          this_object->__isset_keeperState = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast3;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->eventType = (EventType)ecast3;
          this_object->__isset_eventType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
watched_event_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WatchedEvent * this_object = WATCHED_EVENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WatchedEvent", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "keeperState", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->keeperState, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "eventType", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->eventType, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
watched_event_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  WatchedEvent *self = WATCHED_EVENT (object);

  switch (property_id)
  {
    case PROP_WATCHED_EVENT_KEEPER_STATE:
      self->keeperState = g_value_get_int (value);
      self->__isset_keeperState = TRUE;
      break;

    case PROP_WATCHED_EVENT_EVENT_TYPE:
      self->eventType = g_value_get_int (value);
      self->__isset_eventType = TRUE;
      break;

    case PROP_WATCHED_EVENT_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
watched_event_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  WatchedEvent *self = WATCHED_EVENT (object);

  switch (property_id)
  {
    case PROP_WATCHED_EVENT_KEEPER_STATE:
      g_value_set_int (value, self->keeperState);
      break;

    case PROP_WATCHED_EVENT_EVENT_TYPE:
      g_value_set_int (value, self->eventType);
      break;

    case PROP_WATCHED_EVENT_PATH:
      g_value_set_string (value, self->path);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
watched_event_instance_init (WatchedEvent * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_keeperState = FALSE;
  object->__isset_eventType = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
}

static void 
watched_event_finalize (GObject *object)
{
  WatchedEvent *tobject = WATCHED_EVENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
watched_event_class_init (WatchedEventClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = watched_event_read;
  struct_class->write = watched_event_write;

  gobject_class->finalize = watched_event_finalize;
  gobject_class->get_property = watched_event_get_property;
  gobject_class->set_property = watched_event_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WATCHED_EVENT_KEEPER_STATE,
     g_param_spec_int ("keeperState",
                       NULL,
                       NULL,
                       0,
                       7,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WATCHED_EVENT_EVENT_TYPE,
     g_param_spec_int ("eventType",
                       NULL,
                       NULL,
                       0,
                       4,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WATCHED_EVENT_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
watched_event_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WatchedEventClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) watched_event_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WatchedEvent),
      0, /* n_preallocs */
      (GInstanceInitFunc) watched_event_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WatchedEventType",
                                   &type_info, 0);
  }

  return type;
}

enum _VersionProperties
{
  PROP_VERSION_0,
  PROP_VERSION_VERSION
};

/* reads a version object */
static gint32
version_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Version * this_object = VERSION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
version_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Version * this_object = VERSION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Version", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->version, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
version_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Version *self = VERSION (object);

  switch (property_id)
  {
    case PROP_VERSION_VERSION:
      self->version = g_value_get_int (value);
      self->__isset_version = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
version_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Version *self = VERSION (object);

  switch (property_id)
  {
    case PROP_VERSION_VERSION:
      g_value_set_int (value, self->version);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
version_instance_init (Version * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->version = 0;
  object->__isset_version = FALSE;
}

static void 
version_finalize (GObject *object)
{
  Version *tobject = VERSION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
version_class_init (VersionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = version_read;
  struct_class->write = version_write;

  gobject_class->finalize = version_finalize;
  gobject_class->get_property = version_get_property;
  gobject_class->set_property = version_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_VERSION_VERSION,
     g_param_spec_int ("version",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
version_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (VersionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) version_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Version),
      0, /* n_preallocs */
      (GInstanceInitFunc) version_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "VersionType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryProjectionProperties
{
  PROP_DISCOVERY_PROJECTION_0,
  PROP_DISCOVERY_PROJECTION_ID
};

/* reads a discovery_projection object */
static gint32
discovery_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryProjection * this_object = DISCOVERY_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryProjection * this_object = DISCOVERY_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_projection_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  DiscoveryProjection *self = DISCOVERY_PROJECTION (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_projection_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  DiscoveryProjection *self = DISCOVERY_PROJECTION (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_projection_instance_init (DiscoveryProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
discovery_projection_finalize (GObject *object)
{
  DiscoveryProjection *tobject = DISCOVERY_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
discovery_projection_class_init (DiscoveryProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_projection_read;
  struct_class->write = discovery_projection_write;

  gobject_class->finalize = discovery_projection_finalize;
  gobject_class->get_property = discovery_projection_get_property;
  gobject_class->set_property = discovery_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
discovery_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryProviderProjectionProperties
{
  PROP_DISCOVERY_PROVIDER_PROJECTION_0,
  PROP_DISCOVERY_PROVIDER_PROJECTION_ID
};

/* reads a discovery_provider_projection object */
static gint32
discovery_provider_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryProviderProjection * this_object = DISCOVERY_PROVIDER_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_provider_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryProviderProjection * this_object = DISCOVERY_PROVIDER_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryProviderProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_provider_projection_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  DiscoveryProviderProjection *self = DISCOVERY_PROVIDER_PROJECTION (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_PROVIDER_PROJECTION_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_provider_projection_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  DiscoveryProviderProjection *self = DISCOVERY_PROVIDER_PROJECTION (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_PROVIDER_PROJECTION_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_provider_projection_instance_init (DiscoveryProviderProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
discovery_provider_projection_finalize (GObject *object)
{
  DiscoveryProviderProjection *tobject = DISCOVERY_PROVIDER_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
discovery_provider_projection_class_init (DiscoveryProviderProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_provider_projection_read;
  struct_class->write = discovery_provider_projection_write;

  gobject_class->finalize = discovery_provider_projection_finalize;
  gobject_class->get_property = discovery_provider_projection_get_property;
  gobject_class->set_property = discovery_provider_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_PROVIDER_PROJECTION_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
discovery_provider_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryProviderProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_provider_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryProviderProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_provider_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryProviderProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _CreateSpecProperties
{
  PROP_CREATE_SPEC_0,
  PROP_CREATE_SPEC_PATH,
  PROP_CREATE_SPEC_DATA,
  PROP_CREATE_SPEC_MODE,
  PROP_CREATE_SPEC_ASYNC_CONTEXT,
  PROP_CREATE_SPEC_COMPRESSED,
  PROP_CREATE_SPEC_CREATING_PARENTS_IF_NEEDED,
  PROP_CREATE_SPEC_WITH_PROTECTION,
  PROP_CREATE_SPEC_CREATING_PARENT_CONTAINERS_IF_NEEDED
};

/* reads a create_spec object */
static gint32
create_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CreateSpec * this_object = CREATE_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast4;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->mode = (CreateMode)ecast4;
          this_object->__isset_mode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->asyncContext != NULL)
          {
            g_free(this_object->asyncContext);
            this_object->asyncContext = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->asyncContext, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asyncContext = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->compressed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compressed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->creatingParentsIfNeeded, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_creatingParentsIfNeeded = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withProtection, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withProtection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->creatingParentContainersIfNeeded, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_creatingParentContainersIfNeeded = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
create_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CreateSpec * this_object = CREATE_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CreateSpec", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->data)->data, ((GByteArray *) this_object->data)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mode", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->mode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asyncContext", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->asyncContext, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compressed", T_BOOL, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->compressed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "creatingParentsIfNeeded", T_BOOL, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->creatingParentsIfNeeded, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withProtection", T_BOOL, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withProtection, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "creatingParentContainersIfNeeded", T_BOOL, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->creatingParentContainersIfNeeded, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
create_spec_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  CreateSpec *self = CREATE_SPEC (object);

  switch (property_id)
  {
    case PROP_CREATE_SPEC_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CREATE_SPEC_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    case PROP_CREATE_SPEC_MODE:
      self->mode = g_value_get_int (value);
      self->__isset_mode = TRUE;
      break;

    case PROP_CREATE_SPEC_ASYNC_CONTEXT:
      if (self->asyncContext != NULL)
        g_free (self->asyncContext);
      self->asyncContext = g_value_dup_string (value);
      self->__isset_asyncContext = TRUE;
      break;

    case PROP_CREATE_SPEC_COMPRESSED:
      self->compressed = g_value_get_boolean (value);
      self->__isset_compressed = TRUE;
      break;

    case PROP_CREATE_SPEC_CREATING_PARENTS_IF_NEEDED:
      self->creatingParentsIfNeeded = g_value_get_boolean (value);
      self->__isset_creatingParentsIfNeeded = TRUE;
      break;

    case PROP_CREATE_SPEC_WITH_PROTECTION:
      self->withProtection = g_value_get_boolean (value);
      self->__isset_withProtection = TRUE;
      break;

    case PROP_CREATE_SPEC_CREATING_PARENT_CONTAINERS_IF_NEEDED:
      self->creatingParentContainersIfNeeded = g_value_get_boolean (value);
      self->__isset_creatingParentContainersIfNeeded = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
create_spec_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  CreateSpec *self = CREATE_SPEC (object);

  switch (property_id)
  {
    case PROP_CREATE_SPEC_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CREATE_SPEC_DATA:
      g_value_set_boxed (value, self->data);
      break;

    case PROP_CREATE_SPEC_MODE:
      g_value_set_int (value, self->mode);
      break;

    case PROP_CREATE_SPEC_ASYNC_CONTEXT:
      g_value_set_string (value, self->asyncContext);
      break;

    case PROP_CREATE_SPEC_COMPRESSED:
      g_value_set_boolean (value, self->compressed);
      break;

    case PROP_CREATE_SPEC_CREATING_PARENTS_IF_NEEDED:
      g_value_set_boolean (value, self->creatingParentsIfNeeded);
      break;

    case PROP_CREATE_SPEC_WITH_PROTECTION:
      g_value_set_boolean (value, self->withProtection);
      break;

    case PROP_CREATE_SPEC_CREATING_PARENT_CONTAINERS_IF_NEEDED:
      g_value_set_boolean (value, self->creatingParentContainersIfNeeded);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
create_spec_instance_init (CreateSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->data = NULL;
  object->__isset_data = FALSE;
  object->__isset_mode = FALSE;
  object->asyncContext = NULL;
  object->__isset_asyncContext = FALSE;
  object->compressed = 0;
  object->__isset_compressed = FALSE;
  object->creatingParentsIfNeeded = 0;
  object->__isset_creatingParentsIfNeeded = FALSE;
  object->withProtection = 0;
  object->__isset_withProtection = FALSE;
  object->creatingParentContainersIfNeeded = 0;
  object->__isset_creatingParentContainersIfNeeded = FALSE;
}

static void 
create_spec_finalize (GObject *object)
{
  CreateSpec *tobject = CREATE_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
  if (tobject->asyncContext != NULL)
  {
    g_free(tobject->asyncContext);
    tobject->asyncContext = NULL;
  }
}

static void
create_spec_class_init (CreateSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = create_spec_read;
  struct_class->write = create_spec_write;

  gobject_class->finalize = create_spec_finalize;
  gobject_class->get_property = create_spec_get_property;
  gobject_class->set_property = create_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_MODE,
     g_param_spec_int ("mode",
                       NULL,
                       NULL,
                       0,
                       4,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_ASYNC_CONTEXT,
     g_param_spec_string ("asyncContext",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_COMPRESSED,
     g_param_spec_boolean ("compressed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_CREATING_PARENTS_IF_NEEDED,
     g_param_spec_boolean ("creatingParentsIfNeeded",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_WITH_PROTECTION,
     g_param_spec_boolean ("withProtection",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_SPEC_CREATING_PARENT_CONTAINERS_IF_NEEDED,
     g_param_spec_boolean ("creatingParentContainersIfNeeded",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
create_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CreateSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) create_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CreateSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) create_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CreateSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _DeleteSpecProperties
{
  PROP_DELETE_SPEC_0,
  PROP_DELETE_SPEC_PATH,
  PROP_DELETE_SPEC_GUARANTEED,
  PROP_DELETE_SPEC_ASYNC_CONTEXT,
  PROP_DELETE_SPEC_VERSION
};

/* reads a delete_spec object */
static gint32
delete_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DeleteSpec * this_object = DELETE_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->guaranteed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guaranteed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->asyncContext != NULL)
          {
            g_free(this_object->asyncContext);
            this_object->asyncContext = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->asyncContext, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asyncContext = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->version), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
delete_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DeleteSpec * this_object = DELETE_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DeleteSpec", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guaranteed", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->guaranteed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asyncContext", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->asyncContext, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->version), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
delete_spec_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  DeleteSpec *self = DELETE_SPEC (object);

  switch (property_id)
  {
    case PROP_DELETE_SPEC_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_DELETE_SPEC_GUARANTEED:
      self->guaranteed = g_value_get_boolean (value);
      self->__isset_guaranteed = TRUE;
      break;

    case PROP_DELETE_SPEC_ASYNC_CONTEXT:
      if (self->asyncContext != NULL)
        g_free (self->asyncContext);
      self->asyncContext = g_value_dup_string (value);
      self->__isset_asyncContext = TRUE;
      break;

    case PROP_DELETE_SPEC_VERSION:
      if (self->version != NULL)
        g_object_unref (self->version);
      self->version = g_value_dup_object (value);
      self->__isset_version = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
delete_spec_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  DeleteSpec *self = DELETE_SPEC (object);

  switch (property_id)
  {
    case PROP_DELETE_SPEC_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_DELETE_SPEC_GUARANTEED:
      g_value_set_boolean (value, self->guaranteed);
      break;

    case PROP_DELETE_SPEC_ASYNC_CONTEXT:
      g_value_set_string (value, self->asyncContext);
      break;

    case PROP_DELETE_SPEC_VERSION:
      g_value_set_object (value, self->version);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
delete_spec_instance_init (DeleteSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->guaranteed = 0;
  object->__isset_guaranteed = FALSE;
  object->asyncContext = NULL;
  object->__isset_asyncContext = FALSE;
  object->version = g_object_new (TYPE_VERSION, NULL);
  object->__isset_version = FALSE;
}

static void 
delete_spec_finalize (GObject *object)
{
  DeleteSpec *tobject = DELETE_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->asyncContext != NULL)
  {
    g_free(tobject->asyncContext);
    tobject->asyncContext = NULL;
  }
  if (tobject->version != NULL)
  {
    g_object_unref(tobject->version);
    tobject->version = NULL;
  }
}

static void
delete_spec_class_init (DeleteSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = delete_spec_read;
  struct_class->write = delete_spec_write;

  gobject_class->finalize = delete_spec_finalize;
  gobject_class->get_property = delete_spec_get_property;
  gobject_class->set_property = delete_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_SPEC_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_SPEC_GUARANTEED,
     g_param_spec_boolean ("guaranteed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_SPEC_ASYNC_CONTEXT,
     g_param_spec_string ("asyncContext",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_SPEC_VERSION,
     g_param_spec_object ("version",
                         NULL,
                         NULL,
                         TYPE_VERSION,
                         G_PARAM_READWRITE));
}

GType
delete_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DeleteSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) delete_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DeleteSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) delete_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DeleteSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _OptionalStatProperties
{
  PROP_OPTIONAL_STAT_0,
  PROP_OPTIONAL_STAT_STAT
};

/* reads a optional_stat object */
static gint32
optional_stat_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  OptionalStat * this_object = OPTIONAL_STAT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->stat), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_stat = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
optional_stat_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  OptionalStat * this_object = OPTIONAL_STAT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OptionalStat", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stat", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->stat), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
optional_stat_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  OptionalStat *self = OPTIONAL_STAT (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_STAT_STAT:
      if (self->stat != NULL)
        g_object_unref (self->stat);
      self->stat = g_value_dup_object (value);
      self->__isset_stat = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
optional_stat_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  OptionalStat *self = OPTIONAL_STAT (object);

  switch (property_id)
  {
    case PROP_OPTIONAL_STAT_STAT:
      g_value_set_object (value, self->stat);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
optional_stat_instance_init (OptionalStat * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stat = g_object_new (TYPE_STAT, NULL);
  object->__isset_stat = FALSE;
}

static void 
optional_stat_finalize (GObject *object)
{
  OptionalStat *tobject = OPTIONAL_STAT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->stat != NULL)
  {
    g_object_unref(tobject->stat);
    tobject->stat = NULL;
  }
}

static void
optional_stat_class_init (OptionalStatClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = optional_stat_read;
  struct_class->write = optional_stat_write;

  gobject_class->finalize = optional_stat_finalize;
  gobject_class->get_property = optional_stat_get_property;
  gobject_class->set_property = optional_stat_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_OPTIONAL_STAT_STAT,
     g_param_spec_object ("stat",
                         NULL,
                         NULL,
                         TYPE_STAT,
                         G_PARAM_READWRITE));
}

GType
optional_stat_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (OptionalStatClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) optional_stat_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (OptionalStat),
      0, /* n_preallocs */
      (GInstanceInitFunc) optional_stat_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "OptionalStatType",
                                   &type_info, 0);
  }

  return type;
}

enum _AclProperties
{
  PROP_ACL_0,
  PROP_ACL_PERMS,
  PROP_ACL_ID
};

/* reads a acl object */
static gint32
acl_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Acl * this_object = ACL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->perms, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_perms = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->id), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
acl_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Acl * this_object = ACL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Acl", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "perms", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->perms, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->id), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
acl_set_property (GObject *object,
                  guint property_id,
                  const GValue *value,
                  GParamSpec *pspec)
{
  Acl *self = ACL (object);

  switch (property_id)
  {
    case PROP_ACL_PERMS:
      self->perms = g_value_get_int (value);
      self->__isset_perms = TRUE;
      break;

    case PROP_ACL_ID:
      if (self->id != NULL)
        g_object_unref (self->id);
      self->id = g_value_dup_object (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
acl_get_property (GObject *object,
                  guint property_id,
                  GValue *value,
                  GParamSpec *pspec)
{
  Acl *self = ACL (object);

  switch (property_id)
  {
    case PROP_ACL_PERMS:
      g_value_set_int (value, self->perms);
      break;

    case PROP_ACL_ID:
      g_value_set_object (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
acl_instance_init (Acl * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->perms = 0;
  object->__isset_perms = FALSE;
  object->id = g_object_new (TYPE_ID, NULL);
  object->__isset_id = FALSE;
}

static void 
acl_finalize (GObject *object)
{
  Acl *tobject = ACL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_object_unref(tobject->id);
    tobject->id = NULL;
  }
}

static void
acl_class_init (AclClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = acl_read;
  struct_class->write = acl_write;

  gobject_class->finalize = acl_finalize;
  gobject_class->get_property = acl_get_property;
  gobject_class->set_property = acl_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ACL_PERMS,
     g_param_spec_int ("perms",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ACL_ID,
     g_param_spec_object ("id",
                         NULL,
                         NULL,
                         TYPE_ID,
                         G_PARAM_READWRITE));
}

GType
acl_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AclClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) acl_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Acl),
      0, /* n_preallocs */
      (GInstanceInitFunc) acl_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AclType",
                                   &type_info, 0);
  }

  return type;
}

enum _ChildDataProperties
{
  PROP_CHILD_DATA_0,
  PROP_CHILD_DATA_PATH,
  PROP_CHILD_DATA_STAT,
  PROP_CHILD_DATA_DATA
};

/* reads a child_data object */
static gint32
child_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ChildData * this_object = CHILD_DATA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->stat), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_stat = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
child_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ChildData * this_object = CHILD_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ChildData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stat", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->stat), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->data)->data, ((GByteArray *) this_object->data)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
child_data_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  ChildData *self = CHILD_DATA (object);

  switch (property_id)
  {
    case PROP_CHILD_DATA_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CHILD_DATA_STAT:
      if (self->stat != NULL)
        g_object_unref (self->stat);
      self->stat = g_value_dup_object (value);
      self->__isset_stat = TRUE;
      break;

    case PROP_CHILD_DATA_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
child_data_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  ChildData *self = CHILD_DATA (object);

  switch (property_id)
  {
    case PROP_CHILD_DATA_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CHILD_DATA_STAT:
      g_value_set_object (value, self->stat);
      break;

    case PROP_CHILD_DATA_DATA:
      g_value_set_boxed (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
child_data_instance_init (ChildData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->stat = g_object_new (TYPE_STAT, NULL);
  object->__isset_stat = FALSE;
  object->data = NULL;
  object->__isset_data = FALSE;
}

static void 
child_data_finalize (GObject *object)
{
  ChildData *tobject = CHILD_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->stat != NULL)
  {
    g_object_unref(tobject->stat);
    tobject->stat = NULL;
  }
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
}

static void
child_data_class_init (ChildDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = child_data_read;
  struct_class->write = child_data_write;

  gobject_class->finalize = child_data_finalize;
  gobject_class->get_property = child_data_get_property;
  gobject_class->set_property = child_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CHILD_DATA_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CHILD_DATA_STAT,
     g_param_spec_object ("stat",
                         NULL,
                         NULL,
                         TYPE_STAT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CHILD_DATA_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
child_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ChildDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) child_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ChildData),
      0, /* n_preallocs */
      (GInstanceInitFunc) child_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ChildDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _PathChildrenCacheEventProperties
{
  PROP_PATH_CHILDREN_CACHE_EVENT_0,
  PROP_PATH_CHILDREN_CACHE_EVENT_CACHED_PATH,
  PROP_PATH_CHILDREN_CACHE_EVENT_TYPE,
  PROP_PATH_CHILDREN_CACHE_EVENT_DATA
};

/* reads a path_children_cache_event object */
static gint32
path_children_cache_event_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PathChildrenCacheEvent * this_object = PATH_CHILDREN_CACHE_EVENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->cachedPath != NULL)
          {
            g_free(this_object->cachedPath);
            this_object->cachedPath = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cachedPath, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cachedPath = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast5;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (PathChildrenCacheEventType)ecast5;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
path_children_cache_event_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PathChildrenCacheEvent * this_object = PATH_CHILDREN_CACHE_EVENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PathChildrenCacheEvent", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cachedPath", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->cachedPath, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
path_children_cache_event_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  PathChildrenCacheEvent *self = PATH_CHILDREN_CACHE_EVENT (object);

  switch (property_id)
  {
    case PROP_PATH_CHILDREN_CACHE_EVENT_CACHED_PATH:
      if (self->cachedPath != NULL)
        g_free (self->cachedPath);
      self->cachedPath = g_value_dup_string (value);
      self->__isset_cachedPath = TRUE;
      break;

    case PROP_PATH_CHILDREN_CACHE_EVENT_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PATH_CHILDREN_CACHE_EVENT_DATA:
      if (self->data != NULL)
        g_object_unref (self->data);
      self->data = g_value_dup_object (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
path_children_cache_event_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  PathChildrenCacheEvent *self = PATH_CHILDREN_CACHE_EVENT (object);

  switch (property_id)
  {
    case PROP_PATH_CHILDREN_CACHE_EVENT_CACHED_PATH:
      g_value_set_string (value, self->cachedPath);
      break;

    case PROP_PATH_CHILDREN_CACHE_EVENT_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PATH_CHILDREN_CACHE_EVENT_DATA:
      g_value_set_object (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
path_children_cache_event_instance_init (PathChildrenCacheEvent * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cachedPath = NULL;
  object->__isset_cachedPath = FALSE;
  object->__isset_type = FALSE;
  object->data = g_object_new (TYPE_CHILD_DATA, NULL);
  object->__isset_data = FALSE;
}

static void 
path_children_cache_event_finalize (GObject *object)
{
  PathChildrenCacheEvent *tobject = PATH_CHILDREN_CACHE_EVENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cachedPath != NULL)
  {
    g_free(tobject->cachedPath);
    tobject->cachedPath = NULL;
  }
  if (tobject->data != NULL)
  {
    g_object_unref(tobject->data);
    tobject->data = NULL;
  }
}

static void
path_children_cache_event_class_init (PathChildrenCacheEventClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = path_children_cache_event_read;
  struct_class->write = path_children_cache_event_write;

  gobject_class->finalize = path_children_cache_event_finalize;
  gobject_class->get_property = path_children_cache_event_get_property;
  gobject_class->set_property = path_children_cache_event_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PATH_CHILDREN_CACHE_EVENT_CACHED_PATH,
     g_param_spec_string ("cachedPath",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PATH_CHILDREN_CACHE_EVENT_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       6,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PATH_CHILDREN_CACHE_EVENT_DATA,
     g_param_spec_object ("data",
                         NULL,
                         NULL,
                         TYPE_CHILD_DATA,
                         G_PARAM_READWRITE));
}

GType
path_children_cache_event_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PathChildrenCacheEventClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) path_children_cache_event_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PathChildrenCacheEvent),
      0, /* n_preallocs */
      (GInstanceInitFunc) path_children_cache_event_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PathChildrenCacheEventType",
                                   &type_info, 0);
  }

  return type;
}

enum _SetDataSpecProperties
{
  PROP_SET_DATA_SPEC_0,
  PROP_SET_DATA_SPEC_PATH,
  PROP_SET_DATA_SPEC_WATCHED,
  PROP_SET_DATA_SPEC_ASYNC_CONTEXT,
  PROP_SET_DATA_SPEC_COMPRESSED,
  PROP_SET_DATA_SPEC_VERSION,
  PROP_SET_DATA_SPEC_DATA
};

/* reads a set_data_spec object */
static gint32
set_data_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SetDataSpec * this_object = SET_DATA_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->watched, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_watched = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->asyncContext != NULL)
          {
            g_free(this_object->asyncContext);
            this_object->asyncContext = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->asyncContext, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asyncContext = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->compressed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compressed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->version), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
set_data_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SetDataSpec * this_object = SET_DATA_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SetDataSpec", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "watched", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->watched, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asyncContext", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->asyncContext, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compressed", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->compressed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->version), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->data)->data, ((GByteArray *) this_object->data)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
set_data_spec_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  SetDataSpec *self = SET_DATA_SPEC (object);

  switch (property_id)
  {
    case PROP_SET_DATA_SPEC_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_SET_DATA_SPEC_WATCHED:
      self->watched = g_value_get_boolean (value);
      self->__isset_watched = TRUE;
      break;

    case PROP_SET_DATA_SPEC_ASYNC_CONTEXT:
      if (self->asyncContext != NULL)
        g_free (self->asyncContext);
      self->asyncContext = g_value_dup_string (value);
      self->__isset_asyncContext = TRUE;
      break;

    case PROP_SET_DATA_SPEC_COMPRESSED:
      self->compressed = g_value_get_boolean (value);
      self->__isset_compressed = TRUE;
      break;

    case PROP_SET_DATA_SPEC_VERSION:
      if (self->version != NULL)
        g_object_unref (self->version);
      self->version = g_value_dup_object (value);
      self->__isset_version = TRUE;
      break;

    case PROP_SET_DATA_SPEC_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
set_data_spec_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  SetDataSpec *self = SET_DATA_SPEC (object);

  switch (property_id)
  {
    case PROP_SET_DATA_SPEC_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_SET_DATA_SPEC_WATCHED:
      g_value_set_boolean (value, self->watched);
      break;

    case PROP_SET_DATA_SPEC_ASYNC_CONTEXT:
      g_value_set_string (value, self->asyncContext);
      break;

    case PROP_SET_DATA_SPEC_COMPRESSED:
      g_value_set_boolean (value, self->compressed);
      break;

    case PROP_SET_DATA_SPEC_VERSION:
      g_value_set_object (value, self->version);
      break;

    case PROP_SET_DATA_SPEC_DATA:
      g_value_set_boxed (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
set_data_spec_instance_init (SetDataSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->watched = 0;
  object->__isset_watched = FALSE;
  object->asyncContext = NULL;
  object->__isset_asyncContext = FALSE;
  object->compressed = 0;
  object->__isset_compressed = FALSE;
  object->version = g_object_new (TYPE_VERSION, NULL);
  object->__isset_version = FALSE;
  object->data = NULL;
  object->__isset_data = FALSE;
}

static void 
set_data_spec_finalize (GObject *object)
{
  SetDataSpec *tobject = SET_DATA_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->asyncContext != NULL)
  {
    g_free(tobject->asyncContext);
    tobject->asyncContext = NULL;
  }
  if (tobject->version != NULL)
  {
    g_object_unref(tobject->version);
    tobject->version = NULL;
  }
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
}

static void
set_data_spec_class_init (SetDataSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = set_data_spec_read;
  struct_class->write = set_data_spec_write;

  gobject_class->finalize = set_data_spec_finalize;
  gobject_class->get_property = set_data_spec_get_property;
  gobject_class->set_property = set_data_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SET_DATA_SPEC_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SET_DATA_SPEC_WATCHED,
     g_param_spec_boolean ("watched",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SET_DATA_SPEC_ASYNC_CONTEXT,
     g_param_spec_string ("asyncContext",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SET_DATA_SPEC_COMPRESSED,
     g_param_spec_boolean ("compressed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SET_DATA_SPEC_VERSION,
     g_param_spec_object ("version",
                         NULL,
                         NULL,
                         TYPE_VERSION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SET_DATA_SPEC_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
set_data_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SetDataSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) set_data_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SetDataSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) set_data_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SetDataSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorExceptionProperties
{
  PROP_CURATOR_EXCEPTION_0,
  PROP_CURATOR_EXCEPTION_TYPE,
  PROP_CURATOR_EXCEPTION_ZOO_KEEPER_EXCEPTION,
  PROP_CURATOR_EXCEPTION_NODE_EXCEPTION,
  PROP_CURATOR_EXCEPTION_MESSAGE
};

/* reads a curator_exception object */
static gint32
curator_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorException * this_object = CURATOR_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast6;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ExceptionType)ecast6;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->zooKeeperException = (ZooKeeperExceptionType)ecast7;
          this_object->__isset_zooKeeperException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->nodeException = (NodeExceptionType)ecast8;
          this_object->__isset_nodeException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorException * this_object = CURATOR_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "zooKeeperException", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->zooKeeperException, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nodeException", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->nodeException, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_exception_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  CuratorException *self = CURATOR_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_CURATOR_EXCEPTION_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_CURATOR_EXCEPTION_ZOO_KEEPER_EXCEPTION:
      self->zooKeeperException = g_value_get_int (value);
      self->__isset_zooKeeperException = TRUE;
      break;

    case PROP_CURATOR_EXCEPTION_NODE_EXCEPTION:
      self->nodeException = g_value_get_int (value);
      self->__isset_nodeException = TRUE;
      break;

    case PROP_CURATOR_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_exception_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  CuratorException *self = CURATOR_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_CURATOR_EXCEPTION_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_CURATOR_EXCEPTION_ZOO_KEEPER_EXCEPTION:
      g_value_set_int (value, self->zooKeeperException);
      break;

    case PROP_CURATOR_EXCEPTION_NODE_EXCEPTION:
      g_value_set_int (value, self->nodeException);
      break;

    case PROP_CURATOR_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_exception_instance_init (CuratorException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->__isset_zooKeeperException = FALSE;
  object->__isset_nodeException = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
curator_exception_finalize (GObject *object)
{
  CuratorException *tobject = CURATOR_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
curator_exception_class_init (CuratorExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_exception_read;
  struct_class->write = curator_exception_write;

  gobject_class->finalize = curator_exception_finalize;
  gobject_class->get_property = curator_exception_get_property;
  gobject_class->set_property = curator_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EXCEPTION_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EXCEPTION_ZOO_KEEPER_EXCEPTION,
     g_param_spec_int ("zooKeeperException",
                       NULL,
                       NULL,
                       0,
                       16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EXCEPTION_NODE_EXCEPTION,
     g_param_spec_int ("nodeException",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
curator_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorException),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define CURATOR_EXCEPTION_ERROR_DOMAIN "curator_exception_error_quark"
GQuark
curator_exception_error_quark (void)
{
  return g_quark_from_static_string (CURATOR_EXCEPTION_ERROR_DOMAIN);
}

enum _DiscoveryInstanceProperties
{
  PROP_DISCOVERY_INSTANCE_0,
  PROP_DISCOVERY_INSTANCE_NAME,
  PROP_DISCOVERY_INSTANCE_ID,
  PROP_DISCOVERY_INSTANCE_ADDRESS,
  PROP_DISCOVERY_INSTANCE_PORT,
  PROP_DISCOVERY_INSTANCE_SSL_PORT,
  PROP_DISCOVERY_INSTANCE_PAYLOAD,
  PROP_DISCOVERY_INSTANCE_REGISTRATION_TIME_U_T_C,
  PROP_DISCOVERY_INSTANCE_SERVICE_TYPE,
  PROP_DISCOVERY_INSTANCE_URI_SPEC
};

/* reads a discovery_instance object */
static gint32
discovery_instance_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryInstance * this_object = DISCOVERY_INSTANCE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->address != NULL)
          {
            g_free(this_object->address);
            this_object->address = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->address, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_address = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->port, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->sslPort, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sslPort = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->payload != NULL)
          {
            g_free(this_object->payload);
            this_object->payload = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->payload = g_byte_array_new();
          g_byte_array_append (this_object->payload, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_payload = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->registrationTimeUTC, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_registrationTimeUTC = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          gint32 ecast9;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast9, error)) < 0)
            return -1;
          xfer += ret;
          this_object->serviceType = (DiscoveryInstanceType)ecast9;
          this_object->__isset_serviceType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->uriSpec != NULL)
          {
            g_free(this_object->uriSpec);
            this_object->uriSpec = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->uriSpec, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_uriSpec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_instance_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryInstance * this_object = DISCOVERY_INSTANCE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryInstance", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "address", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->address, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->port, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sslPort", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->sslPort, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "payload", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->payload)->data, ((GByteArray *) this_object->payload)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "registrationTimeUTC", T_I64, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->registrationTimeUTC, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serviceType", T_I32, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->serviceType, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "uriSpec", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->uriSpec, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_instance_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  DiscoveryInstance *self = DISCOVERY_INSTANCE (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_INSTANCE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_ADDRESS:
      if (self->address != NULL)
        g_free (self->address);
      self->address = g_value_dup_string (value);
      self->__isset_address = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_PORT:
      self->port = g_value_get_int (value);
      self->__isset_port = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_SSL_PORT:
      self->sslPort = g_value_get_int (value);
      self->__isset_sslPort = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_PAYLOAD:
      if (self->payload != NULL)
        g_byte_array_unref (self->payload);
      self->payload = g_value_dup_boxed (value);
      self->__isset_payload = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_REGISTRATION_TIME_U_T_C:
      self->registrationTimeUTC = g_value_get_int64 (value);
      self->__isset_registrationTimeUTC = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_SERVICE_TYPE:
      self->serviceType = g_value_get_int (value);
      self->__isset_serviceType = TRUE;
      break;

    case PROP_DISCOVERY_INSTANCE_URI_SPEC:
      if (self->uriSpec != NULL)
        g_free (self->uriSpec);
      self->uriSpec = g_value_dup_string (value);
      self->__isset_uriSpec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_instance_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  DiscoveryInstance *self = DISCOVERY_INSTANCE (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_INSTANCE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_DISCOVERY_INSTANCE_ID:
      g_value_set_string (value, self->id);
      break;

    case PROP_DISCOVERY_INSTANCE_ADDRESS:
      g_value_set_string (value, self->address);
      break;

    case PROP_DISCOVERY_INSTANCE_PORT:
      g_value_set_int (value, self->port);
      break;

    case PROP_DISCOVERY_INSTANCE_SSL_PORT:
      g_value_set_int (value, self->sslPort);
      break;

    case PROP_DISCOVERY_INSTANCE_PAYLOAD:
      g_value_set_boxed (value, self->payload);
      break;

    case PROP_DISCOVERY_INSTANCE_REGISTRATION_TIME_U_T_C:
      g_value_set_int64 (value, self->registrationTimeUTC);
      break;

    case PROP_DISCOVERY_INSTANCE_SERVICE_TYPE:
      g_value_set_int (value, self->serviceType);
      break;

    case PROP_DISCOVERY_INSTANCE_URI_SPEC:
      g_value_set_string (value, self->uriSpec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_instance_instance_init (DiscoveryInstance * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->id = NULL;
  object->__isset_id = FALSE;
  object->address = NULL;
  object->__isset_address = FALSE;
  object->port = 0;
  object->__isset_port = FALSE;
  object->sslPort = 0;
  object->__isset_sslPort = FALSE;
  object->payload = NULL;
  object->__isset_payload = FALSE;
  object->registrationTimeUTC = 0;
  object->__isset_registrationTimeUTC = FALSE;
  object->__isset_serviceType = FALSE;
  object->uriSpec = NULL;
  object->__isset_uriSpec = FALSE;
}

static void 
discovery_instance_finalize (GObject *object)
{
  DiscoveryInstance *tobject = DISCOVERY_INSTANCE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
  if (tobject->address != NULL)
  {
    g_free(tobject->address);
    tobject->address = NULL;
  }
  if (tobject->payload != NULL)
  {
    thrift_string_free(tobject->payload);
    tobject->payload = NULL;
  }
  if (tobject->uriSpec != NULL)
  {
    g_free(tobject->uriSpec);
    tobject->uriSpec = NULL;
  }
}

static void
discovery_instance_class_init (DiscoveryInstanceClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_instance_read;
  struct_class->write = discovery_instance_write;

  gobject_class->finalize = discovery_instance_finalize;
  gobject_class->get_property = discovery_instance_get_property;
  gobject_class->set_property = discovery_instance_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_ADDRESS,
     g_param_spec_string ("address",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_PORT,
     g_param_spec_int ("port",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_SSL_PORT,
     g_param_spec_int ("sslPort",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_PAYLOAD,
     g_param_spec_boxed ("payload",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_REGISTRATION_TIME_U_T_C,
     g_param_spec_int64 ("registrationTimeUTC",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_SERVICE_TYPE,
     g_param_spec_int ("serviceType",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_INSTANCE_URI_SPEC,
     g_param_spec_string ("uriSpec",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
discovery_instance_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryInstanceClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_instance_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryInstance),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_instance_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryInstanceType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorEventProperties
{
  PROP_CURATOR_EVENT_0,
  PROP_CURATOR_EVENT_TYPE,
  PROP_CURATOR_EVENT_RESULT_CODE,
  PROP_CURATOR_EVENT_PATH,
  PROP_CURATOR_EVENT_CONTEXT,
  PROP_CURATOR_EVENT_STAT,
  PROP_CURATOR_EVENT_DATA,
  PROP_CURATOR_EVENT_NAME,
  PROP_CURATOR_EVENT_CHILDREN,
  PROP_CURATOR_EVENT_ACL_LIST,
  PROP_CURATOR_EVENT_WATCHED_EVENT,
  PROP_CURATOR_EVENT_LEADER_EVENT,
  PROP_CURATOR_EVENT_CHILDREN_CACHE_EVENT
};

/* reads a curator_event object */
static gint32
curator_event_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorEvent * this_object = CURATOR_EVENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast10;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast10, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (CuratorEventType)ecast10;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->resultCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_resultCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->context != NULL)
          {
            g_free(this_object->context);
            this_object->context = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->context, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_context = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->stat), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_stat = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem11 = NULL;
              if (_elem11 != NULL)
              {
                g_free(_elem11);
                _elem11 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem11, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->children, _elem11);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_children = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Acl * _elem12 = NULL;
              if ( _elem12 != NULL)
              {
                g_object_unref (_elem12);
              }
              _elem12 = g_object_new (TYPE_ACL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem12), protocol, error)) < 0)
              {
                g_object_unref (_elem12);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->aclList, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_aclList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->watchedEvent), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_watchedEvent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->leaderEvent), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_leaderEvent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->childrenCacheEvent), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_childrenCacheEvent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_event_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorEvent * this_object = CURATOR_EVENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorEvent", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "resultCode", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->resultCode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "context", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->context, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stat", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->stat), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->data)->data, ((GByteArray *) this_object->data)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "children", T_LIST, 9, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i13;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->children->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i13 = 0; i13 < this_object->children->len; i13++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->children, i13)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aclList", T_LIST, 10, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i14;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->aclList->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i14 = 0; i14 < this_object->aclList->len; i14++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->aclList, i14))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "watchedEvent", T_STRUCT, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->watchedEvent), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "leaderEvent", T_STRUCT, 12, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->leaderEvent), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "childrenCacheEvent", T_STRUCT, 13, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->childrenCacheEvent), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_event_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  CuratorEvent *self = CURATOR_EVENT (object);

  switch (property_id)
  {
    case PROP_CURATOR_EVENT_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_CURATOR_EVENT_RESULT_CODE:
      self->resultCode = g_value_get_int (value);
      self->__isset_resultCode = TRUE;
      break;

    case PROP_CURATOR_EVENT_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_EVENT_CONTEXT:
      if (self->context != NULL)
        g_free (self->context);
      self->context = g_value_dup_string (value);
      self->__isset_context = TRUE;
      break;

    case PROP_CURATOR_EVENT_STAT:
      if (self->stat != NULL)
        g_object_unref (self->stat);
      self->stat = g_value_dup_object (value);
      self->__isset_stat = TRUE;
      break;

    case PROP_CURATOR_EVENT_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    case PROP_CURATOR_EVENT_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_CURATOR_EVENT_CHILDREN:
      if (self->children != NULL)
        g_ptr_array_unref (self->children);
      self->children = g_value_dup_boxed (value);
      self->__isset_children = TRUE;
      break;

    case PROP_CURATOR_EVENT_ACL_LIST:
      if (self->aclList != NULL)
        g_ptr_array_unref (self->aclList);
      self->aclList = g_value_dup_boxed (value);
      self->__isset_aclList = TRUE;
      break;

    case PROP_CURATOR_EVENT_WATCHED_EVENT:
      if (self->watchedEvent != NULL)
        g_object_unref (self->watchedEvent);
      self->watchedEvent = g_value_dup_object (value);
      self->__isset_watchedEvent = TRUE;
      break;

    case PROP_CURATOR_EVENT_LEADER_EVENT:
      if (self->leaderEvent != NULL)
        g_object_unref (self->leaderEvent);
      self->leaderEvent = g_value_dup_object (value);
      self->__isset_leaderEvent = TRUE;
      break;

    case PROP_CURATOR_EVENT_CHILDREN_CACHE_EVENT:
      if (self->childrenCacheEvent != NULL)
        g_object_unref (self->childrenCacheEvent);
      self->childrenCacheEvent = g_value_dup_object (value);
      self->__isset_childrenCacheEvent = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_event_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  CuratorEvent *self = CURATOR_EVENT (object);

  switch (property_id)
  {
    case PROP_CURATOR_EVENT_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_CURATOR_EVENT_RESULT_CODE:
      g_value_set_int (value, self->resultCode);
      break;

    case PROP_CURATOR_EVENT_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_EVENT_CONTEXT:
      g_value_set_string (value, self->context);
      break;

    case PROP_CURATOR_EVENT_STAT:
      g_value_set_object (value, self->stat);
      break;

    case PROP_CURATOR_EVENT_DATA:
      g_value_set_boxed (value, self->data);
      break;

    case PROP_CURATOR_EVENT_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_CURATOR_EVENT_CHILDREN:
      g_value_set_boxed (value, self->children);
      break;

    case PROP_CURATOR_EVENT_ACL_LIST:
      g_value_set_boxed (value, self->aclList);
      break;

    case PROP_CURATOR_EVENT_WATCHED_EVENT:
      g_value_set_object (value, self->watchedEvent);
      break;

    case PROP_CURATOR_EVENT_LEADER_EVENT:
      g_value_set_object (value, self->leaderEvent);
      break;

    case PROP_CURATOR_EVENT_CHILDREN_CACHE_EVENT:
      g_value_set_object (value, self->childrenCacheEvent);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_event_instance_init (CuratorEvent * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->resultCode = 0;
  object->__isset_resultCode = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->context = NULL;
  object->__isset_context = FALSE;
  object->stat = g_object_new (TYPE_STAT, NULL);
  object->__isset_stat = FALSE;
  object->data = NULL;
  object->__isset_data = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->children = g_ptr_array_new_with_free_func (g_free);
  object->__isset_children = FALSE;
  object->aclList = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_aclList = FALSE;
  object->watchedEvent = g_object_new (TYPE_WATCHED_EVENT, NULL);
  object->__isset_watchedEvent = FALSE;
  object->leaderEvent = g_object_new (TYPE_LEADER_EVENT, NULL);
  object->__isset_leaderEvent = FALSE;
  object->childrenCacheEvent = g_object_new (TYPE_PATH_CHILDREN_CACHE_EVENT, NULL);
  object->__isset_childrenCacheEvent = FALSE;
}

static void 
curator_event_finalize (GObject *object)
{
  CuratorEvent *tobject = CURATOR_EVENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->context != NULL)
  {
    g_free(tobject->context);
    tobject->context = NULL;
  }
  if (tobject->stat != NULL)
  {
    g_object_unref(tobject->stat);
    tobject->stat = NULL;
  }
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->children != NULL)
  {
    g_ptr_array_unref (tobject->children);
    tobject->children = NULL;
  }
  if (tobject->aclList != NULL)
  {
    g_ptr_array_unref (tobject->aclList);
    tobject->aclList = NULL;
  }
  if (tobject->watchedEvent != NULL)
  {
    g_object_unref(tobject->watchedEvent);
    tobject->watchedEvent = NULL;
  }
  if (tobject->leaderEvent != NULL)
  {
    g_object_unref(tobject->leaderEvent);
    tobject->leaderEvent = NULL;
  }
  if (tobject->childrenCacheEvent != NULL)
  {
    g_object_unref(tobject->childrenCacheEvent);
    tobject->childrenCacheEvent = NULL;
  }
}

static void
curator_event_class_init (CuratorEventClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_event_read;
  struct_class->write = curator_event_write;

  gobject_class->finalize = curator_event_finalize;
  gobject_class->get_property = curator_event_get_property;
  gobject_class->set_property = curator_event_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       19,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_RESULT_CODE,
     g_param_spec_int ("resultCode",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_CONTEXT,
     g_param_spec_string ("context",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_STAT,
     g_param_spec_object ("stat",
                         NULL,
                         NULL,
                         TYPE_STAT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_CHILDREN,
     g_param_spec_boxed ("children",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_ACL_LIST,
     g_param_spec_boxed ("aclList",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_WATCHED_EVENT,
     g_param_spec_object ("watchedEvent",
                         NULL,
                         NULL,
                         TYPE_WATCHED_EVENT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_LEADER_EVENT,
     g_param_spec_object ("leaderEvent",
                         NULL,
                         NULL,
                         TYPE_LEADER_EVENT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_EVENT_CHILDREN_CACHE_EVENT,
     g_param_spec_object ("childrenCacheEvent",
                         NULL,
                         NULL,
                         TYPE_PATH_CHILDREN_CACHE_EVENT,
                         G_PARAM_READWRITE));
}

GType
curator_event_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorEventClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_event_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorEvent),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_event_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorEventType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _CuratorServiceAcquireLockArgsProperties
{
  PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_0,
  PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PATH,
  PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_MAX_WAIT_MS
};

/* reads a curator_service_acquire_lock_args object */
static gint32
curator_service_acquire_lock_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceAcquireLockArgs * this_object = CURATOR_SERVICE_ACQUIRE_LOCK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxWaitMs, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxWaitMs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_acquire_lock_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceAcquireLockArgs * this_object = CURATOR_SERVICE_ACQUIRE_LOCK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceAcquireLockArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxWaitMs", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxWaitMs, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_acquire_lock_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  CuratorServiceAcquireLockArgs *self = CURATOR_SERVICE_ACQUIRE_LOCK_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_MAX_WAIT_MS:
      self->maxWaitMs = g_value_get_int (value);
      self->__isset_maxWaitMs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_acquire_lock_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  CuratorServiceAcquireLockArgs *self = CURATOR_SERVICE_ACQUIRE_LOCK_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_MAX_WAIT_MS:
      g_value_set_int (value, self->maxWaitMs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_acquire_lock_args_instance_init (CuratorServiceAcquireLockArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->maxWaitMs = 0;
  object->__isset_maxWaitMs = FALSE;
}

static void 
curator_service_acquire_lock_args_finalize (GObject *object)
{
  CuratorServiceAcquireLockArgs *tobject = CURATOR_SERVICE_ACQUIRE_LOCK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
curator_service_acquire_lock_args_class_init (CuratorServiceAcquireLockArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_acquire_lock_args_read;
  struct_class->write = curator_service_acquire_lock_args_write;

  gobject_class->finalize = curator_service_acquire_lock_args_finalize;
  gobject_class->get_property = curator_service_acquire_lock_args_get_property;
  gobject_class->set_property = curator_service_acquire_lock_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_LOCK_ARGS_MAX_WAIT_MS,
     g_param_spec_int ("maxWaitMs",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
curator_service_acquire_lock_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceAcquireLockArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_acquire_lock_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceAcquireLockArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_acquire_lock_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceAcquireLockArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceAcquireLockResultProperties
{
  PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_0,
  PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_EX1
};

/* reads a curator_service_acquire_lock_result object */
static gint32
curator_service_acquire_lock_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceAcquireLockResult * this_object = CURATOR_SERVICE_ACQUIRE_LOCK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_acquire_lock_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceAcquireLockResult * this_object = CURATOR_SERVICE_ACQUIRE_LOCK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceAcquireLockResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_acquire_lock_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  CuratorServiceAcquireLockResult *self = CURATOR_SERVICE_ACQUIRE_LOCK_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_acquire_lock_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  CuratorServiceAcquireLockResult *self = CURATOR_SERVICE_ACQUIRE_LOCK_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_acquire_lock_result_instance_init (CuratorServiceAcquireLockResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_OPTIONAL_LOCK_PROJECTION, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_acquire_lock_result_finalize (GObject *object)
{
  CuratorServiceAcquireLockResult *tobject = CURATOR_SERVICE_ACQUIRE_LOCK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_acquire_lock_result_class_init (CuratorServiceAcquireLockResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_acquire_lock_result_read;
  struct_class->write = curator_service_acquire_lock_result_write;

  gobject_class->finalize = curator_service_acquire_lock_result_finalize;
  gobject_class->get_property = curator_service_acquire_lock_result_get_property;
  gobject_class->set_property = curator_service_acquire_lock_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_OPTIONAL_LOCK_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_LOCK_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_acquire_lock_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceAcquireLockResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_acquire_lock_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceAcquireLockResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_acquire_lock_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceAcquireLockResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceAcquireSemaphoreArgsProperties
{
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_0,
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PATH,
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_ACQUIRE_QTY,
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_WAIT_MS,
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_LEASES
};

/* reads a curator_service_acquire_semaphore_args object */
static gint32
curator_service_acquire_semaphore_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceAcquireSemaphoreArgs * this_object = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->acquireQty, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_acquireQty = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxWaitMs, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxWaitMs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxLeases, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxLeases = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_acquire_semaphore_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceAcquireSemaphoreArgs * this_object = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceAcquireSemaphoreArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "acquireQty", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->acquireQty, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxWaitMs", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxWaitMs, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxLeases", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxLeases, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_acquire_semaphore_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  CuratorServiceAcquireSemaphoreArgs *self = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_ACQUIRE_QTY:
      self->acquireQty = g_value_get_int (value);
      self->__isset_acquireQty = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_WAIT_MS:
      self->maxWaitMs = g_value_get_int (value);
      self->__isset_maxWaitMs = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_LEASES:
      self->maxLeases = g_value_get_int (value);
      self->__isset_maxLeases = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_acquire_semaphore_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  CuratorServiceAcquireSemaphoreArgs *self = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_ACQUIRE_QTY:
      g_value_set_int (value, self->acquireQty);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_WAIT_MS:
      g_value_set_int (value, self->maxWaitMs);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_LEASES:
      g_value_set_int (value, self->maxLeases);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_acquire_semaphore_args_instance_init (CuratorServiceAcquireSemaphoreArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->acquireQty = 0;
  object->__isset_acquireQty = FALSE;
  object->maxWaitMs = 0;
  object->__isset_maxWaitMs = FALSE;
  object->maxLeases = 0;
  object->__isset_maxLeases = FALSE;
}

static void 
curator_service_acquire_semaphore_args_finalize (GObject *object)
{
  CuratorServiceAcquireSemaphoreArgs *tobject = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
curator_service_acquire_semaphore_args_class_init (CuratorServiceAcquireSemaphoreArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_acquire_semaphore_args_read;
  struct_class->write = curator_service_acquire_semaphore_args_write;

  gobject_class->finalize = curator_service_acquire_semaphore_args_finalize;
  gobject_class->get_property = curator_service_acquire_semaphore_args_get_property;
  gobject_class->set_property = curator_service_acquire_semaphore_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_ACQUIRE_QTY,
     g_param_spec_int ("acquireQty",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_WAIT_MS,
     g_param_spec_int ("maxWaitMs",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_ARGS_MAX_LEASES,
     g_param_spec_int ("maxLeases",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
curator_service_acquire_semaphore_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceAcquireSemaphoreArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_acquire_semaphore_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceAcquireSemaphoreArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_acquire_semaphore_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceAcquireSemaphoreArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceAcquireSemaphoreResultProperties
{
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_0,
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_EX1
};

/* reads a curator_service_acquire_semaphore_result object */
static gint32
curator_service_acquire_semaphore_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceAcquireSemaphoreResult * this_object = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LeaseProjection * _elem15 = NULL;
              if ( _elem15 != NULL)
              {
                g_object_unref (_elem15);
              }
              _elem15 = g_object_new (TYPE_LEASE_PROJECTION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem15), protocol, error)) < 0)
              {
                g_object_unref (_elem15);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem15);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_acquire_semaphore_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceAcquireSemaphoreResult * this_object = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceAcquireSemaphoreResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i16;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i16 = 0; i16 < this_object->success->len; i16++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i16))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_acquire_semaphore_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  CuratorServiceAcquireSemaphoreResult *self = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_acquire_semaphore_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  CuratorServiceAcquireSemaphoreResult *self = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_acquire_semaphore_result_instance_init (CuratorServiceAcquireSemaphoreResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_acquire_semaphore_result_finalize (GObject *object)
{
  CuratorServiceAcquireSemaphoreResult *tobject = CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_acquire_semaphore_result_class_init (CuratorServiceAcquireSemaphoreResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_acquire_semaphore_result_read;
  struct_class->write = curator_service_acquire_semaphore_result_write;

  gobject_class->finalize = curator_service_acquire_semaphore_result_finalize;
  gobject_class->get_property = curator_service_acquire_semaphore_result_get_property;
  gobject_class->set_property = curator_service_acquire_semaphore_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_ACQUIRE_SEMAPHORE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_acquire_semaphore_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceAcquireSemaphoreResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_acquire_semaphore_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceAcquireSemaphoreResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_acquire_semaphore_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceAcquireSemaphoreResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceCloseCuratorProjectionArgsProperties
{
  PROP_CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS_0,
  PROP_CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS_PROJECTION
};

/* reads a curator_service_close_curator_projection_args object */
static gint32
curator_service_close_curator_projection_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceCloseCuratorProjectionArgs * this_object = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_close_curator_projection_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceCloseCuratorProjectionArgs * this_object = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceCloseCuratorProjectionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_close_curator_projection_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  CuratorServiceCloseCuratorProjectionArgs *self = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_close_curator_projection_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  CuratorServiceCloseCuratorProjectionArgs *self = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_close_curator_projection_args_instance_init (CuratorServiceCloseCuratorProjectionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
}

static void 
curator_service_close_curator_projection_args_finalize (GObject *object)
{
  CuratorServiceCloseCuratorProjectionArgs *tobject = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
}

static void
curator_service_close_curator_projection_args_class_init (CuratorServiceCloseCuratorProjectionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_close_curator_projection_args_read;
  struct_class->write = curator_service_close_curator_projection_args_write;

  gobject_class->finalize = curator_service_close_curator_projection_args_finalize;
  gobject_class->get_property = curator_service_close_curator_projection_args_get_property;
  gobject_class->set_property = curator_service_close_curator_projection_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_close_curator_projection_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceCloseCuratorProjectionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_close_curator_projection_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceCloseCuratorProjectionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_close_curator_projection_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceCloseCuratorProjectionArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a curator_service_close_curator_projection_result object */
static gint32
curator_service_close_curator_projection_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceCloseCuratorProjectionResult * this_object = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_close_curator_projection_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceCloseCuratorProjectionResult * this_object = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceCloseCuratorProjectionResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
curator_service_close_curator_projection_result_instance_init (CuratorServiceCloseCuratorProjectionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
curator_service_close_curator_projection_result_finalize (GObject *object)
{
  CuratorServiceCloseCuratorProjectionResult *tobject = CURATOR_SERVICE_CLOSE_CURATOR_PROJECTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
curator_service_close_curator_projection_result_class_init (CuratorServiceCloseCuratorProjectionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_close_curator_projection_result_read;
  struct_class->write = curator_service_close_curator_projection_result_write;

  gobject_class->finalize = curator_service_close_curator_projection_result_finalize;
}

GType
curator_service_close_curator_projection_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceCloseCuratorProjectionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_close_curator_projection_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceCloseCuratorProjectionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_close_curator_projection_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceCloseCuratorProjectionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceCloseGenericProjectionArgsProperties
{
  PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_0,
  PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_ID
};

/* reads a curator_service_close_generic_projection_args object */
static gint32
curator_service_close_generic_projection_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceCloseGenericProjectionArgs * this_object = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_close_generic_projection_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceCloseGenericProjectionArgs * this_object = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceCloseGenericProjectionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_close_generic_projection_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  CuratorServiceCloseGenericProjectionArgs *self = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_close_generic_projection_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  CuratorServiceCloseGenericProjectionArgs *self = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_close_generic_projection_args_instance_init (CuratorServiceCloseGenericProjectionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
curator_service_close_generic_projection_args_finalize (GObject *object)
{
  CuratorServiceCloseGenericProjectionArgs *tobject = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
curator_service_close_generic_projection_args_class_init (CuratorServiceCloseGenericProjectionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_close_generic_projection_args_read;
  struct_class->write = curator_service_close_generic_projection_args_write;

  gobject_class->finalize = curator_service_close_generic_projection_args_finalize;
  gobject_class->get_property = curator_service_close_generic_projection_args_get_property;
  gobject_class->set_property = curator_service_close_generic_projection_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_ARGS_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
curator_service_close_generic_projection_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceCloseGenericProjectionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_close_generic_projection_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceCloseGenericProjectionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_close_generic_projection_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceCloseGenericProjectionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceCloseGenericProjectionResultProperties
{
  PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_0,
  PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_EX1
};

/* reads a curator_service_close_generic_projection_result object */
static gint32
curator_service_close_generic_projection_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceCloseGenericProjectionResult * this_object = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_close_generic_projection_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceCloseGenericProjectionResult * this_object = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceCloseGenericProjectionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_close_generic_projection_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  CuratorServiceCloseGenericProjectionResult *self = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_close_generic_projection_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  CuratorServiceCloseGenericProjectionResult *self = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_close_generic_projection_result_instance_init (CuratorServiceCloseGenericProjectionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_close_generic_projection_result_finalize (GObject *object)
{
  CuratorServiceCloseGenericProjectionResult *tobject = CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_close_generic_projection_result_class_init (CuratorServiceCloseGenericProjectionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_close_generic_projection_result_read;
  struct_class->write = curator_service_close_generic_projection_result_write;

  gobject_class->finalize = curator_service_close_generic_projection_result_finalize;
  gobject_class->get_property = curator_service_close_generic_projection_result_get_property;
  gobject_class->set_property = curator_service_close_generic_projection_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CLOSE_GENERIC_PROJECTION_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_close_generic_projection_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceCloseGenericProjectionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_close_generic_projection_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceCloseGenericProjectionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_close_generic_projection_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceCloseGenericProjectionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceCreateNodeArgsProperties
{
  PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_0,
  PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_SPEC
};

/* reads a curator_service_create_node_args object */
static gint32
curator_service_create_node_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceCreateNodeArgs * this_object = CURATOR_SERVICE_CREATE_NODE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_create_node_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceCreateNodeArgs * this_object = CURATOR_SERVICE_CREATE_NODE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceCreateNodeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_create_node_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  CuratorServiceCreateNodeArgs *self = CURATOR_SERVICE_CREATE_NODE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_create_node_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  CuratorServiceCreateNodeArgs *self = CURATOR_SERVICE_CREATE_NODE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_create_node_args_instance_init (CuratorServiceCreateNodeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->spec = g_object_new (TYPE_CREATE_SPEC, NULL);
  object->__isset_spec = FALSE;
}

static void 
curator_service_create_node_args_finalize (GObject *object)
{
  CuratorServiceCreateNodeArgs *tobject = CURATOR_SERVICE_CREATE_NODE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
curator_service_create_node_args_class_init (CuratorServiceCreateNodeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_create_node_args_read;
  struct_class->write = curator_service_create_node_args_write;

  gobject_class->finalize = curator_service_create_node_args_finalize;
  gobject_class->get_property = curator_service_create_node_args_get_property;
  gobject_class->set_property = curator_service_create_node_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CREATE_NODE_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         TYPE_CREATE_SPEC,
                         G_PARAM_READWRITE));
}

GType
curator_service_create_node_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceCreateNodeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_create_node_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceCreateNodeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_create_node_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceCreateNodeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceCreateNodeResultProperties
{
  PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_0,
  PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_EX1
};

/* reads a curator_service_create_node_result object */
static gint32
curator_service_create_node_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceCreateNodeResult * this_object = CURATOR_SERVICE_CREATE_NODE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_create_node_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceCreateNodeResult * this_object = CURATOR_SERVICE_CREATE_NODE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceCreateNodeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_create_node_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  CuratorServiceCreateNodeResult *self = CURATOR_SERVICE_CREATE_NODE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_create_node_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  CuratorServiceCreateNodeResult *self = CURATOR_SERVICE_CREATE_NODE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_create_node_result_instance_init (CuratorServiceCreateNodeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_OPTIONAL_PATH, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_create_node_result_finalize (GObject *object)
{
  CuratorServiceCreateNodeResult *tobject = CURATOR_SERVICE_CREATE_NODE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_create_node_result_class_init (CuratorServiceCreateNodeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_create_node_result_read;
  struct_class->write = curator_service_create_node_result_write;

  gobject_class->finalize = curator_service_create_node_result_finalize;
  gobject_class->get_property = curator_service_create_node_result_get_property;
  gobject_class->set_property = curator_service_create_node_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_OPTIONAL_PATH,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_CREATE_NODE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_create_node_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceCreateNodeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_create_node_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceCreateNodeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_create_node_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceCreateNodeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceDeleteNodeArgsProperties
{
  PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_0,
  PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_SPEC
};

/* reads a curator_service_delete_node_args object */
static gint32
curator_service_delete_node_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceDeleteNodeArgs * this_object = CURATOR_SERVICE_DELETE_NODE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_delete_node_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceDeleteNodeArgs * this_object = CURATOR_SERVICE_DELETE_NODE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceDeleteNodeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_delete_node_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  CuratorServiceDeleteNodeArgs *self = CURATOR_SERVICE_DELETE_NODE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_delete_node_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  CuratorServiceDeleteNodeArgs *self = CURATOR_SERVICE_DELETE_NODE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_delete_node_args_instance_init (CuratorServiceDeleteNodeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->spec = g_object_new (TYPE_DELETE_SPEC, NULL);
  object->__isset_spec = FALSE;
}

static void 
curator_service_delete_node_args_finalize (GObject *object)
{
  CuratorServiceDeleteNodeArgs *tobject = CURATOR_SERVICE_DELETE_NODE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
curator_service_delete_node_args_class_init (CuratorServiceDeleteNodeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_delete_node_args_read;
  struct_class->write = curator_service_delete_node_args_write;

  gobject_class->finalize = curator_service_delete_node_args_finalize;
  gobject_class->get_property = curator_service_delete_node_args_get_property;
  gobject_class->set_property = curator_service_delete_node_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_DELETE_NODE_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         TYPE_DELETE_SPEC,
                         G_PARAM_READWRITE));
}

GType
curator_service_delete_node_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceDeleteNodeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_delete_node_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceDeleteNodeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_delete_node_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceDeleteNodeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceDeleteNodeResultProperties
{
  PROP_CURATOR_SERVICE_DELETE_NODE_RESULT_0,
  PROP_CURATOR_SERVICE_DELETE_NODE_RESULT_EX1
};

/* reads a curator_service_delete_node_result object */
static gint32
curator_service_delete_node_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceDeleteNodeResult * this_object = CURATOR_SERVICE_DELETE_NODE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_delete_node_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceDeleteNodeResult * this_object = CURATOR_SERVICE_DELETE_NODE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceDeleteNodeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_delete_node_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  CuratorServiceDeleteNodeResult *self = CURATOR_SERVICE_DELETE_NODE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_DELETE_NODE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_delete_node_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  CuratorServiceDeleteNodeResult *self = CURATOR_SERVICE_DELETE_NODE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_DELETE_NODE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_delete_node_result_instance_init (CuratorServiceDeleteNodeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_delete_node_result_finalize (GObject *object)
{
  CuratorServiceDeleteNodeResult *tobject = CURATOR_SERVICE_DELETE_NODE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_delete_node_result_class_init (CuratorServiceDeleteNodeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_delete_node_result_read;
  struct_class->write = curator_service_delete_node_result_write;

  gobject_class->finalize = curator_service_delete_node_result_finalize;
  gobject_class->get_property = curator_service_delete_node_result_get_property;
  gobject_class->set_property = curator_service_delete_node_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_DELETE_NODE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_delete_node_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceDeleteNodeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_delete_node_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceDeleteNodeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_delete_node_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceDeleteNodeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceExistsArgsProperties
{
  PROP_CURATOR_SERVICE_EXISTS_ARGS_0,
  PROP_CURATOR_SERVICE_EXISTS_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_EXISTS_ARGS_SPEC
};

/* reads a curator_service_exists_args object */
static gint32
curator_service_exists_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceExistsArgs * this_object = CURATOR_SERVICE_EXISTS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_exists_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceExistsArgs * this_object = CURATOR_SERVICE_EXISTS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceExistsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_exists_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  CuratorServiceExistsArgs *self = CURATOR_SERVICE_EXISTS_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_EXISTS_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_EXISTS_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_exists_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  CuratorServiceExistsArgs *self = CURATOR_SERVICE_EXISTS_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_EXISTS_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_EXISTS_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_exists_args_instance_init (CuratorServiceExistsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->spec = g_object_new (TYPE_EXISTS_SPEC, NULL);
  object->__isset_spec = FALSE;
}

static void 
curator_service_exists_args_finalize (GObject *object)
{
  CuratorServiceExistsArgs *tobject = CURATOR_SERVICE_EXISTS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
curator_service_exists_args_class_init (CuratorServiceExistsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_exists_args_read;
  struct_class->write = curator_service_exists_args_write;

  gobject_class->finalize = curator_service_exists_args_finalize;
  gobject_class->get_property = curator_service_exists_args_get_property;
  gobject_class->set_property = curator_service_exists_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_EXISTS_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_EXISTS_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         TYPE_EXISTS_SPEC,
                         G_PARAM_READWRITE));
}

GType
curator_service_exists_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceExistsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_exists_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceExistsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_exists_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceExistsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceExistsResultProperties
{
  PROP_CURATOR_SERVICE_EXISTS_RESULT_0,
  PROP_CURATOR_SERVICE_EXISTS_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_EXISTS_RESULT_EX1
};

/* reads a curator_service_exists_result object */
static gint32
curator_service_exists_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceExistsResult * this_object = CURATOR_SERVICE_EXISTS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_exists_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceExistsResult * this_object = CURATOR_SERVICE_EXISTS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceExistsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_exists_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  CuratorServiceExistsResult *self = CURATOR_SERVICE_EXISTS_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_EXISTS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_EXISTS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_exists_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  CuratorServiceExistsResult *self = CURATOR_SERVICE_EXISTS_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_EXISTS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_EXISTS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_exists_result_instance_init (CuratorServiceExistsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_OPTIONAL_STAT, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_exists_result_finalize (GObject *object)
{
  CuratorServiceExistsResult *tobject = CURATOR_SERVICE_EXISTS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_exists_result_class_init (CuratorServiceExistsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_exists_result_read;
  struct_class->write = curator_service_exists_result_write;

  gobject_class->finalize = curator_service_exists_result_finalize;
  gobject_class->get_property = curator_service_exists_result_get_property;
  gobject_class->set_property = curator_service_exists_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_EXISTS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_OPTIONAL_STAT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_EXISTS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_exists_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceExistsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_exists_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceExistsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_exists_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceExistsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetChildrenArgsProperties
{
  PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_0,
  PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_SPEC
};

/* reads a curator_service_get_children_args object */
static gint32
curator_service_get_children_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetChildrenArgs * this_object = CURATOR_SERVICE_GET_CHILDREN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_children_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetChildrenArgs * this_object = CURATOR_SERVICE_GET_CHILDREN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetChildrenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_children_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  CuratorServiceGetChildrenArgs *self = CURATOR_SERVICE_GET_CHILDREN_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_children_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  CuratorServiceGetChildrenArgs *self = CURATOR_SERVICE_GET_CHILDREN_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_children_args_instance_init (CuratorServiceGetChildrenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->spec = g_object_new (TYPE_GET_CHILDREN_SPEC, NULL);
  object->__isset_spec = FALSE;
}

static void 
curator_service_get_children_args_finalize (GObject *object)
{
  CuratorServiceGetChildrenArgs *tobject = CURATOR_SERVICE_GET_CHILDREN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
curator_service_get_children_args_class_init (CuratorServiceGetChildrenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_children_args_read;
  struct_class->write = curator_service_get_children_args_write;

  gobject_class->finalize = curator_service_get_children_args_finalize;
  gobject_class->get_property = curator_service_get_children_args_get_property;
  gobject_class->set_property = curator_service_get_children_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_CHILDREN_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         TYPE_GET_CHILDREN_SPEC,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_children_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetChildrenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_children_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetChildrenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_children_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetChildrenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetChildrenResultProperties
{
  PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_0,
  PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_EX1
};

/* reads a curator_service_get_children_result object */
static gint32
curator_service_get_children_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetChildrenResult * this_object = CURATOR_SERVICE_GET_CHILDREN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_children_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetChildrenResult * this_object = CURATOR_SERVICE_GET_CHILDREN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetChildrenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_children_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  CuratorServiceGetChildrenResult *self = CURATOR_SERVICE_GET_CHILDREN_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_children_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  CuratorServiceGetChildrenResult *self = CURATOR_SERVICE_GET_CHILDREN_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_children_result_instance_init (CuratorServiceGetChildrenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_OPTIONAL_CHILDREN_LIST, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_get_children_result_finalize (GObject *object)
{
  CuratorServiceGetChildrenResult *tobject = CURATOR_SERVICE_GET_CHILDREN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_get_children_result_class_init (CuratorServiceGetChildrenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_children_result_read;
  struct_class->write = curator_service_get_children_result_write;

  gobject_class->finalize = curator_service_get_children_result_finalize;
  gobject_class->get_property = curator_service_get_children_result_get_property;
  gobject_class->set_property = curator_service_get_children_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_OPTIONAL_CHILDREN_LIST,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_CHILDREN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_children_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetChildrenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_children_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetChildrenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_children_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetChildrenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetDataArgsProperties
{
  PROP_CURATOR_SERVICE_GET_DATA_ARGS_0,
  PROP_CURATOR_SERVICE_GET_DATA_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_GET_DATA_ARGS_SPEC
};

/* reads a curator_service_get_data_args object */
static gint32
curator_service_get_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetDataArgs * this_object = CURATOR_SERVICE_GET_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetDataArgs * this_object = CURATOR_SERVICE_GET_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_data_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  CuratorServiceGetDataArgs *self = CURATOR_SERVICE_GET_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_DATA_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_DATA_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_data_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  CuratorServiceGetDataArgs *self = CURATOR_SERVICE_GET_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_DATA_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_GET_DATA_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_data_args_instance_init (CuratorServiceGetDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->spec = g_object_new (TYPE_GET_DATA_SPEC, NULL);
  object->__isset_spec = FALSE;
}

static void 
curator_service_get_data_args_finalize (GObject *object)
{
  CuratorServiceGetDataArgs *tobject = CURATOR_SERVICE_GET_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
curator_service_get_data_args_class_init (CuratorServiceGetDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_data_args_read;
  struct_class->write = curator_service_get_data_args_write;

  gobject_class->finalize = curator_service_get_data_args_finalize;
  gobject_class->get_property = curator_service_get_data_args_get_property;
  gobject_class->set_property = curator_service_get_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_DATA_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_DATA_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         TYPE_GET_DATA_SPEC,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetDataResultProperties
{
  PROP_CURATOR_SERVICE_GET_DATA_RESULT_0,
  PROP_CURATOR_SERVICE_GET_DATA_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_GET_DATA_RESULT_EX1
};

/* reads a curator_service_get_data_result object */
static gint32
curator_service_get_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetDataResult * this_object = CURATOR_SERVICE_GET_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetDataResult * this_object = CURATOR_SERVICE_GET_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_data_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  CuratorServiceGetDataResult *self = CURATOR_SERVICE_GET_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_DATA_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_data_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  CuratorServiceGetDataResult *self = CURATOR_SERVICE_GET_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_DATA_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_GET_DATA_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_data_result_instance_init (CuratorServiceGetDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_OPTIONAL_DATA, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_get_data_result_finalize (GObject *object)
{
  CuratorServiceGetDataResult *tobject = CURATOR_SERVICE_GET_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_get_data_result_class_init (CuratorServiceGetDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_data_result_read;
  struct_class->write = curator_service_get_data_result_write;

  gobject_class->finalize = curator_service_get_data_result_finalize;
  gobject_class->get_property = curator_service_get_data_result_get_property;
  gobject_class->set_property = curator_service_get_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_DATA_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_OPTIONAL_DATA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_DATA_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetLeaderParticipantsArgsProperties
{
  PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_0,
  PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_LEADER_PROJECTION
};

/* reads a curator_service_get_leader_participants_args object */
static gint32
curator_service_get_leader_participants_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetLeaderParticipantsArgs * this_object = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->leaderProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_leaderProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_leader_participants_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetLeaderParticipantsArgs * this_object = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetLeaderParticipantsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "leaderProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->leaderProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_leader_participants_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  CuratorServiceGetLeaderParticipantsArgs *self = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_LEADER_PROJECTION:
      if (self->leaderProjection != NULL)
        g_object_unref (self->leaderProjection);
      self->leaderProjection = g_value_dup_object (value);
      self->__isset_leaderProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_leader_participants_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  CuratorServiceGetLeaderParticipantsArgs *self = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_LEADER_PROJECTION:
      g_value_set_object (value, self->leaderProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_leader_participants_args_instance_init (CuratorServiceGetLeaderParticipantsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->leaderProjection = g_object_new (TYPE_LEADER_PROJECTION, NULL);
  object->__isset_leaderProjection = FALSE;
}

static void 
curator_service_get_leader_participants_args_finalize (GObject *object)
{
  CuratorServiceGetLeaderParticipantsArgs *tobject = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->leaderProjection != NULL)
  {
    g_object_unref(tobject->leaderProjection);
    tobject->leaderProjection = NULL;
  }
}

static void
curator_service_get_leader_participants_args_class_init (CuratorServiceGetLeaderParticipantsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_leader_participants_args_read;
  struct_class->write = curator_service_get_leader_participants_args_write;

  gobject_class->finalize = curator_service_get_leader_participants_args_finalize;
  gobject_class->get_property = curator_service_get_leader_participants_args_get_property;
  gobject_class->set_property = curator_service_get_leader_participants_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_ARGS_LEADER_PROJECTION,
     g_param_spec_object ("leaderProjection",
                         NULL,
                         NULL,
                         TYPE_LEADER_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_leader_participants_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetLeaderParticipantsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_leader_participants_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetLeaderParticipantsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_leader_participants_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetLeaderParticipantsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetLeaderParticipantsResultProperties
{
  PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_0,
  PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_EX1
};

/* reads a curator_service_get_leader_participants_result object */
static gint32
curator_service_get_leader_participants_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetLeaderParticipantsResult * this_object = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Participant * _elem17 = NULL;
              if ( _elem17 != NULL)
              {
                g_object_unref (_elem17);
              }
              _elem17 = g_object_new (TYPE_PARTICIPANT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem17), protocol, error)) < 0)
              {
                g_object_unref (_elem17);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem17);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_leader_participants_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetLeaderParticipantsResult * this_object = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetLeaderParticipantsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i18;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i18 = 0; i18 < this_object->success->len; i18++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i18))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_leader_participants_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  CuratorServiceGetLeaderParticipantsResult *self = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_leader_participants_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  CuratorServiceGetLeaderParticipantsResult *self = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_leader_participants_result_instance_init (CuratorServiceGetLeaderParticipantsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_get_leader_participants_result_finalize (GObject *object)
{
  CuratorServiceGetLeaderParticipantsResult *tobject = CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_get_leader_participants_result_class_init (CuratorServiceGetLeaderParticipantsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_leader_participants_result_read;
  struct_class->write = curator_service_get_leader_participants_result_write;

  gobject_class->finalize = curator_service_get_leader_participants_result_finalize;
  gobject_class->get_property = curator_service_get_leader_participants_result_get_property;
  gobject_class->set_property = curator_service_get_leader_participants_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_LEADER_PARTICIPANTS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_leader_participants_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetLeaderParticipantsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_leader_participants_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetLeaderParticipantsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_leader_participants_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetLeaderParticipantsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetNodeCacheDataArgsProperties
{
  PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_0,
  PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_CACHE_PROJECTION
};

/* reads a curator_service_get_node_cache_data_args object */
static gint32
curator_service_get_node_cache_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetNodeCacheDataArgs * this_object = CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cacheProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cacheProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_node_cache_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetNodeCacheDataArgs * this_object = CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetNodeCacheDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cacheProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cacheProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_node_cache_data_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  CuratorServiceGetNodeCacheDataArgs *self = CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_CACHE_PROJECTION:
      if (self->cacheProjection != NULL)
        g_object_unref (self->cacheProjection);
      self->cacheProjection = g_value_dup_object (value);
      self->__isset_cacheProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_node_cache_data_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  CuratorServiceGetNodeCacheDataArgs *self = CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_CACHE_PROJECTION:
      g_value_set_object (value, self->cacheProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_node_cache_data_args_instance_init (CuratorServiceGetNodeCacheDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->cacheProjection = g_object_new (TYPE_NODE_CACHE_PROJECTION, NULL);
  object->__isset_cacheProjection = FALSE;
}

static void 
curator_service_get_node_cache_data_args_finalize (GObject *object)
{
  CuratorServiceGetNodeCacheDataArgs *tobject = CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->cacheProjection != NULL)
  {
    g_object_unref(tobject->cacheProjection);
    tobject->cacheProjection = NULL;
  }
}

static void
curator_service_get_node_cache_data_args_class_init (CuratorServiceGetNodeCacheDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_node_cache_data_args_read;
  struct_class->write = curator_service_get_node_cache_data_args_write;

  gobject_class->finalize = curator_service_get_node_cache_data_args_finalize;
  gobject_class->get_property = curator_service_get_node_cache_data_args_get_property;
  gobject_class->set_property = curator_service_get_node_cache_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_ARGS_CACHE_PROJECTION,
     g_param_spec_object ("cacheProjection",
                         NULL,
                         NULL,
                         TYPE_NODE_CACHE_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_node_cache_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetNodeCacheDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_node_cache_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetNodeCacheDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_node_cache_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetNodeCacheDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetNodeCacheDataResultProperties
{
  PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_0,
  PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_EX1
};

/* reads a curator_service_get_node_cache_data_result object */
static gint32
curator_service_get_node_cache_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetNodeCacheDataResult * this_object = CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_node_cache_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetNodeCacheDataResult * this_object = CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetNodeCacheDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_node_cache_data_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  CuratorServiceGetNodeCacheDataResult *self = CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_node_cache_data_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  CuratorServiceGetNodeCacheDataResult *self = CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_node_cache_data_result_instance_init (CuratorServiceGetNodeCacheDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_CHILD_DATA, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_get_node_cache_data_result_finalize (GObject *object)
{
  CuratorServiceGetNodeCacheDataResult *tobject = CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_get_node_cache_data_result_class_init (CuratorServiceGetNodeCacheDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_node_cache_data_result_read;
  struct_class->write = curator_service_get_node_cache_data_result_write;

  gobject_class->finalize = curator_service_get_node_cache_data_result_finalize;
  gobject_class->get_property = curator_service_get_node_cache_data_result_get_property;
  gobject_class->set_property = curator_service_get_node_cache_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_CHILD_DATA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_NODE_CACHE_DATA_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_node_cache_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetNodeCacheDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_node_cache_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetNodeCacheDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_node_cache_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetNodeCacheDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetPathChildrenCacheDataArgsProperties
{
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_0,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_CACHE_PROJECTION
};

/* reads a curator_service_get_path_children_cache_data_args object */
static gint32
curator_service_get_path_children_cache_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetPathChildrenCacheDataArgs * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cacheProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cacheProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_path_children_cache_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetPathChildrenCacheDataArgs * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetPathChildrenCacheDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cacheProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cacheProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_path_children_cache_data_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataArgs *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_CACHE_PROJECTION:
      if (self->cacheProjection != NULL)
        g_object_unref (self->cacheProjection);
      self->cacheProjection = g_value_dup_object (value);
      self->__isset_cacheProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_path_children_cache_data_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataArgs *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_CACHE_PROJECTION:
      g_value_set_object (value, self->cacheProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_path_children_cache_data_args_instance_init (CuratorServiceGetPathChildrenCacheDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->cacheProjection = g_object_new (TYPE_PATH_CHILDREN_CACHE_PROJECTION, NULL);
  object->__isset_cacheProjection = FALSE;
}

static void 
curator_service_get_path_children_cache_data_args_finalize (GObject *object)
{
  CuratorServiceGetPathChildrenCacheDataArgs *tobject = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->cacheProjection != NULL)
  {
    g_object_unref(tobject->cacheProjection);
    tobject->cacheProjection = NULL;
  }
}

static void
curator_service_get_path_children_cache_data_args_class_init (CuratorServiceGetPathChildrenCacheDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_path_children_cache_data_args_read;
  struct_class->write = curator_service_get_path_children_cache_data_args_write;

  gobject_class->finalize = curator_service_get_path_children_cache_data_args_finalize;
  gobject_class->get_property = curator_service_get_path_children_cache_data_args_get_property;
  gobject_class->set_property = curator_service_get_path_children_cache_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_ARGS_CACHE_PROJECTION,
     g_param_spec_object ("cacheProjection",
                         NULL,
                         NULL,
                         TYPE_PATH_CHILDREN_CACHE_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_path_children_cache_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetPathChildrenCacheDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_path_children_cache_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetPathChildrenCacheDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_path_children_cache_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetPathChildrenCacheDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetPathChildrenCacheDataResultProperties
{
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_0,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_EX1
};

/* reads a curator_service_get_path_children_cache_data_result object */
static gint32
curator_service_get_path_children_cache_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetPathChildrenCacheDataResult * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ChildData * _elem19 = NULL;
              if ( _elem19 != NULL)
              {
                g_object_unref (_elem19);
              }
              _elem19 = g_object_new (TYPE_CHILD_DATA, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem19), protocol, error)) < 0)
              {
                g_object_unref (_elem19);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem19);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_path_children_cache_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetPathChildrenCacheDataResult * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetPathChildrenCacheDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i20;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i20 = 0; i20 < this_object->success->len; i20++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i20))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_path_children_cache_data_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataResult *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_path_children_cache_data_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataResult *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_path_children_cache_data_result_instance_init (CuratorServiceGetPathChildrenCacheDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_get_path_children_cache_data_result_finalize (GObject *object)
{
  CuratorServiceGetPathChildrenCacheDataResult *tobject = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_get_path_children_cache_data_result_class_init (CuratorServiceGetPathChildrenCacheDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_path_children_cache_data_result_read;
  struct_class->write = curator_service_get_path_children_cache_data_result_write;

  gobject_class->finalize = curator_service_get_path_children_cache_data_result_finalize;
  gobject_class->get_property = curator_service_get_path_children_cache_data_result_get_property;
  gobject_class->set_property = curator_service_get_path_children_cache_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_path_children_cache_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetPathChildrenCacheDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_path_children_cache_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetPathChildrenCacheDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_path_children_cache_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetPathChildrenCacheDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetPathChildrenCacheDataForPathArgsProperties
{
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_0,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_CACHE_PROJECTION,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PATH
};

/* reads a curator_service_get_path_children_cache_data_for_path_args object */
static gint32
curator_service_get_path_children_cache_data_for_path_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetPathChildrenCacheDataForPathArgs * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cacheProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cacheProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_path_children_cache_data_for_path_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetPathChildrenCacheDataForPathArgs * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetPathChildrenCacheDataForPathArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cacheProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cacheProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_path_children_cache_data_for_path_args_set_property (GObject *object,
                                                                         guint property_id,
                                                                         const GValue *value,
                                                                         GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataForPathArgs *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_CACHE_PROJECTION:
      if (self->cacheProjection != NULL)
        g_object_unref (self->cacheProjection);
      self->cacheProjection = g_value_dup_object (value);
      self->__isset_cacheProjection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_path_children_cache_data_for_path_args_get_property (GObject *object,
                                                                         guint property_id,
                                                                         GValue *value,
                                                                         GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataForPathArgs *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_CACHE_PROJECTION:
      g_value_set_object (value, self->cacheProjection);
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_path_children_cache_data_for_path_args_instance_init (CuratorServiceGetPathChildrenCacheDataForPathArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->cacheProjection = g_object_new (TYPE_PATH_CHILDREN_CACHE_PROJECTION, NULL);
  object->__isset_cacheProjection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
}

static void 
curator_service_get_path_children_cache_data_for_path_args_finalize (GObject *object)
{
  CuratorServiceGetPathChildrenCacheDataForPathArgs *tobject = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->cacheProjection != NULL)
  {
    g_object_unref(tobject->cacheProjection);
    tobject->cacheProjection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
curator_service_get_path_children_cache_data_for_path_args_class_init (CuratorServiceGetPathChildrenCacheDataForPathArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_path_children_cache_data_for_path_args_read;
  struct_class->write = curator_service_get_path_children_cache_data_for_path_args_write;

  gobject_class->finalize = curator_service_get_path_children_cache_data_for_path_args_finalize;
  gobject_class->get_property = curator_service_get_path_children_cache_data_for_path_args_get_property;
  gobject_class->set_property = curator_service_get_path_children_cache_data_for_path_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_CACHE_PROJECTION,
     g_param_spec_object ("cacheProjection",
                         NULL,
                         NULL,
                         TYPE_PATH_CHILDREN_CACHE_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
curator_service_get_path_children_cache_data_for_path_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetPathChildrenCacheDataForPathArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_path_children_cache_data_for_path_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetPathChildrenCacheDataForPathArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_path_children_cache_data_for_path_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetPathChildrenCacheDataForPathArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceGetPathChildrenCacheDataForPathResultProperties
{
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_0,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_EX1
};

/* reads a curator_service_get_path_children_cache_data_for_path_result object */
static gint32
curator_service_get_path_children_cache_data_for_path_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceGetPathChildrenCacheDataForPathResult * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_get_path_children_cache_data_for_path_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceGetPathChildrenCacheDataForPathResult * this_object = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceGetPathChildrenCacheDataForPathResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_get_path_children_cache_data_for_path_result_set_property (GObject *object,
                                                                           guint property_id,
                                                                           const GValue *value,
                                                                           GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataForPathResult *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_get_path_children_cache_data_for_path_result_get_property (GObject *object,
                                                                           guint property_id,
                                                                           GValue *value,
                                                                           GParamSpec *pspec)
{
  CuratorServiceGetPathChildrenCacheDataForPathResult *self = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_get_path_children_cache_data_for_path_result_instance_init (CuratorServiceGetPathChildrenCacheDataForPathResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_CHILD_DATA, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_get_path_children_cache_data_for_path_result_finalize (GObject *object)
{
  CuratorServiceGetPathChildrenCacheDataForPathResult *tobject = CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_get_path_children_cache_data_for_path_result_class_init (CuratorServiceGetPathChildrenCacheDataForPathResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_get_path_children_cache_data_for_path_result_read;
  struct_class->write = curator_service_get_path_children_cache_data_for_path_result_write;

  gobject_class->finalize = curator_service_get_path_children_cache_data_for_path_result_finalize;
  gobject_class->get_property = curator_service_get_path_children_cache_data_for_path_result_get_property;
  gobject_class->set_property = curator_service_get_path_children_cache_data_for_path_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_CHILD_DATA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_GET_PATH_CHILDREN_CACHE_DATA_FOR_PATH_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_get_path_children_cache_data_for_path_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceGetPathChildrenCacheDataForPathResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_get_path_children_cache_data_for_path_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceGetPathChildrenCacheDataForPathResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_get_path_children_cache_data_for_path_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceGetPathChildrenCacheDataForPathResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceIsLeaderArgsProperties
{
  PROP_CURATOR_SERVICE_IS_LEADER_ARGS_0,
  PROP_CURATOR_SERVICE_IS_LEADER_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_IS_LEADER_ARGS_LEADER_PROJECTION
};

/* reads a curator_service_is_leader_args object */
static gint32
curator_service_is_leader_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceIsLeaderArgs * this_object = CURATOR_SERVICE_IS_LEADER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->leaderProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_leaderProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_is_leader_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceIsLeaderArgs * this_object = CURATOR_SERVICE_IS_LEADER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceIsLeaderArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "leaderProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->leaderProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_is_leader_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  CuratorServiceIsLeaderArgs *self = CURATOR_SERVICE_IS_LEADER_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_IS_LEADER_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_IS_LEADER_ARGS_LEADER_PROJECTION:
      if (self->leaderProjection != NULL)
        g_object_unref (self->leaderProjection);
      self->leaderProjection = g_value_dup_object (value);
      self->__isset_leaderProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_is_leader_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  CuratorServiceIsLeaderArgs *self = CURATOR_SERVICE_IS_LEADER_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_IS_LEADER_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_IS_LEADER_ARGS_LEADER_PROJECTION:
      g_value_set_object (value, self->leaderProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_is_leader_args_instance_init (CuratorServiceIsLeaderArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->leaderProjection = g_object_new (TYPE_LEADER_PROJECTION, NULL);
  object->__isset_leaderProjection = FALSE;
}

static void 
curator_service_is_leader_args_finalize (GObject *object)
{
  CuratorServiceIsLeaderArgs *tobject = CURATOR_SERVICE_IS_LEADER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->leaderProjection != NULL)
  {
    g_object_unref(tobject->leaderProjection);
    tobject->leaderProjection = NULL;
  }
}

static void
curator_service_is_leader_args_class_init (CuratorServiceIsLeaderArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_is_leader_args_read;
  struct_class->write = curator_service_is_leader_args_write;

  gobject_class->finalize = curator_service_is_leader_args_finalize;
  gobject_class->get_property = curator_service_is_leader_args_get_property;
  gobject_class->set_property = curator_service_is_leader_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_IS_LEADER_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_IS_LEADER_ARGS_LEADER_PROJECTION,
     g_param_spec_object ("leaderProjection",
                         NULL,
                         NULL,
                         TYPE_LEADER_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_is_leader_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceIsLeaderArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_is_leader_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceIsLeaderArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_is_leader_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceIsLeaderArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceIsLeaderResultProperties
{
  PROP_CURATOR_SERVICE_IS_LEADER_RESULT_0,
  PROP_CURATOR_SERVICE_IS_LEADER_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_IS_LEADER_RESULT_EX1
};

/* reads a curator_service_is_leader_result object */
static gint32
curator_service_is_leader_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceIsLeaderResult * this_object = CURATOR_SERVICE_IS_LEADER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_is_leader_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceIsLeaderResult * this_object = CURATOR_SERVICE_IS_LEADER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceIsLeaderResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_is_leader_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  CuratorServiceIsLeaderResult *self = CURATOR_SERVICE_IS_LEADER_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_IS_LEADER_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_IS_LEADER_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_is_leader_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  CuratorServiceIsLeaderResult *self = CURATOR_SERVICE_IS_LEADER_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_IS_LEADER_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_IS_LEADER_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_is_leader_result_instance_init (CuratorServiceIsLeaderResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_is_leader_result_finalize (GObject *object)
{
  CuratorServiceIsLeaderResult *tobject = CURATOR_SERVICE_IS_LEADER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_is_leader_result_class_init (CuratorServiceIsLeaderResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_is_leader_result_read;
  struct_class->write = curator_service_is_leader_result_write;

  gobject_class->finalize = curator_service_is_leader_result_finalize;
  gobject_class->get_property = curator_service_is_leader_result_get_property;
  gobject_class->set_property = curator_service_is_leader_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_IS_LEADER_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_IS_LEADER_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_is_leader_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceIsLeaderResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_is_leader_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceIsLeaderResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_is_leader_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceIsLeaderResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceNewCuratorProjectionArgsProperties
{
  PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS_0,
  PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS_CONNECTION_NAME
};

/* reads a curator_service_new_curator_projection_args object */
static gint32
curator_service_new_curator_projection_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceNewCuratorProjectionArgs * this_object = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->connectionName != NULL)
          {
            g_free(this_object->connectionName);
            this_object->connectionName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->connectionName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_connectionName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_new_curator_projection_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceNewCuratorProjectionArgs * this_object = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceNewCuratorProjectionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "connectionName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->connectionName, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_new_curator_projection_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  CuratorServiceNewCuratorProjectionArgs *self = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS_CONNECTION_NAME:
      if (self->connectionName != NULL)
        g_free (self->connectionName);
      self->connectionName = g_value_dup_string (value);
      self->__isset_connectionName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_new_curator_projection_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  CuratorServiceNewCuratorProjectionArgs *self = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS_CONNECTION_NAME:
      g_value_set_string (value, self->connectionName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_new_curator_projection_args_instance_init (CuratorServiceNewCuratorProjectionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->connectionName = NULL;
  object->__isset_connectionName = FALSE;
}

static void 
curator_service_new_curator_projection_args_finalize (GObject *object)
{
  CuratorServiceNewCuratorProjectionArgs *tobject = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->connectionName != NULL)
  {
    g_free(tobject->connectionName);
    tobject->connectionName = NULL;
  }
}

static void
curator_service_new_curator_projection_args_class_init (CuratorServiceNewCuratorProjectionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_new_curator_projection_args_read;
  struct_class->write = curator_service_new_curator_projection_args_write;

  gobject_class->finalize = curator_service_new_curator_projection_args_finalize;
  gobject_class->get_property = curator_service_new_curator_projection_args_get_property;
  gobject_class->set_property = curator_service_new_curator_projection_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_ARGS_CONNECTION_NAME,
     g_param_spec_string ("connectionName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
curator_service_new_curator_projection_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceNewCuratorProjectionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_new_curator_projection_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceNewCuratorProjectionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_new_curator_projection_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceNewCuratorProjectionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceNewCuratorProjectionResultProperties
{
  PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_0,
  PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_EX1
};

/* reads a curator_service_new_curator_projection_result object */
static gint32
curator_service_new_curator_projection_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceNewCuratorProjectionResult * this_object = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_new_curator_projection_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceNewCuratorProjectionResult * this_object = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceNewCuratorProjectionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_new_curator_projection_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  CuratorServiceNewCuratorProjectionResult *self = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_new_curator_projection_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  CuratorServiceNewCuratorProjectionResult *self = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_new_curator_projection_result_instance_init (CuratorServiceNewCuratorProjectionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_new_curator_projection_result_finalize (GObject *object)
{
  CuratorServiceNewCuratorProjectionResult *tobject = CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_new_curator_projection_result_class_init (CuratorServiceNewCuratorProjectionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_new_curator_projection_result_read;
  struct_class->write = curator_service_new_curator_projection_result_write;

  gobject_class->finalize = curator_service_new_curator_projection_result_finalize;
  gobject_class->get_property = curator_service_new_curator_projection_result_get_property;
  gobject_class->set_property = curator_service_new_curator_projection_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_NEW_CURATOR_PROJECTION_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_new_curator_projection_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceNewCuratorProjectionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_new_curator_projection_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceNewCuratorProjectionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_new_curator_projection_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceNewCuratorProjectionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServicePingCuratorProjectionArgsProperties
{
  PROP_CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS_0,
  PROP_CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS_PROJECTION
};

/* reads a curator_service_ping_curator_projection_args object */
static gint32
curator_service_ping_curator_projection_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServicePingCuratorProjectionArgs * this_object = CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_ping_curator_projection_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServicePingCuratorProjectionArgs * this_object = CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServicePingCuratorProjectionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_ping_curator_projection_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  CuratorServicePingCuratorProjectionArgs *self = CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_ping_curator_projection_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  CuratorServicePingCuratorProjectionArgs *self = CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_ping_curator_projection_args_instance_init (CuratorServicePingCuratorProjectionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
}

static void 
curator_service_ping_curator_projection_args_finalize (GObject *object)
{
  CuratorServicePingCuratorProjectionArgs *tobject = CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
}

static void
curator_service_ping_curator_projection_args_class_init (CuratorServicePingCuratorProjectionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_ping_curator_projection_args_read;
  struct_class->write = curator_service_ping_curator_projection_args_write;

  gobject_class->finalize = curator_service_ping_curator_projection_args_finalize;
  gobject_class->get_property = curator_service_ping_curator_projection_args_get_property;
  gobject_class->set_property = curator_service_ping_curator_projection_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_PING_CURATOR_PROJECTION_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_ping_curator_projection_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServicePingCuratorProjectionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_ping_curator_projection_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServicePingCuratorProjectionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_ping_curator_projection_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServicePingCuratorProjectionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceSetDataArgsProperties
{
  PROP_CURATOR_SERVICE_SET_DATA_ARGS_0,
  PROP_CURATOR_SERVICE_SET_DATA_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_SET_DATA_ARGS_SPEC
};

/* reads a curator_service_set_data_args object */
static gint32
curator_service_set_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceSetDataArgs * this_object = CURATOR_SERVICE_SET_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_set_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceSetDataArgs * this_object = CURATOR_SERVICE_SET_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceSetDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_set_data_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  CuratorServiceSetDataArgs *self = CURATOR_SERVICE_SET_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SET_DATA_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_SET_DATA_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_set_data_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  CuratorServiceSetDataArgs *self = CURATOR_SERVICE_SET_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SET_DATA_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_SET_DATA_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_set_data_args_instance_init (CuratorServiceSetDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->spec = g_object_new (TYPE_SET_DATA_SPEC, NULL);
  object->__isset_spec = FALSE;
}

static void 
curator_service_set_data_args_finalize (GObject *object)
{
  CuratorServiceSetDataArgs *tobject = CURATOR_SERVICE_SET_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
curator_service_set_data_args_class_init (CuratorServiceSetDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_set_data_args_read;
  struct_class->write = curator_service_set_data_args_write;

  gobject_class->finalize = curator_service_set_data_args_finalize;
  gobject_class->get_property = curator_service_set_data_args_get_property;
  gobject_class->set_property = curator_service_set_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SET_DATA_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SET_DATA_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         TYPE_SET_DATA_SPEC,
                         G_PARAM_READWRITE));
}

GType
curator_service_set_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceSetDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_set_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceSetDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_set_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceSetDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceSetDataResultProperties
{
  PROP_CURATOR_SERVICE_SET_DATA_RESULT_0,
  PROP_CURATOR_SERVICE_SET_DATA_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_SET_DATA_RESULT_EX1
};

/* reads a curator_service_set_data_result object */
static gint32
curator_service_set_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceSetDataResult * this_object = CURATOR_SERVICE_SET_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_set_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceSetDataResult * this_object = CURATOR_SERVICE_SET_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceSetDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_set_data_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  CuratorServiceSetDataResult *self = CURATOR_SERVICE_SET_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SET_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_SET_DATA_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_set_data_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  CuratorServiceSetDataResult *self = CURATOR_SERVICE_SET_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SET_DATA_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_SET_DATA_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_set_data_result_instance_init (CuratorServiceSetDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_OPTIONAL_STAT, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_set_data_result_finalize (GObject *object)
{
  CuratorServiceSetDataResult *tobject = CURATOR_SERVICE_SET_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_set_data_result_class_init (CuratorServiceSetDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_set_data_result_read;
  struct_class->write = curator_service_set_data_result_write;

  gobject_class->finalize = curator_service_set_data_result_finalize;
  gobject_class->get_property = curator_service_set_data_result_get_property;
  gobject_class->set_property = curator_service_set_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SET_DATA_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_OPTIONAL_STAT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SET_DATA_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_set_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceSetDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_set_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceSetDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_set_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceSetDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartLeaderSelectorArgsProperties
{
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_0,
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PATH,
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PARTICIPANT_ID,
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_WAIT_FOR_LEADERSHIP_MS
};

/* reads a curator_service_start_leader_selector_args object */
static gint32
curator_service_start_leader_selector_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartLeaderSelectorArgs * this_object = CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->participantId != NULL)
          {
            g_free(this_object->participantId);
            this_object->participantId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->participantId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_participantId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->waitForLeadershipMs, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_waitForLeadershipMs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_leader_selector_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartLeaderSelectorArgs * this_object = CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartLeaderSelectorArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "participantId", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->participantId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "waitForLeadershipMs", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->waitForLeadershipMs, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_leader_selector_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  CuratorServiceStartLeaderSelectorArgs *self = CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PARTICIPANT_ID:
      if (self->participantId != NULL)
        g_free (self->participantId);
      self->participantId = g_value_dup_string (value);
      self->__isset_participantId = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_WAIT_FOR_LEADERSHIP_MS:
      self->waitForLeadershipMs = g_value_get_int (value);
      self->__isset_waitForLeadershipMs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_leader_selector_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  CuratorServiceStartLeaderSelectorArgs *self = CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PARTICIPANT_ID:
      g_value_set_string (value, self->participantId);
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_WAIT_FOR_LEADERSHIP_MS:
      g_value_set_int (value, self->waitForLeadershipMs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_leader_selector_args_instance_init (CuratorServiceStartLeaderSelectorArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->participantId = NULL;
  object->__isset_participantId = FALSE;
  object->waitForLeadershipMs = 0;
  object->__isset_waitForLeadershipMs = FALSE;
}

static void 
curator_service_start_leader_selector_args_finalize (GObject *object)
{
  CuratorServiceStartLeaderSelectorArgs *tobject = CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->participantId != NULL)
  {
    g_free(tobject->participantId);
    tobject->participantId = NULL;
  }
}

static void
curator_service_start_leader_selector_args_class_init (CuratorServiceStartLeaderSelectorArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_leader_selector_args_read;
  struct_class->write = curator_service_start_leader_selector_args_write;

  gobject_class->finalize = curator_service_start_leader_selector_args_finalize;
  gobject_class->get_property = curator_service_start_leader_selector_args_get_property;
  gobject_class->set_property = curator_service_start_leader_selector_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_PARTICIPANT_ID,
     g_param_spec_string ("participantId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_ARGS_WAIT_FOR_LEADERSHIP_MS,
     g_param_spec_int ("waitForLeadershipMs",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
curator_service_start_leader_selector_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartLeaderSelectorArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_leader_selector_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartLeaderSelectorArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_leader_selector_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartLeaderSelectorArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartLeaderSelectorResultProperties
{
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_0,
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_EX1
};

/* reads a curator_service_start_leader_selector_result object */
static gint32
curator_service_start_leader_selector_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartLeaderSelectorResult * this_object = CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_leader_selector_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartLeaderSelectorResult * this_object = CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartLeaderSelectorResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_leader_selector_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  CuratorServiceStartLeaderSelectorResult *self = CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_leader_selector_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  CuratorServiceStartLeaderSelectorResult *self = CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_leader_selector_result_instance_init (CuratorServiceStartLeaderSelectorResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_LEADER_RESULT, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_start_leader_selector_result_finalize (GObject *object)
{
  CuratorServiceStartLeaderSelectorResult *tobject = CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_start_leader_selector_result_class_init (CuratorServiceStartLeaderSelectorResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_leader_selector_result_read;
  struct_class->write = curator_service_start_leader_selector_result_write;

  gobject_class->finalize = curator_service_start_leader_selector_result_finalize;
  gobject_class->get_property = curator_service_start_leader_selector_result_get_property;
  gobject_class->set_property = curator_service_start_leader_selector_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_LEADER_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_LEADER_SELECTOR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_start_leader_selector_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartLeaderSelectorResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_leader_selector_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartLeaderSelectorResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_leader_selector_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartLeaderSelectorResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartNodeCacheArgsProperties
{
  PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_0,
  PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PATH,
  PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_DATA_IS_COMPRESSED,
  PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_BUILD_INITIAL
};

/* reads a curator_service_start_node_cache_args object */
static gint32
curator_service_start_node_cache_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartNodeCacheArgs * this_object = CURATOR_SERVICE_START_NODE_CACHE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->dataIsCompressed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dataIsCompressed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->buildInitial, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_buildInitial = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_node_cache_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartNodeCacheArgs * this_object = CURATOR_SERVICE_START_NODE_CACHE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartNodeCacheArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "dataIsCompressed", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->dataIsCompressed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "buildInitial", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->buildInitial, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_node_cache_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  CuratorServiceStartNodeCacheArgs *self = CURATOR_SERVICE_START_NODE_CACHE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_DATA_IS_COMPRESSED:
      self->dataIsCompressed = g_value_get_boolean (value);
      self->__isset_dataIsCompressed = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_BUILD_INITIAL:
      self->buildInitial = g_value_get_boolean (value);
      self->__isset_buildInitial = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_node_cache_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  CuratorServiceStartNodeCacheArgs *self = CURATOR_SERVICE_START_NODE_CACHE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_DATA_IS_COMPRESSED:
      g_value_set_boolean (value, self->dataIsCompressed);
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_BUILD_INITIAL:
      g_value_set_boolean (value, self->buildInitial);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_node_cache_args_instance_init (CuratorServiceStartNodeCacheArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->dataIsCompressed = 0;
  object->__isset_dataIsCompressed = FALSE;
  object->buildInitial = 0;
  object->__isset_buildInitial = FALSE;
}

static void 
curator_service_start_node_cache_args_finalize (GObject *object)
{
  CuratorServiceStartNodeCacheArgs *tobject = CURATOR_SERVICE_START_NODE_CACHE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
curator_service_start_node_cache_args_class_init (CuratorServiceStartNodeCacheArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_node_cache_args_read;
  struct_class->write = curator_service_start_node_cache_args_write;

  gobject_class->finalize = curator_service_start_node_cache_args_finalize;
  gobject_class->get_property = curator_service_start_node_cache_args_get_property;
  gobject_class->set_property = curator_service_start_node_cache_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_DATA_IS_COMPRESSED,
     g_param_spec_boolean ("dataIsCompressed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_NODE_CACHE_ARGS_BUILD_INITIAL,
     g_param_spec_boolean ("buildInitial",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
curator_service_start_node_cache_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartNodeCacheArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_node_cache_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartNodeCacheArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_node_cache_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartNodeCacheArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartNodeCacheResultProperties
{
  PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_0,
  PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_EX1
};

/* reads a curator_service_start_node_cache_result object */
static gint32
curator_service_start_node_cache_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartNodeCacheResult * this_object = CURATOR_SERVICE_START_NODE_CACHE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_node_cache_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartNodeCacheResult * this_object = CURATOR_SERVICE_START_NODE_CACHE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartNodeCacheResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_node_cache_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  CuratorServiceStartNodeCacheResult *self = CURATOR_SERVICE_START_NODE_CACHE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_node_cache_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  CuratorServiceStartNodeCacheResult *self = CURATOR_SERVICE_START_NODE_CACHE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_node_cache_result_instance_init (CuratorServiceStartNodeCacheResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NODE_CACHE_PROJECTION, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_start_node_cache_result_finalize (GObject *object)
{
  CuratorServiceStartNodeCacheResult *tobject = CURATOR_SERVICE_START_NODE_CACHE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_start_node_cache_result_class_init (CuratorServiceStartNodeCacheResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_node_cache_result_read;
  struct_class->write = curator_service_start_node_cache_result_write;

  gobject_class->finalize = curator_service_start_node_cache_result_finalize;
  gobject_class->get_property = curator_service_start_node_cache_result_get_property;
  gobject_class->set_property = curator_service_start_node_cache_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NODE_CACHE_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_NODE_CACHE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_start_node_cache_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartNodeCacheResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_node_cache_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartNodeCacheResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_node_cache_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartNodeCacheResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartPathChildrenCacheArgsProperties
{
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_0,
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PATH,
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_CACHE_DATA,
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_DATA_IS_COMPRESSED,
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_START_MODE
};

/* reads a curator_service_start_path_children_cache_args object */
static gint32
curator_service_start_path_children_cache_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartPathChildrenCacheArgs * this_object = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->cacheData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cacheData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->dataIsCompressed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dataIsCompressed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          gint32 ecast21;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast21, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startMode = (PathChildrenCacheStartMode)ecast21;
          this_object->__isset_startMode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_path_children_cache_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartPathChildrenCacheArgs * this_object = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartPathChildrenCacheArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cacheData", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->cacheData, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "dataIsCompressed", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->dataIsCompressed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startMode", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->startMode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_path_children_cache_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  CuratorServiceStartPathChildrenCacheArgs *self = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_CACHE_DATA:
      self->cacheData = g_value_get_boolean (value);
      self->__isset_cacheData = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_DATA_IS_COMPRESSED:
      self->dataIsCompressed = g_value_get_boolean (value);
      self->__isset_dataIsCompressed = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_START_MODE:
      self->startMode = g_value_get_int (value);
      self->__isset_startMode = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_path_children_cache_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  CuratorServiceStartPathChildrenCacheArgs *self = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_CACHE_DATA:
      g_value_set_boolean (value, self->cacheData);
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_DATA_IS_COMPRESSED:
      g_value_set_boolean (value, self->dataIsCompressed);
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_START_MODE:
      g_value_set_int (value, self->startMode);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_path_children_cache_args_instance_init (CuratorServiceStartPathChildrenCacheArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->cacheData = 0;
  object->__isset_cacheData = FALSE;
  object->dataIsCompressed = 0;
  object->__isset_dataIsCompressed = FALSE;
  object->__isset_startMode = FALSE;
}

static void 
curator_service_start_path_children_cache_args_finalize (GObject *object)
{
  CuratorServiceStartPathChildrenCacheArgs *tobject = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
curator_service_start_path_children_cache_args_class_init (CuratorServiceStartPathChildrenCacheArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_path_children_cache_args_read;
  struct_class->write = curator_service_start_path_children_cache_args_write;

  gobject_class->finalize = curator_service_start_path_children_cache_args_finalize;
  gobject_class->get_property = curator_service_start_path_children_cache_args_get_property;
  gobject_class->set_property = curator_service_start_path_children_cache_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_CACHE_DATA,
     g_param_spec_boolean ("cacheData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_DATA_IS_COMPRESSED,
     g_param_spec_boolean ("dataIsCompressed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_ARGS_START_MODE,
     g_param_spec_int ("startMode",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));
}

GType
curator_service_start_path_children_cache_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartPathChildrenCacheArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_path_children_cache_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartPathChildrenCacheArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_path_children_cache_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartPathChildrenCacheArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartPathChildrenCacheResultProperties
{
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_0,
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_EX1
};

/* reads a curator_service_start_path_children_cache_result object */
static gint32
curator_service_start_path_children_cache_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartPathChildrenCacheResult * this_object = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_path_children_cache_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartPathChildrenCacheResult * this_object = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartPathChildrenCacheResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_path_children_cache_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  CuratorServiceStartPathChildrenCacheResult *self = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_path_children_cache_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  CuratorServiceStartPathChildrenCacheResult *self = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_path_children_cache_result_instance_init (CuratorServiceStartPathChildrenCacheResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PATH_CHILDREN_CACHE_PROJECTION, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_start_path_children_cache_result_finalize (GObject *object)
{
  CuratorServiceStartPathChildrenCacheResult *tobject = CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_start_path_children_cache_result_class_init (CuratorServiceStartPathChildrenCacheResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_path_children_cache_result_read;
  struct_class->write = curator_service_start_path_children_cache_result_write;

  gobject_class->finalize = curator_service_start_path_children_cache_result_finalize;
  gobject_class->get_property = curator_service_start_path_children_cache_result_get_property;
  gobject_class->set_property = curator_service_start_path_children_cache_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PATH_CHILDREN_CACHE_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PATH_CHILDREN_CACHE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_start_path_children_cache_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartPathChildrenCacheResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_path_children_cache_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartPathChildrenCacheResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_path_children_cache_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartPathChildrenCacheResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartPersistentEphemeralNodeArgsProperties
{
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_0,
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PATH,
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_DATA,
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_MODE
};

/* reads a curator_service_start_persistent_ephemeral_node_args object */
static gint32
curator_service_start_persistent_ephemeral_node_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartPersistentEphemeralNodeArgs * this_object = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast22;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast22, error)) < 0)
            return -1;
          xfer += ret;
          this_object->mode = (PersistentEphemeralNodeMode)ecast22;
          this_object->__isset_mode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_persistent_ephemeral_node_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartPersistentEphemeralNodeArgs * this_object = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartPersistentEphemeralNodeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->data)->data, ((GByteArray *) this_object->data)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mode", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->mode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_persistent_ephemeral_node_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  CuratorServiceStartPersistentEphemeralNodeArgs *self = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_MODE:
      self->mode = g_value_get_int (value);
      self->__isset_mode = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_persistent_ephemeral_node_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  CuratorServiceStartPersistentEphemeralNodeArgs *self = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_DATA:
      g_value_set_boxed (value, self->data);
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_MODE:
      g_value_set_int (value, self->mode);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_persistent_ephemeral_node_args_instance_init (CuratorServiceStartPersistentEphemeralNodeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->data = NULL;
  object->__isset_data = FALSE;
  object->__isset_mode = FALSE;
}

static void 
curator_service_start_persistent_ephemeral_node_args_finalize (GObject *object)
{
  CuratorServiceStartPersistentEphemeralNodeArgs *tobject = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
}

static void
curator_service_start_persistent_ephemeral_node_args_class_init (CuratorServiceStartPersistentEphemeralNodeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_persistent_ephemeral_node_args_read;
  struct_class->write = curator_service_start_persistent_ephemeral_node_args_write;

  gobject_class->finalize = curator_service_start_persistent_ephemeral_node_args_finalize;
  gobject_class->get_property = curator_service_start_persistent_ephemeral_node_args_get_property;
  gobject_class->set_property = curator_service_start_persistent_ephemeral_node_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_ARGS_MODE,
     g_param_spec_int ("mode",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
curator_service_start_persistent_ephemeral_node_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartPersistentEphemeralNodeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_persistent_ephemeral_node_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartPersistentEphemeralNodeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_persistent_ephemeral_node_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartPersistentEphemeralNodeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceStartPersistentEphemeralNodeResultProperties
{
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_0,
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_SUCCESS,
  PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_EX1
};

/* reads a curator_service_start_persistent_ephemeral_node_result object */
static gint32
curator_service_start_persistent_ephemeral_node_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceStartPersistentEphemeralNodeResult * this_object = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_start_persistent_ephemeral_node_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceStartPersistentEphemeralNodeResult * this_object = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceStartPersistentEphemeralNodeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_start_persistent_ephemeral_node_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  CuratorServiceStartPersistentEphemeralNodeResult *self = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_start_persistent_ephemeral_node_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  CuratorServiceStartPersistentEphemeralNodeResult *self = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_start_persistent_ephemeral_node_result_instance_init (CuratorServiceStartPersistentEphemeralNodeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSISTENT_EPHEMERAL_NODE_PROJECTION, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_start_persistent_ephemeral_node_result_finalize (GObject *object)
{
  CuratorServiceStartPersistentEphemeralNodeResult *tobject = CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_start_persistent_ephemeral_node_result_class_init (CuratorServiceStartPersistentEphemeralNodeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_start_persistent_ephemeral_node_result_read;
  struct_class->write = curator_service_start_persistent_ephemeral_node_result_write;

  gobject_class->finalize = curator_service_start_persistent_ephemeral_node_result_finalize;
  gobject_class->get_property = curator_service_start_persistent_ephemeral_node_result_get_property;
  gobject_class->set_property = curator_service_start_persistent_ephemeral_node_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSISTENT_EPHEMERAL_NODE_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_START_PERSISTENT_EPHEMERAL_NODE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_start_persistent_ephemeral_node_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceStartPersistentEphemeralNodeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_start_persistent_ephemeral_node_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceStartPersistentEphemeralNodeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_start_persistent_ephemeral_node_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceStartPersistentEphemeralNodeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceSyncArgsProperties
{
  PROP_CURATOR_SERVICE_SYNC_ARGS_0,
  PROP_CURATOR_SERVICE_SYNC_ARGS_PROJECTION,
  PROP_CURATOR_SERVICE_SYNC_ARGS_PATH,
  PROP_CURATOR_SERVICE_SYNC_ARGS_ASYNC_CONTEXT
};

/* reads a curator_service_sync_args object */
static gint32
curator_service_sync_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceSyncArgs * this_object = CURATOR_SERVICE_SYNC_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->asyncContext != NULL)
          {
            g_free(this_object->asyncContext);
            this_object->asyncContext = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->asyncContext, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asyncContext = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_sync_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceSyncArgs * this_object = CURATOR_SERVICE_SYNC_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceSyncArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asyncContext", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->asyncContext, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_sync_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  CuratorServiceSyncArgs *self = CURATOR_SERVICE_SYNC_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SYNC_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_CURATOR_SERVICE_SYNC_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_CURATOR_SERVICE_SYNC_ARGS_ASYNC_CONTEXT:
      if (self->asyncContext != NULL)
        g_free (self->asyncContext);
      self->asyncContext = g_value_dup_string (value);
      self->__isset_asyncContext = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_sync_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  CuratorServiceSyncArgs *self = CURATOR_SERVICE_SYNC_ARGS (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SYNC_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_CURATOR_SERVICE_SYNC_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_CURATOR_SERVICE_SYNC_ARGS_ASYNC_CONTEXT:
      g_value_set_string (value, self->asyncContext);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_sync_args_instance_init (CuratorServiceSyncArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->path = NULL;
  object->__isset_path = FALSE;
  object->asyncContext = NULL;
  object->__isset_asyncContext = FALSE;
}

static void 
curator_service_sync_args_finalize (GObject *object)
{
  CuratorServiceSyncArgs *tobject = CURATOR_SERVICE_SYNC_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->asyncContext != NULL)
  {
    g_free(tobject->asyncContext);
    tobject->asyncContext = NULL;
  }
}

static void
curator_service_sync_args_class_init (CuratorServiceSyncArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_sync_args_read;
  struct_class->write = curator_service_sync_args_write;

  gobject_class->finalize = curator_service_sync_args_finalize;
  gobject_class->get_property = curator_service_sync_args_get_property;
  gobject_class->set_property = curator_service_sync_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SYNC_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SYNC_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SYNC_ARGS_ASYNC_CONTEXT,
     g_param_spec_string ("asyncContext",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
curator_service_sync_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceSyncArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_sync_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceSyncArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_sync_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceSyncArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CuratorServiceSyncResultProperties
{
  PROP_CURATOR_SERVICE_SYNC_RESULT_0,
  PROP_CURATOR_SERVICE_SYNC_RESULT_EX1
};

/* reads a curator_service_sync_result object */
static gint32
curator_service_sync_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CuratorServiceSyncResult * this_object = CURATOR_SERVICE_SYNC_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
curator_service_sync_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CuratorServiceSyncResult * this_object = CURATOR_SERVICE_SYNC_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CuratorServiceSyncResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
curator_service_sync_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  CuratorServiceSyncResult *self = CURATOR_SERVICE_SYNC_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SYNC_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
curator_service_sync_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  CuratorServiceSyncResult *self = CURATOR_SERVICE_SYNC_RESULT (object);

  switch (property_id)
  {
    case PROP_CURATOR_SERVICE_SYNC_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
curator_service_sync_result_instance_init (CuratorServiceSyncResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
curator_service_sync_result_finalize (GObject *object)
{
  CuratorServiceSyncResult *tobject = CURATOR_SERVICE_SYNC_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
curator_service_sync_result_class_init (CuratorServiceSyncResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = curator_service_sync_result_read;
  struct_class->write = curator_service_sync_result_write;

  gobject_class->finalize = curator_service_sync_result_finalize;
  gobject_class->get_property = curator_service_sync_result_get_property;
  gobject_class->set_property = curator_service_sync_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CURATOR_SERVICE_SYNC_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
curator_service_sync_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CuratorServiceSyncResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) curator_service_sync_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CuratorServiceSyncResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) curator_service_sync_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CuratorServiceSyncResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _EventServiceGetNextEventArgsProperties
{
  PROP_EVENT_SERVICE_GET_NEXT_EVENT_ARGS_0,
  PROP_EVENT_SERVICE_GET_NEXT_EVENT_ARGS_PROJECTION
};

/* reads a event_service_get_next_event_args object */
static gint32
event_service_get_next_event_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EventServiceGetNextEventArgs * this_object = EVENT_SERVICE_GET_NEXT_EVENT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
event_service_get_next_event_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EventServiceGetNextEventArgs * this_object = EVENT_SERVICE_GET_NEXT_EVENT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EventServiceGetNextEventArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
event_service_get_next_event_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  EventServiceGetNextEventArgs *self = EVENT_SERVICE_GET_NEXT_EVENT_ARGS (object);

  switch (property_id)
  {
    case PROP_EVENT_SERVICE_GET_NEXT_EVENT_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
event_service_get_next_event_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  EventServiceGetNextEventArgs *self = EVENT_SERVICE_GET_NEXT_EVENT_ARGS (object);

  switch (property_id)
  {
    case PROP_EVENT_SERVICE_GET_NEXT_EVENT_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
event_service_get_next_event_args_instance_init (EventServiceGetNextEventArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
}

static void 
event_service_get_next_event_args_finalize (GObject *object)
{
  EventServiceGetNextEventArgs *tobject = EVENT_SERVICE_GET_NEXT_EVENT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
}

static void
event_service_get_next_event_args_class_init (EventServiceGetNextEventArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = event_service_get_next_event_args_read;
  struct_class->write = event_service_get_next_event_args_write;

  gobject_class->finalize = event_service_get_next_event_args_finalize;
  gobject_class->get_property = event_service_get_next_event_args_get_property;
  gobject_class->set_property = event_service_get_next_event_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_EVENT_SERVICE_GET_NEXT_EVENT_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
event_service_get_next_event_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EventServiceGetNextEventArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) event_service_get_next_event_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EventServiceGetNextEventArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) event_service_get_next_event_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EventServiceGetNextEventArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _EventServiceGetNextEventResultProperties
{
  PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_0,
  PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_SUCCESS,
  PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_EX1
};

/* reads a event_service_get_next_event_result object */
static gint32
event_service_get_next_event_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EventServiceGetNextEventResult * this_object = EVENT_SERVICE_GET_NEXT_EVENT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
event_service_get_next_event_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EventServiceGetNextEventResult * this_object = EVENT_SERVICE_GET_NEXT_EVENT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EventServiceGetNextEventResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
event_service_get_next_event_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  EventServiceGetNextEventResult *self = EVENT_SERVICE_GET_NEXT_EVENT_RESULT (object);

  switch (property_id)
  {
    case PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
event_service_get_next_event_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  EventServiceGetNextEventResult *self = EVENT_SERVICE_GET_NEXT_EVENT_RESULT (object);

  switch (property_id)
  {
    case PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
event_service_get_next_event_result_instance_init (EventServiceGetNextEventResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_CURATOR_EVENT, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
event_service_get_next_event_result_finalize (GObject *object)
{
  EventServiceGetNextEventResult *tobject = EVENT_SERVICE_GET_NEXT_EVENT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
event_service_get_next_event_result_class_init (EventServiceGetNextEventResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = event_service_get_next_event_result_read;
  struct_class->write = event_service_get_next_event_result_write;

  gobject_class->finalize = event_service_get_next_event_result_finalize;
  gobject_class->get_property = event_service_get_next_event_result_get_property;
  gobject_class->set_property = event_service_get_next_event_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EVENT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_EVENT_SERVICE_GET_NEXT_EVENT_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
event_service_get_next_event_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EventServiceGetNextEventResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) event_service_get_next_event_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EventServiceGetNextEventResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) event_service_get_next_event_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EventServiceGetNextEventResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceGetAllInstancesArgsProperties
{
  PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_0,
  PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROVIDER_PROJECTION
};

/* reads a discovery_service_get_all_instances_args object */
static gint32
discovery_service_get_all_instances_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceGetAllInstancesArgs * this_object = DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->providerProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_providerProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_get_all_instances_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceGetAllInstancesArgs * this_object = DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceGetAllInstancesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "providerProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->providerProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_get_all_instances_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  DiscoveryServiceGetAllInstancesArgs *self = DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROVIDER_PROJECTION:
      if (self->providerProjection != NULL)
        g_object_unref (self->providerProjection);
      self->providerProjection = g_value_dup_object (value);
      self->__isset_providerProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_get_all_instances_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  DiscoveryServiceGetAllInstancesArgs *self = DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROVIDER_PROJECTION:
      g_value_set_object (value, self->providerProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_get_all_instances_args_instance_init (DiscoveryServiceGetAllInstancesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->providerProjection = g_object_new (TYPE_DISCOVERY_PROVIDER_PROJECTION, NULL);
  object->__isset_providerProjection = FALSE;
}

static void 
discovery_service_get_all_instances_args_finalize (GObject *object)
{
  DiscoveryServiceGetAllInstancesArgs *tobject = DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->providerProjection != NULL)
  {
    g_object_unref(tobject->providerProjection);
    tobject->providerProjection = NULL;
  }
}

static void
discovery_service_get_all_instances_args_class_init (DiscoveryServiceGetAllInstancesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_get_all_instances_args_read;
  struct_class->write = discovery_service_get_all_instances_args_write;

  gobject_class->finalize = discovery_service_get_all_instances_args_finalize;
  gobject_class->get_property = discovery_service_get_all_instances_args_get_property;
  gobject_class->set_property = discovery_service_get_all_instances_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_ARGS_PROVIDER_PROJECTION,
     g_param_spec_object ("providerProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROVIDER_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_get_all_instances_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceGetAllInstancesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_get_all_instances_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceGetAllInstancesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_get_all_instances_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceGetAllInstancesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceGetAllInstancesResultProperties
{
  PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_0,
  PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_EX1
};

/* reads a discovery_service_get_all_instances_result object */
static gint32
discovery_service_get_all_instances_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceGetAllInstancesResult * this_object = DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              DiscoveryInstance * _elem26 = NULL;
              if ( _elem26 != NULL)
              {
                g_object_unref (_elem26);
              }
              _elem26 = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem26), protocol, error)) < 0)
              {
                g_object_unref (_elem26);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem26);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_get_all_instances_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceGetAllInstancesResult * this_object = DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceGetAllInstancesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i27;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i27 = 0; i27 < this_object->success->len; i27++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i27))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_get_all_instances_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  DiscoveryServiceGetAllInstancesResult *self = DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_get_all_instances_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  DiscoveryServiceGetAllInstancesResult *self = DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_get_all_instances_result_instance_init (DiscoveryServiceGetAllInstancesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_get_all_instances_result_finalize (GObject *object)
{
  DiscoveryServiceGetAllInstancesResult *tobject = DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_get_all_instances_result_class_init (DiscoveryServiceGetAllInstancesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_get_all_instances_result_read;
  struct_class->write = discovery_service_get_all_instances_result_write;

  gobject_class->finalize = discovery_service_get_all_instances_result_finalize;
  gobject_class->get_property = discovery_service_get_all_instances_result_get_property;
  gobject_class->set_property = discovery_service_get_all_instances_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_ALL_INSTANCES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_get_all_instances_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceGetAllInstancesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_get_all_instances_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceGetAllInstancesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_get_all_instances_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceGetAllInstancesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceGetInstanceArgsProperties
{
  PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_0,
  PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROVIDER_PROJECTION
};

/* reads a discovery_service_get_instance_args object */
static gint32
discovery_service_get_instance_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceGetInstanceArgs * this_object = DISCOVERY_SERVICE_GET_INSTANCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->providerProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_providerProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_get_instance_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceGetInstanceArgs * this_object = DISCOVERY_SERVICE_GET_INSTANCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceGetInstanceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "providerProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->providerProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_get_instance_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  DiscoveryServiceGetInstanceArgs *self = DISCOVERY_SERVICE_GET_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROVIDER_PROJECTION:
      if (self->providerProjection != NULL)
        g_object_unref (self->providerProjection);
      self->providerProjection = g_value_dup_object (value);
      self->__isset_providerProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_get_instance_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  DiscoveryServiceGetInstanceArgs *self = DISCOVERY_SERVICE_GET_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROVIDER_PROJECTION:
      g_value_set_object (value, self->providerProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_get_instance_args_instance_init (DiscoveryServiceGetInstanceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->providerProjection = g_object_new (TYPE_DISCOVERY_PROVIDER_PROJECTION, NULL);
  object->__isset_providerProjection = FALSE;
}

static void 
discovery_service_get_instance_args_finalize (GObject *object)
{
  DiscoveryServiceGetInstanceArgs *tobject = DISCOVERY_SERVICE_GET_INSTANCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->providerProjection != NULL)
  {
    g_object_unref(tobject->providerProjection);
    tobject->providerProjection = NULL;
  }
}

static void
discovery_service_get_instance_args_class_init (DiscoveryServiceGetInstanceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_get_instance_args_read;
  struct_class->write = discovery_service_get_instance_args_write;

  gobject_class->finalize = discovery_service_get_instance_args_finalize;
  gobject_class->get_property = discovery_service_get_instance_args_get_property;
  gobject_class->set_property = discovery_service_get_instance_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_INSTANCE_ARGS_PROVIDER_PROJECTION,
     g_param_spec_object ("providerProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROVIDER_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_get_instance_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceGetInstanceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_get_instance_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceGetInstanceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_get_instance_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceGetInstanceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceGetInstanceResultProperties
{
  PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_0,
  PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_EX1
};

/* reads a discovery_service_get_instance_result object */
static gint32
discovery_service_get_instance_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceGetInstanceResult * this_object = DISCOVERY_SERVICE_GET_INSTANCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_get_instance_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceGetInstanceResult * this_object = DISCOVERY_SERVICE_GET_INSTANCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceGetInstanceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_get_instance_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  DiscoveryServiceGetInstanceResult *self = DISCOVERY_SERVICE_GET_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_get_instance_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  DiscoveryServiceGetInstanceResult *self = DISCOVERY_SERVICE_GET_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_get_instance_result_instance_init (DiscoveryServiceGetInstanceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_get_instance_result_finalize (GObject *object)
{
  DiscoveryServiceGetInstanceResult *tobject = DISCOVERY_SERVICE_GET_INSTANCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_get_instance_result_class_init (DiscoveryServiceGetInstanceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_get_instance_result_read;
  struct_class->write = discovery_service_get_instance_result_write;

  gobject_class->finalize = discovery_service_get_instance_result_finalize;
  gobject_class->get_property = discovery_service_get_instance_result_get_property;
  gobject_class->set_property = discovery_service_get_instance_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_INSTANCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_GET_INSTANCE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_get_instance_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceGetInstanceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_get_instance_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceGetInstanceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_get_instance_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceGetInstanceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceMakeDiscoveryInstanceArgsProperties
{
  PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_0,
  PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_NAME,
  PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PAYLOAD,
  PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PORT
};

/* reads a discovery_service_make_discovery_instance_args object */
static gint32
discovery_service_make_discovery_instance_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceMakeDiscoveryInstanceArgs * this_object = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->payload != NULL)
          {
            g_free(this_object->payload);
            this_object->payload = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->payload = g_byte_array_new();
          g_byte_array_append (this_object->payload, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_payload = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->port, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_make_discovery_instance_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceMakeDiscoveryInstanceArgs * this_object = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceMakeDiscoveryInstanceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "payload", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->payload)->data, ((GByteArray *) this_object->payload)->len, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->port, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_make_discovery_instance_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  DiscoveryServiceMakeDiscoveryInstanceArgs *self = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PAYLOAD:
      if (self->payload != NULL)
        g_byte_array_unref (self->payload);
      self->payload = g_value_dup_boxed (value);
      self->__isset_payload = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PORT:
      self->port = g_value_get_int (value);
      self->__isset_port = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_make_discovery_instance_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  DiscoveryServiceMakeDiscoveryInstanceArgs *self = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PAYLOAD:
      g_value_set_boxed (value, self->payload);
      break;

    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PORT:
      g_value_set_int (value, self->port);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_make_discovery_instance_args_instance_init (DiscoveryServiceMakeDiscoveryInstanceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->payload = NULL;
  object->__isset_payload = FALSE;
  object->port = 0;
  object->__isset_port = FALSE;
}

static void 
discovery_service_make_discovery_instance_args_finalize (GObject *object)
{
  DiscoveryServiceMakeDiscoveryInstanceArgs *tobject = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->payload != NULL)
  {
    thrift_string_free(tobject->payload);
    tobject->payload = NULL;
  }
}

static void
discovery_service_make_discovery_instance_args_class_init (DiscoveryServiceMakeDiscoveryInstanceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_make_discovery_instance_args_read;
  struct_class->write = discovery_service_make_discovery_instance_args_write;

  gobject_class->finalize = discovery_service_make_discovery_instance_args_finalize;
  gobject_class->get_property = discovery_service_make_discovery_instance_args_get_property;
  gobject_class->set_property = discovery_service_make_discovery_instance_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PAYLOAD,
     g_param_spec_boxed ("payload",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_ARGS_PORT,
     g_param_spec_int ("port",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
discovery_service_make_discovery_instance_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceMakeDiscoveryInstanceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_make_discovery_instance_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceMakeDiscoveryInstanceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_make_discovery_instance_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceMakeDiscoveryInstanceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceMakeDiscoveryInstanceResultProperties
{
  PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_0,
  PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_EX1
};

/* reads a discovery_service_make_discovery_instance_result object */
static gint32
discovery_service_make_discovery_instance_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceMakeDiscoveryInstanceResult * this_object = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_make_discovery_instance_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceMakeDiscoveryInstanceResult * this_object = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceMakeDiscoveryInstanceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_make_discovery_instance_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  DiscoveryServiceMakeDiscoveryInstanceResult *self = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_make_discovery_instance_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  DiscoveryServiceMakeDiscoveryInstanceResult *self = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_make_discovery_instance_result_instance_init (DiscoveryServiceMakeDiscoveryInstanceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_make_discovery_instance_result_finalize (GObject *object)
{
  DiscoveryServiceMakeDiscoveryInstanceResult *tobject = DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_make_discovery_instance_result_class_init (DiscoveryServiceMakeDiscoveryInstanceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_make_discovery_instance_result_read;
  struct_class->write = discovery_service_make_discovery_instance_result_write;

  gobject_class->finalize = discovery_service_make_discovery_instance_result_finalize;
  gobject_class->get_property = discovery_service_make_discovery_instance_result_get_property;
  gobject_class->set_property = discovery_service_make_discovery_instance_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_INSTANCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_MAKE_DISCOVERY_INSTANCE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_make_discovery_instance_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceMakeDiscoveryInstanceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_make_discovery_instance_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceMakeDiscoveryInstanceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_make_discovery_instance_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceMakeDiscoveryInstanceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceNoteErrorArgsProperties
{
  PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_0,
  PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROVIDER_PROJECTION,
  PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_INSTANCE_ID
};

/* reads a discovery_service_note_error_args object */
static gint32
discovery_service_note_error_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceNoteErrorArgs * this_object = DISCOVERY_SERVICE_NOTE_ERROR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->providerProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_providerProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->instanceId != NULL)
          {
            g_free(this_object->instanceId);
            this_object->instanceId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->instanceId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_instanceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_note_error_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceNoteErrorArgs * this_object = DISCOVERY_SERVICE_NOTE_ERROR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceNoteErrorArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "providerProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->providerProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "instanceId", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->instanceId, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_note_error_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  DiscoveryServiceNoteErrorArgs *self = DISCOVERY_SERVICE_NOTE_ERROR_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROVIDER_PROJECTION:
      if (self->providerProjection != NULL)
        g_object_unref (self->providerProjection);
      self->providerProjection = g_value_dup_object (value);
      self->__isset_providerProjection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_INSTANCE_ID:
      if (self->instanceId != NULL)
        g_free (self->instanceId);
      self->instanceId = g_value_dup_string (value);
      self->__isset_instanceId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_note_error_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  DiscoveryServiceNoteErrorArgs *self = DISCOVERY_SERVICE_NOTE_ERROR_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROVIDER_PROJECTION:
      g_value_set_object (value, self->providerProjection);
      break;

    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_INSTANCE_ID:
      g_value_set_string (value, self->instanceId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_note_error_args_instance_init (DiscoveryServiceNoteErrorArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->providerProjection = g_object_new (TYPE_DISCOVERY_PROVIDER_PROJECTION, NULL);
  object->__isset_providerProjection = FALSE;
  object->instanceId = NULL;
  object->__isset_instanceId = FALSE;
}

static void 
discovery_service_note_error_args_finalize (GObject *object)
{
  DiscoveryServiceNoteErrorArgs *tobject = DISCOVERY_SERVICE_NOTE_ERROR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->providerProjection != NULL)
  {
    g_object_unref(tobject->providerProjection);
    tobject->providerProjection = NULL;
  }
  if (tobject->instanceId != NULL)
  {
    g_free(tobject->instanceId);
    tobject->instanceId = NULL;
  }
}

static void
discovery_service_note_error_args_class_init (DiscoveryServiceNoteErrorArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_note_error_args_read;
  struct_class->write = discovery_service_note_error_args_write;

  gobject_class->finalize = discovery_service_note_error_args_finalize;
  gobject_class->get_property = discovery_service_note_error_args_get_property;
  gobject_class->set_property = discovery_service_note_error_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_PROVIDER_PROJECTION,
     g_param_spec_object ("providerProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROVIDER_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_NOTE_ERROR_ARGS_INSTANCE_ID,
     g_param_spec_string ("instanceId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
discovery_service_note_error_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceNoteErrorArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_note_error_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceNoteErrorArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_note_error_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceNoteErrorArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceNoteErrorResultProperties
{
  PROP_DISCOVERY_SERVICE_NOTE_ERROR_RESULT_0,
  PROP_DISCOVERY_SERVICE_NOTE_ERROR_RESULT_EX1
};

/* reads a discovery_service_note_error_result object */
static gint32
discovery_service_note_error_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceNoteErrorResult * this_object = DISCOVERY_SERVICE_NOTE_ERROR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_note_error_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceNoteErrorResult * this_object = DISCOVERY_SERVICE_NOTE_ERROR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceNoteErrorResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_note_error_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  DiscoveryServiceNoteErrorResult *self = DISCOVERY_SERVICE_NOTE_ERROR_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_note_error_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  DiscoveryServiceNoteErrorResult *self = DISCOVERY_SERVICE_NOTE_ERROR_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_NOTE_ERROR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_note_error_result_instance_init (DiscoveryServiceNoteErrorResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_note_error_result_finalize (GObject *object)
{
  DiscoveryServiceNoteErrorResult *tobject = DISCOVERY_SERVICE_NOTE_ERROR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_note_error_result_class_init (DiscoveryServiceNoteErrorResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_note_error_result_read;
  struct_class->write = discovery_service_note_error_result_write;

  gobject_class->finalize = discovery_service_note_error_result_finalize;
  gobject_class->get_property = discovery_service_note_error_result_get_property;
  gobject_class->set_property = discovery_service_note_error_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_NOTE_ERROR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_note_error_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceNoteErrorResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_note_error_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceNoteErrorResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_note_error_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceNoteErrorResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceStartDiscoveryArgsProperties
{
  PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_0,
  PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_BASE_PATH,
  PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_YOUR_INSTANCE
};

/* reads a discovery_service_start_discovery_args object */
static gint32
discovery_service_start_discovery_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceStartDiscoveryArgs * this_object = DISCOVERY_SERVICE_START_DISCOVERY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->basePath != NULL)
          {
            g_free(this_object->basePath);
            this_object->basePath = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->basePath, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_basePath = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->yourInstance), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_yourInstance = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_start_discovery_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceStartDiscoveryArgs * this_object = DISCOVERY_SERVICE_START_DISCOVERY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceStartDiscoveryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "basePath", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->basePath, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "yourInstance", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->yourInstance), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_start_discovery_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  DiscoveryServiceStartDiscoveryArgs *self = DISCOVERY_SERVICE_START_DISCOVERY_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_BASE_PATH:
      if (self->basePath != NULL)
        g_free (self->basePath);
      self->basePath = g_value_dup_string (value);
      self->__isset_basePath = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_YOUR_INSTANCE:
      if (self->yourInstance != NULL)
        g_object_unref (self->yourInstance);
      self->yourInstance = g_value_dup_object (value);
      self->__isset_yourInstance = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_start_discovery_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  DiscoveryServiceStartDiscoveryArgs *self = DISCOVERY_SERVICE_START_DISCOVERY_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_BASE_PATH:
      g_value_set_string (value, self->basePath);
      break;

    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_YOUR_INSTANCE:
      g_value_set_object (value, self->yourInstance);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_start_discovery_args_instance_init (DiscoveryServiceStartDiscoveryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->basePath = NULL;
  object->__isset_basePath = FALSE;
  object->yourInstance = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
  object->__isset_yourInstance = FALSE;
}

static void 
discovery_service_start_discovery_args_finalize (GObject *object)
{
  DiscoveryServiceStartDiscoveryArgs *tobject = DISCOVERY_SERVICE_START_DISCOVERY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->basePath != NULL)
  {
    g_free(tobject->basePath);
    tobject->basePath = NULL;
  }
  if (tobject->yourInstance != NULL)
  {
    g_object_unref(tobject->yourInstance);
    tobject->yourInstance = NULL;
  }
}

static void
discovery_service_start_discovery_args_class_init (DiscoveryServiceStartDiscoveryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_start_discovery_args_read;
  struct_class->write = discovery_service_start_discovery_args_write;

  gobject_class->finalize = discovery_service_start_discovery_args_finalize;
  gobject_class->get_property = discovery_service_start_discovery_args_get_property;
  gobject_class->set_property = discovery_service_start_discovery_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_BASE_PATH,
     g_param_spec_string ("basePath",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_DISCOVERY_ARGS_YOUR_INSTANCE,
     g_param_spec_object ("yourInstance",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_INSTANCE,
                         G_PARAM_READWRITE));
}

GType
discovery_service_start_discovery_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceStartDiscoveryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_start_discovery_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceStartDiscoveryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_start_discovery_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceStartDiscoveryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceStartDiscoveryResultProperties
{
  PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_0,
  PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_EX1
};

/* reads a discovery_service_start_discovery_result object */
static gint32
discovery_service_start_discovery_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceStartDiscoveryResult * this_object = DISCOVERY_SERVICE_START_DISCOVERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_start_discovery_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceStartDiscoveryResult * this_object = DISCOVERY_SERVICE_START_DISCOVERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceStartDiscoveryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_start_discovery_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  DiscoveryServiceStartDiscoveryResult *self = DISCOVERY_SERVICE_START_DISCOVERY_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_start_discovery_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  DiscoveryServiceStartDiscoveryResult *self = DISCOVERY_SERVICE_START_DISCOVERY_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_start_discovery_result_instance_init (DiscoveryServiceStartDiscoveryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_start_discovery_result_finalize (GObject *object)
{
  DiscoveryServiceStartDiscoveryResult *tobject = DISCOVERY_SERVICE_START_DISCOVERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_start_discovery_result_class_init (DiscoveryServiceStartDiscoveryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_start_discovery_result_read;
  struct_class->write = discovery_service_start_discovery_result_write;

  gobject_class->finalize = discovery_service_start_discovery_result_finalize;
  gobject_class->get_property = discovery_service_start_discovery_result_get_property;
  gobject_class->set_property = discovery_service_start_discovery_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_DISCOVERY_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_start_discovery_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceStartDiscoveryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_start_discovery_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceStartDiscoveryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_start_discovery_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceStartDiscoveryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceStartProviderArgsProperties
{
  PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_0,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DISCOVERY_PROJECTION,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_SERVICE_NAME,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROVIDER_STRATEGY,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_TIMEOUT_MS,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_ERROR_THRESHOLD
};

/* reads a discovery_service_start_provider_args object */
static gint32
discovery_service_start_provider_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceStartProviderArgs * this_object = DISCOVERY_SERVICE_START_PROVIDER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_discoveryProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->serviceName != NULL)
          {
            g_free(this_object->serviceName);
            this_object->serviceName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->serviceName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_serviceName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast28;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast28, error)) < 0)
            return -1;
          xfer += ret;
          this_object->providerStrategy = (ProviderStrategyType)ecast28;
          this_object->__isset_providerStrategy = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->downTimeoutMs, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_downTimeoutMs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->downErrorThreshold, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_downErrorThreshold = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_start_provider_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceStartProviderArgs * this_object = DISCOVERY_SERVICE_START_PROVIDER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceStartProviderArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "discoveryProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serviceName", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->serviceName, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "providerStrategy", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->providerStrategy, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "downTimeoutMs", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->downTimeoutMs, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "downErrorThreshold", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->downErrorThreshold, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_start_provider_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  DiscoveryServiceStartProviderArgs *self = DISCOVERY_SERVICE_START_PROVIDER_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DISCOVERY_PROJECTION:
      if (self->discoveryProjection != NULL)
        g_object_unref (self->discoveryProjection);
      self->discoveryProjection = g_value_dup_object (value);
      self->__isset_discoveryProjection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_SERVICE_NAME:
      if (self->serviceName != NULL)
        g_free (self->serviceName);
      self->serviceName = g_value_dup_string (value);
      self->__isset_serviceName = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROVIDER_STRATEGY:
      self->providerStrategy = g_value_get_int (value);
      self->__isset_providerStrategy = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_TIMEOUT_MS:
      self->downTimeoutMs = g_value_get_int (value);
      self->__isset_downTimeoutMs = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_ERROR_THRESHOLD:
      self->downErrorThreshold = g_value_get_int (value);
      self->__isset_downErrorThreshold = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_start_provider_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  DiscoveryServiceStartProviderArgs *self = DISCOVERY_SERVICE_START_PROVIDER_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DISCOVERY_PROJECTION:
      g_value_set_object (value, self->discoveryProjection);
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_SERVICE_NAME:
      g_value_set_string (value, self->serviceName);
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROVIDER_STRATEGY:
      g_value_set_int (value, self->providerStrategy);
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_TIMEOUT_MS:
      g_value_set_int (value, self->downTimeoutMs);
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_ERROR_THRESHOLD:
      g_value_set_int (value, self->downErrorThreshold);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_start_provider_args_instance_init (DiscoveryServiceStartProviderArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->discoveryProjection = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_discoveryProjection = FALSE;
  object->serviceName = NULL;
  object->__isset_serviceName = FALSE;
  object->__isset_providerStrategy = FALSE;
  object->downTimeoutMs = 0;
  object->__isset_downTimeoutMs = FALSE;
  object->downErrorThreshold = 0;
  object->__isset_downErrorThreshold = FALSE;
}

static void 
discovery_service_start_provider_args_finalize (GObject *object)
{
  DiscoveryServiceStartProviderArgs *tobject = DISCOVERY_SERVICE_START_PROVIDER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->discoveryProjection != NULL)
  {
    g_object_unref(tobject->discoveryProjection);
    tobject->discoveryProjection = NULL;
  }
  if (tobject->serviceName != NULL)
  {
    g_free(tobject->serviceName);
    tobject->serviceName = NULL;
  }
}

static void
discovery_service_start_provider_args_class_init (DiscoveryServiceStartProviderArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_start_provider_args_read;
  struct_class->write = discovery_service_start_provider_args_write;

  gobject_class->finalize = discovery_service_start_provider_args_finalize;
  gobject_class->get_property = discovery_service_start_provider_args_get_property;
  gobject_class->set_property = discovery_service_start_provider_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DISCOVERY_PROJECTION,
     g_param_spec_object ("discoveryProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_SERVICE_NAME,
     g_param_spec_string ("serviceName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_PROVIDER_STRATEGY,
     g_param_spec_int ("providerStrategy",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_TIMEOUT_MS,
     g_param_spec_int ("downTimeoutMs",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_ARGS_DOWN_ERROR_THRESHOLD,
     g_param_spec_int ("downErrorThreshold",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
discovery_service_start_provider_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceStartProviderArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_start_provider_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceStartProviderArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_start_provider_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceStartProviderArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceStartProviderResultProperties
{
  PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_0,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_EX1
};

/* reads a discovery_service_start_provider_result object */
static gint32
discovery_service_start_provider_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceStartProviderResult * this_object = DISCOVERY_SERVICE_START_PROVIDER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_start_provider_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceStartProviderResult * this_object = DISCOVERY_SERVICE_START_PROVIDER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceStartProviderResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_start_provider_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  DiscoveryServiceStartProviderResult *self = DISCOVERY_SERVICE_START_PROVIDER_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_start_provider_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  DiscoveryServiceStartProviderResult *self = DISCOVERY_SERVICE_START_PROVIDER_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_start_provider_result_instance_init (DiscoveryServiceStartProviderResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DISCOVERY_PROVIDER_PROJECTION, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_start_provider_result_finalize (GObject *object)
{
  DiscoveryServiceStartProviderResult *tobject = DISCOVERY_SERVICE_START_PROVIDER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_start_provider_result_class_init (DiscoveryServiceStartProviderResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_start_provider_result_read;
  struct_class->write = discovery_service_start_provider_result_write;

  gobject_class->finalize = discovery_service_start_provider_result_finalize;
  gobject_class->get_property = discovery_service_start_provider_result_get_property;
  gobject_class->set_property = discovery_service_start_provider_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROVIDER_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_START_PROVIDER_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_start_provider_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceStartProviderResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_start_provider_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceStartProviderResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_start_provider_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceStartProviderResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelQueryForInstanceArgsProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_DISCOVERY_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_NAME,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_ID
};

/* reads a discovery_service_low_level_query_for_instance_args object */
static gint32
discovery_service_low_level_query_for_instance_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelQueryForInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_discoveryProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->id != NULL)
          {
            g_free(this_object->id);
            this_object->id = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_query_for_instance_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelQueryForInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelQueryForInstanceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "discoveryProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_query_for_instance_args_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      if (self->discoveryProjection != NULL)
        g_object_unref (self->discoveryProjection);
      self->discoveryProjection = g_value_dup_object (value);
      self->__isset_discoveryProjection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_ID:
      if (self->id != NULL)
        g_free (self->id);
      self->id = g_value_dup_string (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_query_for_instance_args_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      g_value_set_object (value, self->discoveryProjection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_ID:
      g_value_set_string (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_query_for_instance_args_instance_init (DiscoveryServiceLowLevelQueryForInstanceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->discoveryProjection = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_discoveryProjection = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->id = NULL;
  object->__isset_id = FALSE;
}

static void 
discovery_service_low_level_query_for_instance_args_finalize (GObject *object)
{
  DiscoveryServiceLowLevelQueryForInstanceArgs *tobject = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->discoveryProjection != NULL)
  {
    g_object_unref(tobject->discoveryProjection);
    tobject->discoveryProjection = NULL;
  }
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->id != NULL)
  {
    g_free(tobject->id);
    tobject->id = NULL;
  }
}

static void
discovery_service_low_level_query_for_instance_args_class_init (DiscoveryServiceLowLevelQueryForInstanceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_query_for_instance_args_read;
  struct_class->write = discovery_service_low_level_query_for_instance_args_write;

  gobject_class->finalize = discovery_service_low_level_query_for_instance_args_finalize;
  gobject_class->get_property = discovery_service_low_level_query_for_instance_args_get_property;
  gobject_class->set_property = discovery_service_low_level_query_for_instance_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_DISCOVERY_PROJECTION,
     g_param_spec_object ("discoveryProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_ARGS_ID,
     g_param_spec_string ("id",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
discovery_service_low_level_query_for_instance_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelQueryForInstanceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_query_for_instance_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelQueryForInstanceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_query_for_instance_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelQueryForInstanceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelQueryForInstanceResultProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_EX1
};

/* reads a discovery_service_low_level_query_for_instance_result object */
static gint32
discovery_service_low_level_query_for_instance_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelQueryForInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_query_for_instance_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelQueryForInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelQueryForInstanceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_query_for_instance_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_query_for_instance_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_query_for_instance_result_instance_init (DiscoveryServiceLowLevelQueryForInstanceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_low_level_query_for_instance_result_finalize (GObject *object)
{
  DiscoveryServiceLowLevelQueryForInstanceResult *tobject = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_low_level_query_for_instance_result_class_init (DiscoveryServiceLowLevelQueryForInstanceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_query_for_instance_result_read;
  struct_class->write = discovery_service_low_level_query_for_instance_result_write;

  gobject_class->finalize = discovery_service_low_level_query_for_instance_result_finalize;
  gobject_class->get_property = discovery_service_low_level_query_for_instance_result_get_property;
  gobject_class->set_property = discovery_service_low_level_query_for_instance_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_INSTANCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_query_for_instance_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelQueryForInstanceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_query_for_instance_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelQueryForInstanceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_query_for_instance_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelQueryForInstanceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelQueryForInstancesArgsProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_DISCOVERY_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_NAME
};

/* reads a discovery_service_low_level_query_for_instances_args object */
static gint32
discovery_service_low_level_query_for_instances_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelQueryForInstancesArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_discoveryProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_query_for_instances_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelQueryForInstancesArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelQueryForInstancesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "discoveryProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_query_for_instances_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstancesArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_DISCOVERY_PROJECTION:
      if (self->discoveryProjection != NULL)
        g_object_unref (self->discoveryProjection);
      self->discoveryProjection = g_value_dup_object (value);
      self->__isset_discoveryProjection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_query_for_instances_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstancesArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_DISCOVERY_PROJECTION:
      g_value_set_object (value, self->discoveryProjection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_query_for_instances_args_instance_init (DiscoveryServiceLowLevelQueryForInstancesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->discoveryProjection = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_discoveryProjection = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
}

static void 
discovery_service_low_level_query_for_instances_args_finalize (GObject *object)
{
  DiscoveryServiceLowLevelQueryForInstancesArgs *tobject = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->discoveryProjection != NULL)
  {
    g_object_unref(tobject->discoveryProjection);
    tobject->discoveryProjection = NULL;
  }
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
discovery_service_low_level_query_for_instances_args_class_init (DiscoveryServiceLowLevelQueryForInstancesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_query_for_instances_args_read;
  struct_class->write = discovery_service_low_level_query_for_instances_args_write;

  gobject_class->finalize = discovery_service_low_level_query_for_instances_args_finalize;
  gobject_class->get_property = discovery_service_low_level_query_for_instances_args_get_property;
  gobject_class->set_property = discovery_service_low_level_query_for_instances_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_DISCOVERY_PROJECTION,
     g_param_spec_object ("discoveryProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
discovery_service_low_level_query_for_instances_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelQueryForInstancesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_query_for_instances_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelQueryForInstancesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_query_for_instances_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelQueryForInstancesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelQueryForInstancesResultProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_EX1
};

/* reads a discovery_service_low_level_query_for_instances_result object */
static gint32
discovery_service_low_level_query_for_instances_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelQueryForInstancesResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              DiscoveryInstance * _elem30 = NULL;
              if ( _elem30 != NULL)
              {
                g_object_unref (_elem30);
              }
              _elem30 = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem30), protocol, error)) < 0)
              {
                g_object_unref (_elem30);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem30);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_query_for_instances_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelQueryForInstancesResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelQueryForInstancesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i31;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i31 = 0; i31 < this_object->success->len; i31++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i31))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_query_for_instances_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstancesResult *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_query_for_instances_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForInstancesResult *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_query_for_instances_result_instance_init (DiscoveryServiceLowLevelQueryForInstancesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_low_level_query_for_instances_result_finalize (GObject *object)
{
  DiscoveryServiceLowLevelQueryForInstancesResult *tobject = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_low_level_query_for_instances_result_class_init (DiscoveryServiceLowLevelQueryForInstancesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_query_for_instances_result_read;
  struct_class->write = discovery_service_low_level_query_for_instances_result_write;

  gobject_class->finalize = discovery_service_low_level_query_for_instances_result_finalize;
  gobject_class->get_property = discovery_service_low_level_query_for_instances_result_get_property;
  gobject_class->set_property = discovery_service_low_level_query_for_instances_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_INSTANCES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_query_for_instances_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelQueryForInstancesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_query_for_instances_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelQueryForInstancesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_query_for_instances_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelQueryForInstancesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelQueryForNamesArgsProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_DISCOVERY_PROJECTION
};

/* reads a discovery_service_low_level_query_for_names_args object */
static gint32
discovery_service_low_level_query_for_names_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelQueryForNamesArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_discoveryProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_query_for_names_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelQueryForNamesArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelQueryForNamesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "discoveryProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_query_for_names_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForNamesArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_DISCOVERY_PROJECTION:
      if (self->discoveryProjection != NULL)
        g_object_unref (self->discoveryProjection);
      self->discoveryProjection = g_value_dup_object (value);
      self->__isset_discoveryProjection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_query_for_names_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForNamesArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_DISCOVERY_PROJECTION:
      g_value_set_object (value, self->discoveryProjection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_query_for_names_args_instance_init (DiscoveryServiceLowLevelQueryForNamesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->discoveryProjection = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_discoveryProjection = FALSE;
}

static void 
discovery_service_low_level_query_for_names_args_finalize (GObject *object)
{
  DiscoveryServiceLowLevelQueryForNamesArgs *tobject = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->discoveryProjection != NULL)
  {
    g_object_unref(tobject->discoveryProjection);
    tobject->discoveryProjection = NULL;
  }
}

static void
discovery_service_low_level_query_for_names_args_class_init (DiscoveryServiceLowLevelQueryForNamesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_query_for_names_args_read;
  struct_class->write = discovery_service_low_level_query_for_names_args_write;

  gobject_class->finalize = discovery_service_low_level_query_for_names_args_finalize;
  gobject_class->get_property = discovery_service_low_level_query_for_names_args_get_property;
  gobject_class->set_property = discovery_service_low_level_query_for_names_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_ARGS_DISCOVERY_PROJECTION,
     g_param_spec_object ("discoveryProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_query_for_names_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelQueryForNamesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_query_for_names_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelQueryForNamesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_query_for_names_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelQueryForNamesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelQueryForNamesResultProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_SUCCESS,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_EX1
};

/* reads a discovery_service_low_level_query_for_names_result object */
static gint32
discovery_service_low_level_query_for_names_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelQueryForNamesResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem32 = NULL;
              if (_elem32 != NULL)
              {
                g_free(_elem32);
                _elem32 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem32, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_query_for_names_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelQueryForNamesResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelQueryForNamesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i33;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i33 = 0; i33 < this_object->success->len; i33++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i33)), error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_query_for_names_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForNamesResult *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_query_for_names_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  DiscoveryServiceLowLevelQueryForNamesResult *self = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_query_for_names_result_instance_init (DiscoveryServiceLowLevelQueryForNamesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_low_level_query_for_names_result_finalize (GObject *object)
{
  DiscoveryServiceLowLevelQueryForNamesResult *tobject = DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_low_level_query_for_names_result_class_init (DiscoveryServiceLowLevelQueryForNamesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_query_for_names_result_read;
  struct_class->write = discovery_service_low_level_query_for_names_result_write;

  gobject_class->finalize = discovery_service_low_level_query_for_names_result_finalize;
  gobject_class->get_property = discovery_service_low_level_query_for_names_result_get_property;
  gobject_class->set_property = discovery_service_low_level_query_for_names_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_QUERY_FOR_NAMES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_query_for_names_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelQueryForNamesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_query_for_names_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelQueryForNamesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_query_for_names_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelQueryForNamesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelRegisterInstanceArgsProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_INSTANCE
};

/* reads a discovery_service_low_level_register_instance_args object */
static gint32
discovery_service_low_level_register_instance_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelRegisterInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_discoveryProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->instance), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_instance = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_register_instance_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelRegisterInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelRegisterInstanceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "discoveryProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "instance", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->instance), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_register_instance_args_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  DiscoveryServiceLowLevelRegisterInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      if (self->discoveryProjection != NULL)
        g_object_unref (self->discoveryProjection);
      self->discoveryProjection = g_value_dup_object (value);
      self->__isset_discoveryProjection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_INSTANCE:
      if (self->instance != NULL)
        g_object_unref (self->instance);
      self->instance = g_value_dup_object (value);
      self->__isset_instance = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_register_instance_args_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  DiscoveryServiceLowLevelRegisterInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      g_value_set_object (value, self->discoveryProjection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_INSTANCE:
      g_value_set_object (value, self->instance);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_register_instance_args_instance_init (DiscoveryServiceLowLevelRegisterInstanceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->discoveryProjection = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_discoveryProjection = FALSE;
  object->instance = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
  object->__isset_instance = FALSE;
}

static void 
discovery_service_low_level_register_instance_args_finalize (GObject *object)
{
  DiscoveryServiceLowLevelRegisterInstanceArgs *tobject = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->discoveryProjection != NULL)
  {
    g_object_unref(tobject->discoveryProjection);
    tobject->discoveryProjection = NULL;
  }
  if (tobject->instance != NULL)
  {
    g_object_unref(tobject->instance);
    tobject->instance = NULL;
  }
}

static void
discovery_service_low_level_register_instance_args_class_init (DiscoveryServiceLowLevelRegisterInstanceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_register_instance_args_read;
  struct_class->write = discovery_service_low_level_register_instance_args_write;

  gobject_class->finalize = discovery_service_low_level_register_instance_args_finalize;
  gobject_class->get_property = discovery_service_low_level_register_instance_args_get_property;
  gobject_class->set_property = discovery_service_low_level_register_instance_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION,
     g_param_spec_object ("discoveryProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_ARGS_INSTANCE,
     g_param_spec_object ("instance",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_INSTANCE,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_register_instance_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelRegisterInstanceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_register_instance_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelRegisterInstanceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_register_instance_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelRegisterInstanceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelRegisterInstanceResultProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT_EX1
};

/* reads a discovery_service_low_level_register_instance_result object */
static gint32
discovery_service_low_level_register_instance_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelRegisterInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_register_instance_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelRegisterInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelRegisterInstanceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_register_instance_result_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  DiscoveryServiceLowLevelRegisterInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_register_instance_result_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  DiscoveryServiceLowLevelRegisterInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_register_instance_result_instance_init (DiscoveryServiceLowLevelRegisterInstanceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_low_level_register_instance_result_finalize (GObject *object)
{
  DiscoveryServiceLowLevelRegisterInstanceResult *tobject = DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_low_level_register_instance_result_class_init (DiscoveryServiceLowLevelRegisterInstanceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_register_instance_result_read;
  struct_class->write = discovery_service_low_level_register_instance_result_write;

  gobject_class->finalize = discovery_service_low_level_register_instance_result_finalize;
  gobject_class->get_property = discovery_service_low_level_register_instance_result_get_property;
  gobject_class->set_property = discovery_service_low_level_register_instance_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_REGISTER_INSTANCE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_register_instance_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelRegisterInstanceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_register_instance_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelRegisterInstanceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_register_instance_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelRegisterInstanceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelUnregisterInstanceArgsProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_INSTANCE
};

/* reads a discovery_service_low_level_unregister_instance_args object */
static gint32
discovery_service_low_level_unregister_instance_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelUnregisterInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_discoveryProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->instance), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_instance = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_unregister_instance_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelUnregisterInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelUnregisterInstanceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "discoveryProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "instance", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->instance), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_unregister_instance_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUnregisterInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      if (self->discoveryProjection != NULL)
        g_object_unref (self->discoveryProjection);
      self->discoveryProjection = g_value_dup_object (value);
      self->__isset_discoveryProjection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_INSTANCE:
      if (self->instance != NULL)
        g_object_unref (self->instance);
      self->instance = g_value_dup_object (value);
      self->__isset_instance = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_unregister_instance_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUnregisterInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      g_value_set_object (value, self->discoveryProjection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_INSTANCE:
      g_value_set_object (value, self->instance);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_unregister_instance_args_instance_init (DiscoveryServiceLowLevelUnregisterInstanceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->discoveryProjection = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_discoveryProjection = FALSE;
  object->instance = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
  object->__isset_instance = FALSE;
}

static void 
discovery_service_low_level_unregister_instance_args_finalize (GObject *object)
{
  DiscoveryServiceLowLevelUnregisterInstanceArgs *tobject = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->discoveryProjection != NULL)
  {
    g_object_unref(tobject->discoveryProjection);
    tobject->discoveryProjection = NULL;
  }
  if (tobject->instance != NULL)
  {
    g_object_unref(tobject->instance);
    tobject->instance = NULL;
  }
}

static void
discovery_service_low_level_unregister_instance_args_class_init (DiscoveryServiceLowLevelUnregisterInstanceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_unregister_instance_args_read;
  struct_class->write = discovery_service_low_level_unregister_instance_args_write;

  gobject_class->finalize = discovery_service_low_level_unregister_instance_args_finalize;
  gobject_class->get_property = discovery_service_low_level_unregister_instance_args_get_property;
  gobject_class->set_property = discovery_service_low_level_unregister_instance_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_DISCOVERY_PROJECTION,
     g_param_spec_object ("discoveryProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_ARGS_INSTANCE,
     g_param_spec_object ("instance",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_INSTANCE,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_unregister_instance_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelUnregisterInstanceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_unregister_instance_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelUnregisterInstanceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_unregister_instance_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelUnregisterInstanceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelUnregisterInstanceResultProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT_EX1
};

/* reads a discovery_service_low_level_unregister_instance_result object */
static gint32
discovery_service_low_level_unregister_instance_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelUnregisterInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_unregister_instance_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelUnregisterInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelUnregisterInstanceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_unregister_instance_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUnregisterInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_unregister_instance_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUnregisterInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_unregister_instance_result_instance_init (DiscoveryServiceLowLevelUnregisterInstanceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_low_level_unregister_instance_result_finalize (GObject *object)
{
  DiscoveryServiceLowLevelUnregisterInstanceResult *tobject = DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_low_level_unregister_instance_result_class_init (DiscoveryServiceLowLevelUnregisterInstanceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_unregister_instance_result_read;
  struct_class->write = discovery_service_low_level_unregister_instance_result_write;

  gobject_class->finalize = discovery_service_low_level_unregister_instance_result_finalize;
  gobject_class->get_property = discovery_service_low_level_unregister_instance_result_get_property;
  gobject_class->set_property = discovery_service_low_level_unregister_instance_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UNREGISTER_INSTANCE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_unregister_instance_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelUnregisterInstanceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_unregister_instance_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelUnregisterInstanceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_unregister_instance_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelUnregisterInstanceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelUpdateInstanceArgsProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_DISCOVERY_PROJECTION,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_INSTANCE
};

/* reads a discovery_service_low_level_update_instance_args object */
static gint32
discovery_service_low_level_update_instance_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelUpdateInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_discoveryProjection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->instance), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_instance = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_update_instance_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelUpdateInstanceArgs * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelUpdateInstanceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "discoveryProjection", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->discoveryProjection), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "instance", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->instance), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_update_instance_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUpdateInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      if (self->discoveryProjection != NULL)
        g_object_unref (self->discoveryProjection);
      self->discoveryProjection = g_value_dup_object (value);
      self->__isset_discoveryProjection = TRUE;
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_INSTANCE:
      if (self->instance != NULL)
        g_object_unref (self->instance);
      self->instance = g_value_dup_object (value);
      self->__isset_instance = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_update_instance_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUpdateInstanceArgs *self = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_DISCOVERY_PROJECTION:
      g_value_set_object (value, self->discoveryProjection);
      break;

    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_INSTANCE:
      g_value_set_object (value, self->instance);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_update_instance_args_instance_init (DiscoveryServiceLowLevelUpdateInstanceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->projection = g_object_new (TYPE_CURATOR_PROJECTION, NULL);
  object->__isset_projection = FALSE;
  object->discoveryProjection = g_object_new (TYPE_DISCOVERY_PROJECTION, NULL);
  object->__isset_discoveryProjection = FALSE;
  object->instance = g_object_new (TYPE_DISCOVERY_INSTANCE, NULL);
  object->__isset_instance = FALSE;
}

static void 
discovery_service_low_level_update_instance_args_finalize (GObject *object)
{
  DiscoveryServiceLowLevelUpdateInstanceArgs *tobject = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
  if (tobject->discoveryProjection != NULL)
  {
    g_object_unref(tobject->discoveryProjection);
    tobject->discoveryProjection = NULL;
  }
  if (tobject->instance != NULL)
  {
    g_object_unref(tobject->instance);
    tobject->instance = NULL;
  }
}

static void
discovery_service_low_level_update_instance_args_class_init (DiscoveryServiceLowLevelUpdateInstanceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_update_instance_args_read;
  struct_class->write = discovery_service_low_level_update_instance_args_write;

  gobject_class->finalize = discovery_service_low_level_update_instance_args_finalize;
  gobject_class->get_property = discovery_service_low_level_update_instance_args_get_property;
  gobject_class->set_property = discovery_service_low_level_update_instance_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_CURATOR_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_DISCOVERY_PROJECTION,
     g_param_spec_object ("discoveryProjection",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_PROJECTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_ARGS_INSTANCE,
     g_param_spec_object ("instance",
                         NULL,
                         NULL,
                         TYPE_DISCOVERY_INSTANCE,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_update_instance_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelUpdateInstanceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_update_instance_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelUpdateInstanceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_update_instance_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelUpdateInstanceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DiscoveryServiceLowLevelUpdateInstanceResultProperties
{
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT_0,
  PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT_EX1
};

/* reads a discovery_service_low_level_update_instance_result object */
static gint32
discovery_service_low_level_update_instance_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DiscoveryServiceLowLevelUpdateInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_CURATOR_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
discovery_service_low_level_update_instance_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DiscoveryServiceLowLevelUpdateInstanceResult * this_object = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DiscoveryServiceLowLevelUpdateInstanceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
discovery_service_low_level_update_instance_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUpdateInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
discovery_service_low_level_update_instance_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  DiscoveryServiceLowLevelUpdateInstanceResult *self = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT (object);

  switch (property_id)
  {
    case PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
discovery_service_low_level_update_instance_result_instance_init (DiscoveryServiceLowLevelUpdateInstanceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
discovery_service_low_level_update_instance_result_finalize (GObject *object)
{
  DiscoveryServiceLowLevelUpdateInstanceResult *tobject = DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
discovery_service_low_level_update_instance_result_class_init (DiscoveryServiceLowLevelUpdateInstanceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = discovery_service_low_level_update_instance_result_read;
  struct_class->write = discovery_service_low_level_update_instance_result_write;

  gobject_class->finalize = discovery_service_low_level_update_instance_result_finalize;
  gobject_class->get_property = discovery_service_low_level_update_instance_result_get_property;
  gobject_class->set_property = discovery_service_low_level_update_instance_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DISCOVERY_SERVICE_LOW_LEVEL_UPDATE_INSTANCE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_CURATOR_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
discovery_service_low_level_update_instance_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DiscoveryServiceLowLevelUpdateInstanceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) discovery_service_low_level_update_instance_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DiscoveryServiceLowLevelUpdateInstanceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) discovery_service_low_level_update_instance_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DiscoveryServiceLowLevelUpdateInstanceResultType",
                                   &type_info, 0);
  }

  return type;
}

