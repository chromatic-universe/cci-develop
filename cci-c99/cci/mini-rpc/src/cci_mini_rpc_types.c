/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "cci_mini_rpc_types.h"
#include <thrift/c_glib/thrift.h>

enum _invalid_clang_opProperties
{
  PROP_INVALID_CLANG_OP_0,
  PROP_INVALID_CLANG_OP_WHAT_OP,
  PROP_INVALID_CLANG_OP_WAT
};

/* reads a invalid_clang_op object */
static gint32
invalid_clang_op_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  invalid_clang_op * this_object = INVALID_CLANG_OP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->what_op, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_what_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->wat != NULL)
          {
            g_free(this_object->wat);
            this_object->wat = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->wat, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_wat = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
invalid_clang_op_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  invalid_clang_op * this_object = INVALID_CLANG_OP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "invalid_clang_op", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "what_op", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->what_op, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "wat", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->wat, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
invalid_clang_op_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  invalid_clang_op *self = INVALID_CLANG_OP (object);

  switch (property_id)
  {
    case PROP_INVALID_CLANG_OP_WHAT_OP:
      self->what_op = g_value_get_int (value);
      self->__isset_what_op = TRUE;
      break;

    case PROP_INVALID_CLANG_OP_WAT:
      if (self->wat != NULL)
        g_free (self->wat);
      self->wat = g_value_dup_string (value);
      self->__isset_wat = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
invalid_clang_op_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  invalid_clang_op *self = INVALID_CLANG_OP (object);

  switch (property_id)
  {
    case PROP_INVALID_CLANG_OP_WHAT_OP:
      g_value_set_int (value, self->what_op);
      break;

    case PROP_INVALID_CLANG_OP_WAT:
      g_value_set_string (value, self->wat);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
invalid_clang_op_instance_init (invalid_clang_op * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->what_op = 0;
  object->__isset_what_op = FALSE;
  object->wat = NULL;
  object->__isset_wat = FALSE;
}

static void 
invalid_clang_op_finalize (GObject *object)
{
  invalid_clang_op *tobject = INVALID_CLANG_OP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->wat != NULL)
  {
    g_free(tobject->wat);
    tobject->wat = NULL;
  }
}

static void
invalid_clang_op_class_init (invalid_clang_opClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = invalid_clang_op_read;
  struct_class->write = invalid_clang_op_write;

  gobject_class->finalize = invalid_clang_op_finalize;
  gobject_class->get_property = invalid_clang_op_get_property;
  gobject_class->set_property = invalid_clang_op_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_INVALID_CLANG_OP_WHAT_OP,
     g_param_spec_int ("what_op",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INVALID_CLANG_OP_WAT,
     g_param_spec_string ("wat",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
invalid_clang_op_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (invalid_clang_opClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) invalid_clang_op_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (invalid_clang_op),
      0, /* n_preallocs */
      (GInstanceInitFunc) invalid_clang_op_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "invalid_clang_opType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define INVALID_CLANG_OP_ERROR_DOMAIN "invalid_clang_op_error_quark"
GQuark
invalid_clang_op_error_quark (void)
{
  return g_quark_from_static_string (INVALID_CLANG_OP_ERROR_DOMAIN);
}

/* constants */

enum _cci_mini_clang_rpcPerformDiagArgsProperties
{
  PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS_0,
  PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS_INDEX_MODULE
};

/* reads a cci_mini_clang_rpc_perform_diag_args object */
static gint32
cci_mini_clang_rpc_perform_diag_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  cci_mini_clang_rpcPerformDiagArgs * this_object = CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->index_module != NULL)
          {
            g_free(this_object->index_module);
            this_object->index_module = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->index_module, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_index_module = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
cci_mini_clang_rpc_perform_diag_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  cci_mini_clang_rpcPerformDiagArgs * this_object = CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "cci_mini_clang_rpcPerformDiagArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "index_module", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->index_module, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
cci_mini_clang_rpc_perform_diag_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  cci_mini_clang_rpcPerformDiagArgs *self = CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS (object);

  switch (property_id)
  {
    case PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS_INDEX_MODULE:
      if (self->index_module != NULL)
        g_free (self->index_module);
      self->index_module = g_value_dup_string (value);
      self->__isset_index_module = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
cci_mini_clang_rpc_perform_diag_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  cci_mini_clang_rpcPerformDiagArgs *self = CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS (object);

  switch (property_id)
  {
    case PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS_INDEX_MODULE:
      g_value_set_string (value, self->index_module);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
cci_mini_clang_rpc_perform_diag_args_instance_init (cci_mini_clang_rpcPerformDiagArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->index_module = NULL;
  object->__isset_index_module = FALSE;
}

static void 
cci_mini_clang_rpc_perform_diag_args_finalize (GObject *object)
{
  cci_mini_clang_rpcPerformDiagArgs *tobject = CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->index_module != NULL)
  {
    g_free(tobject->index_module);
    tobject->index_module = NULL;
  }
}

static void
cci_mini_clang_rpc_perform_diag_args_class_init (cci_mini_clang_rpcPerformDiagArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = cci_mini_clang_rpc_perform_diag_args_read;
  struct_class->write = cci_mini_clang_rpc_perform_diag_args_write;

  gobject_class->finalize = cci_mini_clang_rpc_perform_diag_args_finalize;
  gobject_class->get_property = cci_mini_clang_rpc_perform_diag_args_get_property;
  gobject_class->set_property = cci_mini_clang_rpc_perform_diag_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_ARGS_INDEX_MODULE,
     g_param_spec_string ("index_module",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
cci_mini_clang_rpc_perform_diag_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (cci_mini_clang_rpcPerformDiagArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cci_mini_clang_rpc_perform_diag_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (cci_mini_clang_rpcPerformDiagArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) cci_mini_clang_rpc_perform_diag_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "cci_mini_clang_rpcPerformDiagArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _cci_mini_clang_rpcPerformDiagResultProperties
{
  PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT_0,
  PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT_SUCCESS
};

/* reads a cci_mini_clang_rpc_perform_diag_result object */
static gint32
cci_mini_clang_rpc_perform_diag_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  cci_mini_clang_rpcPerformDiagResult * this_object = CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
cci_mini_clang_rpc_perform_diag_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  cci_mini_clang_rpcPerformDiagResult * this_object = CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "cci_mini_clang_rpcPerformDiagResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
cci_mini_clang_rpc_perform_diag_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  cci_mini_clang_rpcPerformDiagResult *self = CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT (object);

  switch (property_id)
  {
    case PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
cci_mini_clang_rpc_perform_diag_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  cci_mini_clang_rpcPerformDiagResult *self = CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT (object);

  switch (property_id)
  {
    case PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
cci_mini_clang_rpc_perform_diag_result_instance_init (cci_mini_clang_rpcPerformDiagResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
cci_mini_clang_rpc_perform_diag_result_finalize (GObject *object)
{
  cci_mini_clang_rpcPerformDiagResult *tobject = CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
cci_mini_clang_rpc_perform_diag_result_class_init (cci_mini_clang_rpcPerformDiagResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = cci_mini_clang_rpc_perform_diag_result_read;
  struct_class->write = cci_mini_clang_rpc_perform_diag_result_write;

  gobject_class->finalize = cci_mini_clang_rpc_perform_diag_result_finalize;
  gobject_class->get_property = cci_mini_clang_rpc_perform_diag_result_get_property;
  gobject_class->set_property = cci_mini_clang_rpc_perform_diag_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CCI_MINI_CLANG_RPC_PERFORM_DIAG_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
cci_mini_clang_rpc_perform_diag_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (cci_mini_clang_rpcPerformDiagResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cci_mini_clang_rpc_perform_diag_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (cci_mini_clang_rpcPerformDiagResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) cci_mini_clang_rpc_perform_diag_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "cci_mini_clang_rpcPerformDiagResultType",
                                   &type_info, 0);
  }

  return type;
}

