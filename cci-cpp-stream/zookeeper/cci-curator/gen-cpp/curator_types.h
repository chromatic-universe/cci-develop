/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef curator_TYPES_H
#define curator_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace shared {

struct PathChildrenCacheStartMode {
  enum type {
    NORMAL = 0,
    BUILD_INITIAL_CACHE = 1,
    POST_INITIALIZED_EVENT = 2
  };
};

extern const std::map<int, const char*> _PathChildrenCacheStartMode_VALUES_TO_NAMES;

struct CreateMode {
  enum type {
    PERSISTENT = 0,
    PERSISTENT_SEQUENTIAL = 1,
    EPHEMERAL = 2,
    EPHEMERAL_SEQUENTIAL = 3,
    CONTAINER = 4
  };
};

extern const std::map<int, const char*> _CreateMode_VALUES_TO_NAMES;

struct CuratorEventType {
  enum type {
    PING = 0,
    CREATE = 1,
    DELETE = 2,
    EXISTS = 3,
    GET_DATA = 4,
    SET_DATA = 5,
    CHILDREN = 6,
    SYNC = 7,
    GET_ACL = 8,
    SET_ACL = 9,
    WATCHED = 10,
    CLOSING = 11,
    CONNECTION_CONNECTED = 12,
    CONNECTION_SUSPENDED = 13,
    CONNECTION_RECONNECTED = 14,
    CONNECTION_LOST = 15,
    CONNECTION_READ_ONLY = 16,
    LEADER = 17,
    PATH_CHILDREN_CACHE = 18,
    NODE_CACHE = 19
  };
};

extern const std::map<int, const char*> _CuratorEventType_VALUES_TO_NAMES;

struct EventType {
  enum type {
    None = 0,
    NodeCreated = 1,
    NodeDeleted = 2,
    NodeDataChanged = 3,
    NodeChildrenChanged = 4
  };
};

extern const std::map<int, const char*> _EventType_VALUES_TO_NAMES;

struct KeeperState {
  enum type {
    Unknown = 0,
    Disconnected = 1,
    NoSyncConnected = 2,
    SyncConnected = 3,
    AuthFailed = 4,
    ConnectedReadOnly = 5,
    SaslAuthenticated = 6,
    Expired = 7
  };
};

extern const std::map<int, const char*> _KeeperState_VALUES_TO_NAMES;

struct PathChildrenCacheEventType {
  enum type {
    CHILD_ADDED = 0,
    CHILD_UPDATED = 1,
    CHILD_REMOVED = 2,
    CONNECTION_SUSPENDED = 3,
    CONNECTION_RECONNECTED = 4,
    CONNECTION_LOST = 5,
    INITIALIZED = 6
  };
};

extern const std::map<int, const char*> _PathChildrenCacheEventType_VALUES_TO_NAMES;

struct PersistentEphemeralNodeMode {
  enum type {
    EPHEMERAL = 0,
    EPHEMERAL_SEQUENTIAL = 1,
    PROTECTED_EPHEMERAL = 2,
    PROTECTED_EPHEMERAL_SEQUENTIAL = 3
  };
};

extern const std::map<int, const char*> _PersistentEphemeralNodeMode_VALUES_TO_NAMES;

struct ExceptionType {
  enum type {
    GENERAL = 0,
    ZOOKEEPER = 1,
    NODE = 2
  };
};

extern const std::map<int, const char*> _ExceptionType_VALUES_TO_NAMES;

struct NodeExceptionType {
  enum type {
    NONODE = 0,
    BADVERSION = 1,
    NODEEXISTS = 2,
    NOTEMPTY = 3
  };
};

extern const std::map<int, const char*> _NodeExceptionType_VALUES_TO_NAMES;

struct ZooKeeperExceptionType {
  enum type {
    SYSTEMERROR = 0,
    RUNTIMEINCONSISTENCY = 1,
    DATAINCONSISTENCY = 2,
    CONNECTIONLOSS = 3,
    MARSHALLINGERROR = 4,
    UNIMPLEMENTED = 5,
    OPERATIONTIMEOUT = 6,
    BADARGUMENTS = 7,
    APIERROR = 8,
    NOAUTH = 9,
    NOCHILDRENFOREPHEMERALS = 10,
    INVALIDACL = 11,
    AUTHFAILED = 12,
    SESSIONEXPIRED = 13,
    INVALIDCALLBACK = 14,
    SESSIONMOVED = 15,
    NOTREADONLY = 16
  };
};

extern const std::map<int, const char*> _ZooKeeperExceptionType_VALUES_TO_NAMES;

struct DiscoveryInstanceType {
  enum type {
    DYNAMIC = 0,
    STATIC = 1,
    PERMANENT = 2
  };
};

extern const std::map<int, const char*> _DiscoveryInstanceType_VALUES_TO_NAMES;

struct ProviderStrategyType {
  enum type {
    RANDOM = 0,
    STICKY_RANDOM = 1,
    STICKY_ROUND_ROBIN = 2,
    ROUND_ROBIN = 3
  };
};

extern const std::map<int, const char*> _ProviderStrategyType_VALUES_TO_NAMES;

class CuratorProjection;

class ExistsSpec;

class GetChildrenSpec;

class GetDataSpec;

class LeaderEvent;

class LeaderProjection;

class LeaderResult;

class LeaseProjection;

class LockProjection;

class NodeCacheProjection;

class OptionalChildrenList;

class OptionalData;

class OptionalLockProjection;

class OptionalPath;

class PathChildrenCacheProjection;

class PersistentEphemeralNodeProjection;

class Id;

class Participant;

class Stat;

class WatchedEvent;

class Version;

class DiscoveryProjection;

class DiscoveryProviderProjection;

class CreateSpec;

class DeleteSpec;

class OptionalStat;

class Acl;

class ChildData;

class PathChildrenCacheEvent;

class SetDataSpec;

class CuratorException;

class DiscoveryInstance;

class CuratorEvent;

typedef struct _CuratorProjection__isset {
  _CuratorProjection__isset() : id(false) {}
  bool id :1;
} _CuratorProjection__isset;

class CuratorProjection {
 public:

  CuratorProjection(const CuratorProjection&);
  CuratorProjection& operator=(const CuratorProjection&);
  CuratorProjection() : id() {
  }

  virtual ~CuratorProjection() throw();
  std::string id;

  _CuratorProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const CuratorProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const CuratorProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CuratorProjection &a, CuratorProjection &b);

inline std::ostream& operator<<(std::ostream& out, const CuratorProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ExistsSpec__isset {
  _ExistsSpec__isset() : path(false), watched(false), asyncContext(false) {}
  bool path :1;
  bool watched :1;
  bool asyncContext :1;
} _ExistsSpec__isset;

class ExistsSpec {
 public:

  ExistsSpec(const ExistsSpec&);
  ExistsSpec& operator=(const ExistsSpec&);
  ExistsSpec() : path(), watched(0), asyncContext() {
  }

  virtual ~ExistsSpec() throw();
  std::string path;
  bool watched;
  std::string asyncContext;

  _ExistsSpec__isset __isset;

  void __set_path(const std::string& val);

  void __set_watched(const bool val);

  void __set_asyncContext(const std::string& val);

  bool operator == (const ExistsSpec & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(watched == rhs.watched))
      return false;
    if (!(asyncContext == rhs.asyncContext))
      return false;
    return true;
  }
  bool operator != (const ExistsSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExistsSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ExistsSpec &a, ExistsSpec &b);

inline std::ostream& operator<<(std::ostream& out, const ExistsSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetChildrenSpec__isset {
  _GetChildrenSpec__isset() : path(false), watched(false), asyncContext(false) {}
  bool path :1;
  bool watched :1;
  bool asyncContext :1;
} _GetChildrenSpec__isset;

class GetChildrenSpec {
 public:

  GetChildrenSpec(const GetChildrenSpec&);
  GetChildrenSpec& operator=(const GetChildrenSpec&);
  GetChildrenSpec() : path(), watched(0), asyncContext() {
  }

  virtual ~GetChildrenSpec() throw();
  std::string path;
  bool watched;
  std::string asyncContext;

  _GetChildrenSpec__isset __isset;

  void __set_path(const std::string& val);

  void __set_watched(const bool val);

  void __set_asyncContext(const std::string& val);

  bool operator == (const GetChildrenSpec & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(watched == rhs.watched))
      return false;
    if (!(asyncContext == rhs.asyncContext))
      return false;
    return true;
  }
  bool operator != (const GetChildrenSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetChildrenSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetChildrenSpec &a, GetChildrenSpec &b);

inline std::ostream& operator<<(std::ostream& out, const GetChildrenSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetDataSpec__isset {
  _GetDataSpec__isset() : path(false), watched(false), asyncContext(false), decompressed(false) {}
  bool path :1;
  bool watched :1;
  bool asyncContext :1;
  bool decompressed :1;
} _GetDataSpec__isset;

class GetDataSpec {
 public:

  GetDataSpec(const GetDataSpec&);
  GetDataSpec& operator=(const GetDataSpec&);
  GetDataSpec() : path(), watched(0), asyncContext(), decompressed(0) {
  }

  virtual ~GetDataSpec() throw();
  std::string path;
  bool watched;
  std::string asyncContext;
  bool decompressed;

  _GetDataSpec__isset __isset;

  void __set_path(const std::string& val);

  void __set_watched(const bool val);

  void __set_asyncContext(const std::string& val);

  void __set_decompressed(const bool val);

  bool operator == (const GetDataSpec & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(watched == rhs.watched))
      return false;
    if (!(asyncContext == rhs.asyncContext))
      return false;
    if (!(decompressed == rhs.decompressed))
      return false;
    return true;
  }
  bool operator != (const GetDataSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetDataSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetDataSpec &a, GetDataSpec &b);

inline std::ostream& operator<<(std::ostream& out, const GetDataSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LeaderEvent__isset {
  _LeaderEvent__isset() : path(false), participantId(false), isLeader(false) {}
  bool path :1;
  bool participantId :1;
  bool isLeader :1;
} _LeaderEvent__isset;

class LeaderEvent {
 public:

  LeaderEvent(const LeaderEvent&);
  LeaderEvent& operator=(const LeaderEvent&);
  LeaderEvent() : path(), participantId(), isLeader(0) {
  }

  virtual ~LeaderEvent() throw();
  std::string path;
  std::string participantId;
  bool isLeader;

  _LeaderEvent__isset __isset;

  void __set_path(const std::string& val);

  void __set_participantId(const std::string& val);

  void __set_isLeader(const bool val);

  bool operator == (const LeaderEvent & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(participantId == rhs.participantId))
      return false;
    if (!(isLeader == rhs.isLeader))
      return false;
    return true;
  }
  bool operator != (const LeaderEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LeaderEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LeaderEvent &a, LeaderEvent &b);

inline std::ostream& operator<<(std::ostream& out, const LeaderEvent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LeaderProjection__isset {
  _LeaderProjection__isset() : id(false) {}
  bool id :1;
} _LeaderProjection__isset;

class LeaderProjection {
 public:

  LeaderProjection(const LeaderProjection&);
  LeaderProjection& operator=(const LeaderProjection&);
  LeaderProjection() : id() {
  }

  virtual ~LeaderProjection() throw();
  std::string id;

  _LeaderProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const LeaderProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const LeaderProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LeaderProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LeaderProjection &a, LeaderProjection &b);

inline std::ostream& operator<<(std::ostream& out, const LeaderProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LeaderResult__isset {
  _LeaderResult__isset() : projection(false), isLeader(false) {}
  bool projection :1;
  bool isLeader :1;
} _LeaderResult__isset;

class LeaderResult {
 public:

  LeaderResult(const LeaderResult&);
  LeaderResult& operator=(const LeaderResult&);
  LeaderResult() : isLeader(0) {
  }

  virtual ~LeaderResult() throw();
  LeaderProjection projection;
  bool isLeader;

  _LeaderResult__isset __isset;

  void __set_projection(const LeaderProjection& val);

  void __set_isLeader(const bool val);

  bool operator == (const LeaderResult & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(isLeader == rhs.isLeader))
      return false;
    return true;
  }
  bool operator != (const LeaderResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LeaderResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LeaderResult &a, LeaderResult &b);

inline std::ostream& operator<<(std::ostream& out, const LeaderResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LeaseProjection__isset {
  _LeaseProjection__isset() : id(false) {}
  bool id :1;
} _LeaseProjection__isset;

class LeaseProjection {
 public:

  LeaseProjection(const LeaseProjection&);
  LeaseProjection& operator=(const LeaseProjection&);
  LeaseProjection() : id() {
  }

  virtual ~LeaseProjection() throw();
  std::string id;

  _LeaseProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const LeaseProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const LeaseProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LeaseProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LeaseProjection &a, LeaseProjection &b);

inline std::ostream& operator<<(std::ostream& out, const LeaseProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LockProjection__isset {
  _LockProjection__isset() : id(false) {}
  bool id :1;
} _LockProjection__isset;

class LockProjection {
 public:

  LockProjection(const LockProjection&);
  LockProjection& operator=(const LockProjection&);
  LockProjection() : id() {
  }

  virtual ~LockProjection() throw();
  std::string id;

  _LockProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const LockProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const LockProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LockProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LockProjection &a, LockProjection &b);

inline std::ostream& operator<<(std::ostream& out, const LockProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NodeCacheProjection__isset {
  _NodeCacheProjection__isset() : id(false) {}
  bool id :1;
} _NodeCacheProjection__isset;

class NodeCacheProjection {
 public:

  NodeCacheProjection(const NodeCacheProjection&);
  NodeCacheProjection& operator=(const NodeCacheProjection&);
  NodeCacheProjection() : id() {
  }

  virtual ~NodeCacheProjection() throw();
  std::string id;

  _NodeCacheProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const NodeCacheProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const NodeCacheProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeCacheProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NodeCacheProjection &a, NodeCacheProjection &b);

inline std::ostream& operator<<(std::ostream& out, const NodeCacheProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _OptionalChildrenList__isset {
  _OptionalChildrenList__isset() : children(false) {}
  bool children :1;
} _OptionalChildrenList__isset;

class OptionalChildrenList {
 public:

  OptionalChildrenList(const OptionalChildrenList&);
  OptionalChildrenList& operator=(const OptionalChildrenList&);
  OptionalChildrenList() {
  }

  virtual ~OptionalChildrenList() throw();
  std::vector<std::string>  children;

  _OptionalChildrenList__isset __isset;

  void __set_children(const std::vector<std::string> & val);

  bool operator == (const OptionalChildrenList & rhs) const
  {
    if (!(children == rhs.children))
      return false;
    return true;
  }
  bool operator != (const OptionalChildrenList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OptionalChildrenList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OptionalChildrenList &a, OptionalChildrenList &b);

inline std::ostream& operator<<(std::ostream& out, const OptionalChildrenList& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _OptionalData__isset {
  _OptionalData__isset() : data(false) {}
  bool data :1;
} _OptionalData__isset;

class OptionalData {
 public:

  OptionalData(const OptionalData&);
  OptionalData& operator=(const OptionalData&);
  OptionalData() : data() {
  }

  virtual ~OptionalData() throw();
  std::string data;

  _OptionalData__isset __isset;

  void __set_data(const std::string& val);

  bool operator == (const OptionalData & rhs) const
  {
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const OptionalData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OptionalData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OptionalData &a, OptionalData &b);

inline std::ostream& operator<<(std::ostream& out, const OptionalData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _OptionalLockProjection__isset {
  _OptionalLockProjection__isset() : lockProjection(false) {}
  bool lockProjection :1;
} _OptionalLockProjection__isset;

class OptionalLockProjection {
 public:

  OptionalLockProjection(const OptionalLockProjection&);
  OptionalLockProjection& operator=(const OptionalLockProjection&);
  OptionalLockProjection() {
  }

  virtual ~OptionalLockProjection() throw();
  LockProjection lockProjection;

  _OptionalLockProjection__isset __isset;

  void __set_lockProjection(const LockProjection& val);

  bool operator == (const OptionalLockProjection & rhs) const
  {
    if (!(lockProjection == rhs.lockProjection))
      return false;
    return true;
  }
  bool operator != (const OptionalLockProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OptionalLockProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OptionalLockProjection &a, OptionalLockProjection &b);

inline std::ostream& operator<<(std::ostream& out, const OptionalLockProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _OptionalPath__isset {
  _OptionalPath__isset() : path(false) {}
  bool path :1;
} _OptionalPath__isset;

class OptionalPath {
 public:

  OptionalPath(const OptionalPath&);
  OptionalPath& operator=(const OptionalPath&);
  OptionalPath() : path() {
  }

  virtual ~OptionalPath() throw();
  std::string path;

  _OptionalPath__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const OptionalPath & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const OptionalPath &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OptionalPath & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OptionalPath &a, OptionalPath &b);

inline std::ostream& operator<<(std::ostream& out, const OptionalPath& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PathChildrenCacheProjection__isset {
  _PathChildrenCacheProjection__isset() : id(false) {}
  bool id :1;
} _PathChildrenCacheProjection__isset;

class PathChildrenCacheProjection {
 public:

  PathChildrenCacheProjection(const PathChildrenCacheProjection&);
  PathChildrenCacheProjection& operator=(const PathChildrenCacheProjection&);
  PathChildrenCacheProjection() : id() {
  }

  virtual ~PathChildrenCacheProjection() throw();
  std::string id;

  _PathChildrenCacheProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const PathChildrenCacheProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const PathChildrenCacheProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PathChildrenCacheProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PathChildrenCacheProjection &a, PathChildrenCacheProjection &b);

inline std::ostream& operator<<(std::ostream& out, const PathChildrenCacheProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PersistentEphemeralNodeProjection__isset {
  _PersistentEphemeralNodeProjection__isset() : id(false) {}
  bool id :1;
} _PersistentEphemeralNodeProjection__isset;

class PersistentEphemeralNodeProjection {
 public:

  PersistentEphemeralNodeProjection(const PersistentEphemeralNodeProjection&);
  PersistentEphemeralNodeProjection& operator=(const PersistentEphemeralNodeProjection&);
  PersistentEphemeralNodeProjection() : id() {
  }

  virtual ~PersistentEphemeralNodeProjection() throw();
  std::string id;

  _PersistentEphemeralNodeProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const PersistentEphemeralNodeProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const PersistentEphemeralNodeProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PersistentEphemeralNodeProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PersistentEphemeralNodeProjection &a, PersistentEphemeralNodeProjection &b);

inline std::ostream& operator<<(std::ostream& out, const PersistentEphemeralNodeProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Id__isset {
  _Id__isset() : scheme(false), id(false) {}
  bool scheme :1;
  bool id :1;
} _Id__isset;

class Id {
 public:

  Id(const Id&);
  Id& operator=(const Id&);
  Id() : scheme(), id() {
  }

  virtual ~Id() throw();
  std::string scheme;
  std::string id;

  _Id__isset __isset;

  void __set_scheme(const std::string& val);

  void __set_id(const std::string& val);

  bool operator == (const Id & rhs) const
  {
    if (!(scheme == rhs.scheme))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Id &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Id & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Id &a, Id &b);

inline std::ostream& operator<<(std::ostream& out, const Id& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Participant__isset {
  _Participant__isset() : id(false), isLeader(false) {}
  bool id :1;
  bool isLeader :1;
} _Participant__isset;

class Participant {
 public:

  Participant(const Participant&);
  Participant& operator=(const Participant&);
  Participant() : id(), isLeader(0) {
  }

  virtual ~Participant() throw();
  std::string id;
  bool isLeader;

  _Participant__isset __isset;

  void __set_id(const std::string& val);

  void __set_isLeader(const bool val);

  bool operator == (const Participant & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(isLeader == rhs.isLeader))
      return false;
    return true;
  }
  bool operator != (const Participant &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Participant & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Participant &a, Participant &b);

inline std::ostream& operator<<(std::ostream& out, const Participant& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Stat__isset {
  _Stat__isset() : czxid(false), mzxid(false), ctime(false), mtime(false), version(false), cversion(false), aversion(false), ephemeralOwner(false), dataLength(false), numChildren(false), pzxid(false) {}
  bool czxid :1;
  bool mzxid :1;
  bool ctime :1;
  bool mtime :1;
  bool version :1;
  bool cversion :1;
  bool aversion :1;
  bool ephemeralOwner :1;
  bool dataLength :1;
  bool numChildren :1;
  bool pzxid :1;
} _Stat__isset;

class Stat {
 public:

  Stat(const Stat&);
  Stat& operator=(const Stat&);
  Stat() : czxid(0), mzxid(0), ctime(0), mtime(0), version(0), cversion(0), aversion(0), ephemeralOwner(0), dataLength(0), numChildren(0), pzxid(0) {
  }

  virtual ~Stat() throw();
  int64_t czxid;
  int64_t mzxid;
  int64_t ctime;
  int64_t mtime;
  int32_t version;
  int32_t cversion;
  int32_t aversion;
  int64_t ephemeralOwner;
  int32_t dataLength;
  int32_t numChildren;
  int64_t pzxid;

  _Stat__isset __isset;

  void __set_czxid(const int64_t val);

  void __set_mzxid(const int64_t val);

  void __set_ctime(const int64_t val);

  void __set_mtime(const int64_t val);

  void __set_version(const int32_t val);

  void __set_cversion(const int32_t val);

  void __set_aversion(const int32_t val);

  void __set_ephemeralOwner(const int64_t val);

  void __set_dataLength(const int32_t val);

  void __set_numChildren(const int32_t val);

  void __set_pzxid(const int64_t val);

  bool operator == (const Stat & rhs) const
  {
    if (!(czxid == rhs.czxid))
      return false;
    if (!(mzxid == rhs.mzxid))
      return false;
    if (!(ctime == rhs.ctime))
      return false;
    if (!(mtime == rhs.mtime))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(cversion == rhs.cversion))
      return false;
    if (!(aversion == rhs.aversion))
      return false;
    if (!(ephemeralOwner == rhs.ephemeralOwner))
      return false;
    if (!(dataLength == rhs.dataLength))
      return false;
    if (!(numChildren == rhs.numChildren))
      return false;
    if (!(pzxid == rhs.pzxid))
      return false;
    return true;
  }
  bool operator != (const Stat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Stat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Stat &a, Stat &b);

inline std::ostream& operator<<(std::ostream& out, const Stat& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WatchedEvent__isset {
  _WatchedEvent__isset() : keeperState(false), eventType(false), path(false) {}
  bool keeperState :1;
  bool eventType :1;
  bool path :1;
} _WatchedEvent__isset;

class WatchedEvent {
 public:

  WatchedEvent(const WatchedEvent&);
  WatchedEvent& operator=(const WatchedEvent&);
  WatchedEvent() : keeperState((KeeperState::type)0), eventType((EventType::type)0), path() {
  }

  virtual ~WatchedEvent() throw();
  KeeperState::type keeperState;
  EventType::type eventType;
  std::string path;

  _WatchedEvent__isset __isset;

  void __set_keeperState(const KeeperState::type val);

  void __set_eventType(const EventType::type val);

  void __set_path(const std::string& val);

  bool operator == (const WatchedEvent & rhs) const
  {
    if (!(keeperState == rhs.keeperState))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const WatchedEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WatchedEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WatchedEvent &a, WatchedEvent &b);

inline std::ostream& operator<<(std::ostream& out, const WatchedEvent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Version__isset {
  _Version__isset() : version(false) {}
  bool version :1;
} _Version__isset;

class Version {
 public:

  Version(const Version&);
  Version& operator=(const Version&);
  Version() : version(0) {
  }

  virtual ~Version() throw();
  int32_t version;

  _Version__isset __isset;

  void __set_version(const int32_t val);

  bool operator == (const Version & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const Version &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Version & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Version &a, Version &b);

inline std::ostream& operator<<(std::ostream& out, const Version& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DiscoveryProjection__isset {
  _DiscoveryProjection__isset() : id(false) {}
  bool id :1;
} _DiscoveryProjection__isset;

class DiscoveryProjection {
 public:

  DiscoveryProjection(const DiscoveryProjection&);
  DiscoveryProjection& operator=(const DiscoveryProjection&);
  DiscoveryProjection() : id() {
  }

  virtual ~DiscoveryProjection() throw();
  std::string id;

  _DiscoveryProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const DiscoveryProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const DiscoveryProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DiscoveryProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DiscoveryProjection &a, DiscoveryProjection &b);

inline std::ostream& operator<<(std::ostream& out, const DiscoveryProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DiscoveryProviderProjection__isset {
  _DiscoveryProviderProjection__isset() : id(false) {}
  bool id :1;
} _DiscoveryProviderProjection__isset;

class DiscoveryProviderProjection {
 public:

  DiscoveryProviderProjection(const DiscoveryProviderProjection&);
  DiscoveryProviderProjection& operator=(const DiscoveryProviderProjection&);
  DiscoveryProviderProjection() : id() {
  }

  virtual ~DiscoveryProviderProjection() throw();
  std::string id;

  _DiscoveryProviderProjection__isset __isset;

  void __set_id(const std::string& val);

  bool operator == (const DiscoveryProviderProjection & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const DiscoveryProviderProjection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DiscoveryProviderProjection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DiscoveryProviderProjection &a, DiscoveryProviderProjection &b);

inline std::ostream& operator<<(std::ostream& out, const DiscoveryProviderProjection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CreateSpec__isset {
  _CreateSpec__isset() : path(false), data(false), mode(false), asyncContext(false), compressed(false), creatingParentsIfNeeded(false), withProtection(false), creatingParentContainersIfNeeded(false) {}
  bool path :1;
  bool data :1;
  bool mode :1;
  bool asyncContext :1;
  bool compressed :1;
  bool creatingParentsIfNeeded :1;
  bool withProtection :1;
  bool creatingParentContainersIfNeeded :1;
} _CreateSpec__isset;

class CreateSpec {
 public:

  CreateSpec(const CreateSpec&);
  CreateSpec& operator=(const CreateSpec&);
  CreateSpec() : path(), data(), mode((CreateMode::type)0), asyncContext(), compressed(0), creatingParentsIfNeeded(0), withProtection(0), creatingParentContainersIfNeeded(0) {
  }

  virtual ~CreateSpec() throw();
  std::string path;
  std::string data;
  CreateMode::type mode;
  std::string asyncContext;
  bool compressed;
  bool creatingParentsIfNeeded;
  bool withProtection;
  bool creatingParentContainersIfNeeded;

  _CreateSpec__isset __isset;

  void __set_path(const std::string& val);

  void __set_data(const std::string& val);

  void __set_mode(const CreateMode::type val);

  void __set_asyncContext(const std::string& val);

  void __set_compressed(const bool val);

  void __set_creatingParentsIfNeeded(const bool val);

  void __set_withProtection(const bool val);

  void __set_creatingParentContainersIfNeeded(const bool val);

  bool operator == (const CreateSpec & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(mode == rhs.mode))
      return false;
    if (!(asyncContext == rhs.asyncContext))
      return false;
    if (!(compressed == rhs.compressed))
      return false;
    if (!(creatingParentsIfNeeded == rhs.creatingParentsIfNeeded))
      return false;
    if (!(withProtection == rhs.withProtection))
      return false;
    if (!(creatingParentContainersIfNeeded == rhs.creatingParentContainersIfNeeded))
      return false;
    return true;
  }
  bool operator != (const CreateSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateSpec &a, CreateSpec &b);

inline std::ostream& operator<<(std::ostream& out, const CreateSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DeleteSpec__isset {
  _DeleteSpec__isset() : path(false), guaranteed(false), asyncContext(false), version(false) {}
  bool path :1;
  bool guaranteed :1;
  bool asyncContext :1;
  bool version :1;
} _DeleteSpec__isset;

class DeleteSpec {
 public:

  DeleteSpec(const DeleteSpec&);
  DeleteSpec& operator=(const DeleteSpec&);
  DeleteSpec() : path(), guaranteed(0), asyncContext() {
  }

  virtual ~DeleteSpec() throw();
  std::string path;
  bool guaranteed;
  std::string asyncContext;
  Version version;

  _DeleteSpec__isset __isset;

  void __set_path(const std::string& val);

  void __set_guaranteed(const bool val);

  void __set_asyncContext(const std::string& val);

  void __set_version(const Version& val);

  bool operator == (const DeleteSpec & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(guaranteed == rhs.guaranteed))
      return false;
    if (!(asyncContext == rhs.asyncContext))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const DeleteSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeleteSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DeleteSpec &a, DeleteSpec &b);

inline std::ostream& operator<<(std::ostream& out, const DeleteSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _OptionalStat__isset {
  _OptionalStat__isset() : stat(false) {}
  bool stat :1;
} _OptionalStat__isset;

class OptionalStat {
 public:

  OptionalStat(const OptionalStat&);
  OptionalStat& operator=(const OptionalStat&);
  OptionalStat() {
  }

  virtual ~OptionalStat() throw();
  Stat stat;

  _OptionalStat__isset __isset;

  void __set_stat(const Stat& val);

  bool operator == (const OptionalStat & rhs) const
  {
    if (!(stat == rhs.stat))
      return false;
    return true;
  }
  bool operator != (const OptionalStat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OptionalStat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OptionalStat &a, OptionalStat &b);

inline std::ostream& operator<<(std::ostream& out, const OptionalStat& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Acl__isset {
  _Acl__isset() : perms(false), id(false) {}
  bool perms :1;
  bool id :1;
} _Acl__isset;

class Acl {
 public:

  Acl(const Acl&);
  Acl& operator=(const Acl&);
  Acl() : perms(0) {
  }

  virtual ~Acl() throw();
  int32_t perms;
  Id id;

  _Acl__isset __isset;

  void __set_perms(const int32_t val);

  void __set_id(const Id& val);

  bool operator == (const Acl & rhs) const
  {
    if (!(perms == rhs.perms))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Acl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Acl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Acl &a, Acl &b);

inline std::ostream& operator<<(std::ostream& out, const Acl& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ChildData__isset {
  _ChildData__isset() : path(false), stat(false), data(false) {}
  bool path :1;
  bool stat :1;
  bool data :1;
} _ChildData__isset;

class ChildData {
 public:

  ChildData(const ChildData&);
  ChildData& operator=(const ChildData&);
  ChildData() : path(), data() {
  }

  virtual ~ChildData() throw();
  std::string path;
  Stat stat;
  std::string data;

  _ChildData__isset __isset;

  void __set_path(const std::string& val);

  void __set_stat(const Stat& val);

  void __set_data(const std::string& val);

  bool operator == (const ChildData & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(stat == rhs.stat))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const ChildData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChildData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ChildData &a, ChildData &b);

inline std::ostream& operator<<(std::ostream& out, const ChildData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PathChildrenCacheEvent__isset {
  _PathChildrenCacheEvent__isset() : cachedPath(false), type(false), data(false) {}
  bool cachedPath :1;
  bool type :1;
  bool data :1;
} _PathChildrenCacheEvent__isset;

class PathChildrenCacheEvent {
 public:

  PathChildrenCacheEvent(const PathChildrenCacheEvent&);
  PathChildrenCacheEvent& operator=(const PathChildrenCacheEvent&);
  PathChildrenCacheEvent() : cachedPath(), type((PathChildrenCacheEventType::type)0) {
  }

  virtual ~PathChildrenCacheEvent() throw();
  std::string cachedPath;
  PathChildrenCacheEventType::type type;
  ChildData data;

  _PathChildrenCacheEvent__isset __isset;

  void __set_cachedPath(const std::string& val);

  void __set_type(const PathChildrenCacheEventType::type val);

  void __set_data(const ChildData& val);

  bool operator == (const PathChildrenCacheEvent & rhs) const
  {
    if (!(cachedPath == rhs.cachedPath))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const PathChildrenCacheEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PathChildrenCacheEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PathChildrenCacheEvent &a, PathChildrenCacheEvent &b);

inline std::ostream& operator<<(std::ostream& out, const PathChildrenCacheEvent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SetDataSpec__isset {
  _SetDataSpec__isset() : path(false), watched(false), asyncContext(false), compressed(false), version(false), data(false) {}
  bool path :1;
  bool watched :1;
  bool asyncContext :1;
  bool compressed :1;
  bool version :1;
  bool data :1;
} _SetDataSpec__isset;

class SetDataSpec {
 public:

  SetDataSpec(const SetDataSpec&);
  SetDataSpec& operator=(const SetDataSpec&);
  SetDataSpec() : path(), watched(0), asyncContext(), compressed(0), data() {
  }

  virtual ~SetDataSpec() throw();
  std::string path;
  bool watched;
  std::string asyncContext;
  bool compressed;
  Version version;
  std::string data;

  _SetDataSpec__isset __isset;

  void __set_path(const std::string& val);

  void __set_watched(const bool val);

  void __set_asyncContext(const std::string& val);

  void __set_compressed(const bool val);

  void __set_version(const Version& val);

  void __set_data(const std::string& val);

  bool operator == (const SetDataSpec & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(watched == rhs.watched))
      return false;
    if (!(asyncContext == rhs.asyncContext))
      return false;
    if (!(compressed == rhs.compressed))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const SetDataSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetDataSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetDataSpec &a, SetDataSpec &b);

inline std::ostream& operator<<(std::ostream& out, const SetDataSpec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CuratorException__isset {
  _CuratorException__isset() : type(false), zooKeeperException(false), nodeException(false), message(false) {}
  bool type :1;
  bool zooKeeperException :1;
  bool nodeException :1;
  bool message :1;
} _CuratorException__isset;

class CuratorException : public ::apache::thrift::TException {
 public:

  CuratorException(const CuratorException&);
  CuratorException& operator=(const CuratorException&);
  CuratorException() : type((ExceptionType::type)0), zooKeeperException((ZooKeeperExceptionType::type)0), nodeException((NodeExceptionType::type)0), message() {
  }

  virtual ~CuratorException() throw();
  ExceptionType::type type;
  ZooKeeperExceptionType::type zooKeeperException;
  NodeExceptionType::type nodeException;
  std::string message;

  _CuratorException__isset __isset;

  void __set_type(const ExceptionType::type val);

  void __set_zooKeeperException(const ZooKeeperExceptionType::type val);

  void __set_nodeException(const NodeExceptionType::type val);

  void __set_message(const std::string& val);

  bool operator == (const CuratorException & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(zooKeeperException == rhs.zooKeeperException))
      return false;
    if (!(nodeException == rhs.nodeException))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const CuratorException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(CuratorException &a, CuratorException &b);

inline std::ostream& operator<<(std::ostream& out, const CuratorException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DiscoveryInstance__isset {
  _DiscoveryInstance__isset() : name(false), id(false), address(false), port(false), sslPort(false), payload(false), registrationTimeUTC(false), serviceType(false), uriSpec(false) {}
  bool name :1;
  bool id :1;
  bool address :1;
  bool port :1;
  bool sslPort :1;
  bool payload :1;
  bool registrationTimeUTC :1;
  bool serviceType :1;
  bool uriSpec :1;
} _DiscoveryInstance__isset;

class DiscoveryInstance {
 public:

  DiscoveryInstance(const DiscoveryInstance&);
  DiscoveryInstance& operator=(const DiscoveryInstance&);
  DiscoveryInstance() : name(), id(), address(), port(0), sslPort(0), payload(), registrationTimeUTC(0), serviceType((DiscoveryInstanceType::type)0), uriSpec() {
  }

  virtual ~DiscoveryInstance() throw();
  std::string name;
  std::string id;
  std::string address;
  int32_t port;
  int32_t sslPort;
  std::string payload;
  int64_t registrationTimeUTC;
  DiscoveryInstanceType::type serviceType;
  std::string uriSpec;

  _DiscoveryInstance__isset __isset;

  void __set_name(const std::string& val);

  void __set_id(const std::string& val);

  void __set_address(const std::string& val);

  void __set_port(const int32_t val);

  void __set_sslPort(const int32_t val);

  void __set_payload(const std::string& val);

  void __set_registrationTimeUTC(const int64_t val);

  void __set_serviceType(const DiscoveryInstanceType::type val);

  void __set_uriSpec(const std::string& val);

  bool operator == (const DiscoveryInstance & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(sslPort == rhs.sslPort))
      return false;
    if (!(payload == rhs.payload))
      return false;
    if (!(registrationTimeUTC == rhs.registrationTimeUTC))
      return false;
    if (!(serviceType == rhs.serviceType))
      return false;
    if (!(uriSpec == rhs.uriSpec))
      return false;
    return true;
  }
  bool operator != (const DiscoveryInstance &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DiscoveryInstance & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DiscoveryInstance &a, DiscoveryInstance &b);

inline std::ostream& operator<<(std::ostream& out, const DiscoveryInstance& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CuratorEvent__isset {
  _CuratorEvent__isset() : type(false), resultCode(false), path(false), context(false), stat(false), data(false), name(false), children(false), aclList(false), watchedEvent(false), leaderEvent(false), childrenCacheEvent(false) {}
  bool type :1;
  bool resultCode :1;
  bool path :1;
  bool context :1;
  bool stat :1;
  bool data :1;
  bool name :1;
  bool children :1;
  bool aclList :1;
  bool watchedEvent :1;
  bool leaderEvent :1;
  bool childrenCacheEvent :1;
} _CuratorEvent__isset;

class CuratorEvent {
 public:

  CuratorEvent(const CuratorEvent&);
  CuratorEvent& operator=(const CuratorEvent&);
  CuratorEvent() : type((CuratorEventType::type)0), resultCode(0), path(), context(), data(), name() {
  }

  virtual ~CuratorEvent() throw();
  CuratorEventType::type type;
  int32_t resultCode;
  std::string path;
  std::string context;
  Stat stat;
  std::string data;
  std::string name;
  std::vector<std::string>  children;
  std::vector<Acl>  aclList;
  WatchedEvent watchedEvent;
  LeaderEvent leaderEvent;
  PathChildrenCacheEvent childrenCacheEvent;

  _CuratorEvent__isset __isset;

  void __set_type(const CuratorEventType::type val);

  void __set_resultCode(const int32_t val);

  void __set_path(const std::string& val);

  void __set_context(const std::string& val);

  void __set_stat(const Stat& val);

  void __set_data(const std::string& val);

  void __set_name(const std::string& val);

  void __set_children(const std::vector<std::string> & val);

  void __set_aclList(const std::vector<Acl> & val);

  void __set_watchedEvent(const WatchedEvent& val);

  void __set_leaderEvent(const LeaderEvent& val);

  void __set_childrenCacheEvent(const PathChildrenCacheEvent& val);

  bool operator == (const CuratorEvent & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(resultCode == rhs.resultCode))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(context == rhs.context))
      return false;
    if (!(stat == rhs.stat))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(children == rhs.children))
      return false;
    if (!(aclList == rhs.aclList))
      return false;
    if (!(watchedEvent == rhs.watchedEvent))
      return false;
    if (!(leaderEvent == rhs.leaderEvent))
      return false;
    if (!(childrenCacheEvent == rhs.childrenCacheEvent))
      return false;
    return true;
  }
  bool operator != (const CuratorEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CuratorEvent &a, CuratorEvent &b);

inline std::ostream& operator<<(std::ostream& out, const CuratorEvent& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
