/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "curator_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace shared {

int _kPathChildrenCacheStartModeValues[] = {
  PathChildrenCacheStartMode::NORMAL,
  PathChildrenCacheStartMode::BUILD_INITIAL_CACHE,
  PathChildrenCacheStartMode::POST_INITIALIZED_EVENT
};
const char* _kPathChildrenCacheStartModeNames[] = {
  "NORMAL",
  "BUILD_INITIAL_CACHE",
  "POST_INITIALIZED_EVENT"
};
const std::map<int, const char*> _PathChildrenCacheStartMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPathChildrenCacheStartModeValues, _kPathChildrenCacheStartModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCreateModeValues[] = {
  CreateMode::PERSISTENT,
  CreateMode::PERSISTENT_SEQUENTIAL,
  CreateMode::EPHEMERAL,
  CreateMode::EPHEMERAL_SEQUENTIAL,
  CreateMode::CONTAINER
};
const char* _kCreateModeNames[] = {
  "PERSISTENT",
  "PERSISTENT_SEQUENTIAL",
  "EPHEMERAL",
  "EPHEMERAL_SEQUENTIAL",
  "CONTAINER"
};
const std::map<int, const char*> _CreateMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kCreateModeValues, _kCreateModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCuratorEventTypeValues[] = {
  CuratorEventType::PING,
  CuratorEventType::CREATE,
  CuratorEventType::DELETE,
  CuratorEventType::EXISTS,
  CuratorEventType::GET_DATA,
  CuratorEventType::SET_DATA,
  CuratorEventType::CHILDREN,
  CuratorEventType::SYNC,
  CuratorEventType::GET_ACL,
  CuratorEventType::SET_ACL,
  CuratorEventType::WATCHED,
  CuratorEventType::CLOSING,
  CuratorEventType::CONNECTION_CONNECTED,
  CuratorEventType::CONNECTION_SUSPENDED,
  CuratorEventType::CONNECTION_RECONNECTED,
  CuratorEventType::CONNECTION_LOST,
  CuratorEventType::CONNECTION_READ_ONLY,
  CuratorEventType::LEADER,
  CuratorEventType::PATH_CHILDREN_CACHE,
  CuratorEventType::NODE_CACHE
};
const char* _kCuratorEventTypeNames[] = {
  "PING",
  "CREATE",
  "DELETE",
  "EXISTS",
  "GET_DATA",
  "SET_DATA",
  "CHILDREN",
  "SYNC",
  "GET_ACL",
  "SET_ACL",
  "WATCHED",
  "CLOSING",
  "CONNECTION_CONNECTED",
  "CONNECTION_SUSPENDED",
  "CONNECTION_RECONNECTED",
  "CONNECTION_LOST",
  "CONNECTION_READ_ONLY",
  "LEADER",
  "PATH_CHILDREN_CACHE",
  "NODE_CACHE"
};
const std::map<int, const char*> _CuratorEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kCuratorEventTypeValues, _kCuratorEventTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEventTypeValues[] = {
  EventType::None,
  EventType::NodeCreated,
  EventType::NodeDeleted,
  EventType::NodeDataChanged,
  EventType::NodeChildrenChanged
};
const char* _kEventTypeNames[] = {
  "None",
  "NodeCreated",
  "NodeDeleted",
  "NodeDataChanged",
  "NodeChildrenChanged"
};
const std::map<int, const char*> _EventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kEventTypeValues, _kEventTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kKeeperStateValues[] = {
  KeeperState::Unknown,
  KeeperState::Disconnected,
  KeeperState::NoSyncConnected,
  KeeperState::SyncConnected,
  KeeperState::AuthFailed,
  KeeperState::ConnectedReadOnly,
  KeeperState::SaslAuthenticated,
  KeeperState::Expired
};
const char* _kKeeperStateNames[] = {
  "Unknown",
  "Disconnected",
  "NoSyncConnected",
  "SyncConnected",
  "AuthFailed",
  "ConnectedReadOnly",
  "SaslAuthenticated",
  "Expired"
};
const std::map<int, const char*> _KeeperState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kKeeperStateValues, _kKeeperStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPathChildrenCacheEventTypeValues[] = {
  PathChildrenCacheEventType::CHILD_ADDED,
  PathChildrenCacheEventType::CHILD_UPDATED,
  PathChildrenCacheEventType::CHILD_REMOVED,
  PathChildrenCacheEventType::CONNECTION_SUSPENDED,
  PathChildrenCacheEventType::CONNECTION_RECONNECTED,
  PathChildrenCacheEventType::CONNECTION_LOST,
  PathChildrenCacheEventType::INITIALIZED
};
const char* _kPathChildrenCacheEventTypeNames[] = {
  "CHILD_ADDED",
  "CHILD_UPDATED",
  "CHILD_REMOVED",
  "CONNECTION_SUSPENDED",
  "CONNECTION_RECONNECTED",
  "CONNECTION_LOST",
  "INITIALIZED"
};
const std::map<int, const char*> _PathChildrenCacheEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kPathChildrenCacheEventTypeValues, _kPathChildrenCacheEventTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPersistentEphemeralNodeModeValues[] = {
  PersistentEphemeralNodeMode::EPHEMERAL,
  PersistentEphemeralNodeMode::EPHEMERAL_SEQUENTIAL,
  PersistentEphemeralNodeMode::PROTECTED_EPHEMERAL,
  PersistentEphemeralNodeMode::PROTECTED_EPHEMERAL_SEQUENTIAL
};
const char* _kPersistentEphemeralNodeModeNames[] = {
  "EPHEMERAL",
  "EPHEMERAL_SEQUENTIAL",
  "PROTECTED_EPHEMERAL",
  "PROTECTED_EPHEMERAL_SEQUENTIAL"
};
const std::map<int, const char*> _PersistentEphemeralNodeMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPersistentEphemeralNodeModeValues, _kPersistentEphemeralNodeModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kExceptionTypeValues[] = {
  ExceptionType::GENERAL,
  ExceptionType::ZOOKEEPER,
  ExceptionType::NODE
};
const char* _kExceptionTypeNames[] = {
  "GENERAL",
  "ZOOKEEPER",
  "NODE"
};
const std::map<int, const char*> _ExceptionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kExceptionTypeValues, _kExceptionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kNodeExceptionTypeValues[] = {
  NodeExceptionType::NONODE,
  NodeExceptionType::BADVERSION,
  NodeExceptionType::NODEEXISTS,
  NodeExceptionType::NOTEMPTY
};
const char* _kNodeExceptionTypeNames[] = {
  "NONODE",
  "BADVERSION",
  "NODEEXISTS",
  "NOTEMPTY"
};
const std::map<int, const char*> _NodeExceptionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kNodeExceptionTypeValues, _kNodeExceptionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kZooKeeperExceptionTypeValues[] = {
  ZooKeeperExceptionType::SYSTEMERROR,
  ZooKeeperExceptionType::RUNTIMEINCONSISTENCY,
  ZooKeeperExceptionType::DATAINCONSISTENCY,
  ZooKeeperExceptionType::CONNECTIONLOSS,
  ZooKeeperExceptionType::MARSHALLINGERROR,
  ZooKeeperExceptionType::UNIMPLEMENTED,
  ZooKeeperExceptionType::OPERATIONTIMEOUT,
  ZooKeeperExceptionType::BADARGUMENTS,
  ZooKeeperExceptionType::APIERROR,
  ZooKeeperExceptionType::NOAUTH,
  ZooKeeperExceptionType::NOCHILDRENFOREPHEMERALS,
  ZooKeeperExceptionType::INVALIDACL,
  ZooKeeperExceptionType::AUTHFAILED,
  ZooKeeperExceptionType::SESSIONEXPIRED,
  ZooKeeperExceptionType::INVALIDCALLBACK,
  ZooKeeperExceptionType::SESSIONMOVED,
  ZooKeeperExceptionType::NOTREADONLY
};
const char* _kZooKeeperExceptionTypeNames[] = {
  "SYSTEMERROR",
  "RUNTIMEINCONSISTENCY",
  "DATAINCONSISTENCY",
  "CONNECTIONLOSS",
  "MARSHALLINGERROR",
  "UNIMPLEMENTED",
  "OPERATIONTIMEOUT",
  "BADARGUMENTS",
  "APIERROR",
  "NOAUTH",
  "NOCHILDRENFOREPHEMERALS",
  "INVALIDACL",
  "AUTHFAILED",
  "SESSIONEXPIRED",
  "INVALIDCALLBACK",
  "SESSIONMOVED",
  "NOTREADONLY"
};
const std::map<int, const char*> _ZooKeeperExceptionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kZooKeeperExceptionTypeValues, _kZooKeeperExceptionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDiscoveryInstanceTypeValues[] = {
  DiscoveryInstanceType::DYNAMIC,
  DiscoveryInstanceType::STATIC,
  DiscoveryInstanceType::PERMANENT
};
const char* _kDiscoveryInstanceTypeNames[] = {
  "DYNAMIC",
  "STATIC",
  "PERMANENT"
};
const std::map<int, const char*> _DiscoveryInstanceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kDiscoveryInstanceTypeValues, _kDiscoveryInstanceTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kProviderStrategyTypeValues[] = {
  ProviderStrategyType::RANDOM,
  ProviderStrategyType::STICKY_RANDOM,
  ProviderStrategyType::STICKY_ROUND_ROBIN,
  ProviderStrategyType::ROUND_ROBIN
};
const char* _kProviderStrategyTypeNames[] = {
  "RANDOM",
  "STICKY_RANDOM",
  "STICKY_ROUND_ROBIN",
  "ROUND_ROBIN"
};
const std::map<int, const char*> _ProviderStrategyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kProviderStrategyTypeValues, _kProviderStrategyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


CuratorProjection::~CuratorProjection() throw() {
}


void CuratorProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t CuratorProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CuratorProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CuratorProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CuratorProjection &a, CuratorProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

CuratorProjection::CuratorProjection(const CuratorProjection& other0) {
  id = other0.id;
  __isset = other0.__isset;
}
CuratorProjection& CuratorProjection::operator=(const CuratorProjection& other1) {
  id = other1.id;
  __isset = other1.__isset;
  return *this;
}
void CuratorProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CuratorProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


ExistsSpec::~ExistsSpec() throw() {
}


void ExistsSpec::__set_path(const std::string& val) {
  this->path = val;
}

void ExistsSpec::__set_watched(const bool val) {
  this->watched = val;
}

void ExistsSpec::__set_asyncContext(const std::string& val) {
  this->asyncContext = val;
}

uint32_t ExistsSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->watched);
          this->__isset.watched = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asyncContext);
          this->__isset.asyncContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExistsSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExistsSpec");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("watched", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->watched);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asyncContext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->asyncContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExistsSpec &a, ExistsSpec &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.watched, b.watched);
  swap(a.asyncContext, b.asyncContext);
  swap(a.__isset, b.__isset);
}

ExistsSpec::ExistsSpec(const ExistsSpec& other2) {
  path = other2.path;
  watched = other2.watched;
  asyncContext = other2.asyncContext;
  __isset = other2.__isset;
}
ExistsSpec& ExistsSpec::operator=(const ExistsSpec& other3) {
  path = other3.path;
  watched = other3.watched;
  asyncContext = other3.asyncContext;
  __isset = other3.__isset;
  return *this;
}
void ExistsSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExistsSpec(";
  out << "path=" << to_string(path);
  out << ", " << "watched=" << to_string(watched);
  out << ", " << "asyncContext=" << to_string(asyncContext);
  out << ")";
}


GetChildrenSpec::~GetChildrenSpec() throw() {
}


void GetChildrenSpec::__set_path(const std::string& val) {
  this->path = val;
}

void GetChildrenSpec::__set_watched(const bool val) {
  this->watched = val;
}

void GetChildrenSpec::__set_asyncContext(const std::string& val) {
  this->asyncContext = val;
}

uint32_t GetChildrenSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->watched);
          this->__isset.watched = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asyncContext);
          this->__isset.asyncContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetChildrenSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetChildrenSpec");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("watched", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->watched);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asyncContext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->asyncContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetChildrenSpec &a, GetChildrenSpec &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.watched, b.watched);
  swap(a.asyncContext, b.asyncContext);
  swap(a.__isset, b.__isset);
}

GetChildrenSpec::GetChildrenSpec(const GetChildrenSpec& other4) {
  path = other4.path;
  watched = other4.watched;
  asyncContext = other4.asyncContext;
  __isset = other4.__isset;
}
GetChildrenSpec& GetChildrenSpec::operator=(const GetChildrenSpec& other5) {
  path = other5.path;
  watched = other5.watched;
  asyncContext = other5.asyncContext;
  __isset = other5.__isset;
  return *this;
}
void GetChildrenSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetChildrenSpec(";
  out << "path=" << to_string(path);
  out << ", " << "watched=" << to_string(watched);
  out << ", " << "asyncContext=" << to_string(asyncContext);
  out << ")";
}


GetDataSpec::~GetDataSpec() throw() {
}


void GetDataSpec::__set_path(const std::string& val) {
  this->path = val;
}

void GetDataSpec::__set_watched(const bool val) {
  this->watched = val;
}

void GetDataSpec::__set_asyncContext(const std::string& val) {
  this->asyncContext = val;
}

void GetDataSpec::__set_decompressed(const bool val) {
  this->decompressed = val;
}

uint32_t GetDataSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->watched);
          this->__isset.watched = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asyncContext);
          this->__isset.asyncContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->decompressed);
          this->__isset.decompressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetDataSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetDataSpec");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("watched", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->watched);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asyncContext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->asyncContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decompressed", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->decompressed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDataSpec &a, GetDataSpec &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.watched, b.watched);
  swap(a.asyncContext, b.asyncContext);
  swap(a.decompressed, b.decompressed);
  swap(a.__isset, b.__isset);
}

GetDataSpec::GetDataSpec(const GetDataSpec& other6) {
  path = other6.path;
  watched = other6.watched;
  asyncContext = other6.asyncContext;
  decompressed = other6.decompressed;
  __isset = other6.__isset;
}
GetDataSpec& GetDataSpec::operator=(const GetDataSpec& other7) {
  path = other7.path;
  watched = other7.watched;
  asyncContext = other7.asyncContext;
  decompressed = other7.decompressed;
  __isset = other7.__isset;
  return *this;
}
void GetDataSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetDataSpec(";
  out << "path=" << to_string(path);
  out << ", " << "watched=" << to_string(watched);
  out << ", " << "asyncContext=" << to_string(asyncContext);
  out << ", " << "decompressed=" << to_string(decompressed);
  out << ")";
}


LeaderEvent::~LeaderEvent() throw() {
}


void LeaderEvent::__set_path(const std::string& val) {
  this->path = val;
}

void LeaderEvent::__set_participantId(const std::string& val) {
  this->participantId = val;
}

void LeaderEvent::__set_isLeader(const bool val) {
  this->isLeader = val;
}

uint32_t LeaderEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->participantId);
          this->__isset.participantId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isLeader);
          this->__isset.isLeader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LeaderEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LeaderEvent");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("participantId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->participantId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isLeader", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isLeader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LeaderEvent &a, LeaderEvent &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.participantId, b.participantId);
  swap(a.isLeader, b.isLeader);
  swap(a.__isset, b.__isset);
}

LeaderEvent::LeaderEvent(const LeaderEvent& other8) {
  path = other8.path;
  participantId = other8.participantId;
  isLeader = other8.isLeader;
  __isset = other8.__isset;
}
LeaderEvent& LeaderEvent::operator=(const LeaderEvent& other9) {
  path = other9.path;
  participantId = other9.participantId;
  isLeader = other9.isLeader;
  __isset = other9.__isset;
  return *this;
}
void LeaderEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LeaderEvent(";
  out << "path=" << to_string(path);
  out << ", " << "participantId=" << to_string(participantId);
  out << ", " << "isLeader=" << to_string(isLeader);
  out << ")";
}


LeaderProjection::~LeaderProjection() throw() {
}


void LeaderProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t LeaderProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LeaderProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LeaderProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LeaderProjection &a, LeaderProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

LeaderProjection::LeaderProjection(const LeaderProjection& other10) {
  id = other10.id;
  __isset = other10.__isset;
}
LeaderProjection& LeaderProjection::operator=(const LeaderProjection& other11) {
  id = other11.id;
  __isset = other11.__isset;
  return *this;
}
void LeaderProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LeaderProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


LeaderResult::~LeaderResult() throw() {
}


void LeaderResult::__set_projection(const LeaderProjection& val) {
  this->projection = val;
}

void LeaderResult::__set_isLeader(const bool val) {
  this->isLeader = val;
}

uint32_t LeaderResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->projection.read(iprot);
          this->__isset.projection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isLeader);
          this->__isset.isLeader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LeaderResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LeaderResult");

  xfer += oprot->writeFieldBegin("projection", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->projection.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isLeader", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isLeader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LeaderResult &a, LeaderResult &b) {
  using ::std::swap;
  swap(a.projection, b.projection);
  swap(a.isLeader, b.isLeader);
  swap(a.__isset, b.__isset);
}

LeaderResult::LeaderResult(const LeaderResult& other12) {
  projection = other12.projection;
  isLeader = other12.isLeader;
  __isset = other12.__isset;
}
LeaderResult& LeaderResult::operator=(const LeaderResult& other13) {
  projection = other13.projection;
  isLeader = other13.isLeader;
  __isset = other13.__isset;
  return *this;
}
void LeaderResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LeaderResult(";
  out << "projection=" << to_string(projection);
  out << ", " << "isLeader=" << to_string(isLeader);
  out << ")";
}


LeaseProjection::~LeaseProjection() throw() {
}


void LeaseProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t LeaseProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LeaseProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LeaseProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LeaseProjection &a, LeaseProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

LeaseProjection::LeaseProjection(const LeaseProjection& other14) {
  id = other14.id;
  __isset = other14.__isset;
}
LeaseProjection& LeaseProjection::operator=(const LeaseProjection& other15) {
  id = other15.id;
  __isset = other15.__isset;
  return *this;
}
void LeaseProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LeaseProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


LockProjection::~LockProjection() throw() {
}


void LockProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t LockProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockProjection &a, LockProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

LockProjection::LockProjection(const LockProjection& other16) {
  id = other16.id;
  __isset = other16.__isset;
}
LockProjection& LockProjection::operator=(const LockProjection& other17) {
  id = other17.id;
  __isset = other17.__isset;
  return *this;
}
void LockProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


NodeCacheProjection::~NodeCacheProjection() throw() {
}


void NodeCacheProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t NodeCacheProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NodeCacheProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NodeCacheProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NodeCacheProjection &a, NodeCacheProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

NodeCacheProjection::NodeCacheProjection(const NodeCacheProjection& other18) {
  id = other18.id;
  __isset = other18.__isset;
}
NodeCacheProjection& NodeCacheProjection::operator=(const NodeCacheProjection& other19) {
  id = other19.id;
  __isset = other19.__isset;
  return *this;
}
void NodeCacheProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NodeCacheProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


OptionalChildrenList::~OptionalChildrenList() throw() {
}


void OptionalChildrenList::__set_children(const std::vector<std::string> & val) {
  this->children = val;
}

uint32_t OptionalChildrenList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->children.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->children.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readString(this->children[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalChildrenList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptionalChildrenList");

  xfer += oprot->writeFieldBegin("children", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->children.size()));
    std::vector<std::string> ::const_iterator _iter25;
    for (_iter25 = this->children.begin(); _iter25 != this->children.end(); ++_iter25)
    {
      xfer += oprot->writeString((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalChildrenList &a, OptionalChildrenList &b) {
  using ::std::swap;
  swap(a.children, b.children);
  swap(a.__isset, b.__isset);
}

OptionalChildrenList::OptionalChildrenList(const OptionalChildrenList& other26) {
  children = other26.children;
  __isset = other26.__isset;
}
OptionalChildrenList& OptionalChildrenList::operator=(const OptionalChildrenList& other27) {
  children = other27.children;
  __isset = other27.__isset;
  return *this;
}
void OptionalChildrenList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptionalChildrenList(";
  out << "children=" << to_string(children);
  out << ")";
}


OptionalData::~OptionalData() throw() {
}


void OptionalData::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t OptionalData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptionalData");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalData &a, OptionalData &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

OptionalData::OptionalData(const OptionalData& other28) {
  data = other28.data;
  __isset = other28.__isset;
}
OptionalData& OptionalData::operator=(const OptionalData& other29) {
  data = other29.data;
  __isset = other29.__isset;
  return *this;
}
void OptionalData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptionalData(";
  out << "data=" << to_string(data);
  out << ")";
}


OptionalLockProjection::~OptionalLockProjection() throw() {
}


void OptionalLockProjection::__set_lockProjection(const LockProjection& val) {
  this->lockProjection = val;
}

uint32_t OptionalLockProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lockProjection.read(iprot);
          this->__isset.lockProjection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalLockProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptionalLockProjection");

  xfer += oprot->writeFieldBegin("lockProjection", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->lockProjection.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalLockProjection &a, OptionalLockProjection &b) {
  using ::std::swap;
  swap(a.lockProjection, b.lockProjection);
  swap(a.__isset, b.__isset);
}

OptionalLockProjection::OptionalLockProjection(const OptionalLockProjection& other30) {
  lockProjection = other30.lockProjection;
  __isset = other30.__isset;
}
OptionalLockProjection& OptionalLockProjection::operator=(const OptionalLockProjection& other31) {
  lockProjection = other31.lockProjection;
  __isset = other31.__isset;
  return *this;
}
void OptionalLockProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptionalLockProjection(";
  out << "lockProjection=" << to_string(lockProjection);
  out << ")";
}


OptionalPath::~OptionalPath() throw() {
}


void OptionalPath::__set_path(const std::string& val) {
  this->path = val;
}

uint32_t OptionalPath::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalPath::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptionalPath");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalPath &a, OptionalPath &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

OptionalPath::OptionalPath(const OptionalPath& other32) {
  path = other32.path;
  __isset = other32.__isset;
}
OptionalPath& OptionalPath::operator=(const OptionalPath& other33) {
  path = other33.path;
  __isset = other33.__isset;
  return *this;
}
void OptionalPath::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptionalPath(";
  out << "path=" << to_string(path);
  out << ")";
}


PathChildrenCacheProjection::~PathChildrenCacheProjection() throw() {
}


void PathChildrenCacheProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t PathChildrenCacheProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PathChildrenCacheProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PathChildrenCacheProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PathChildrenCacheProjection &a, PathChildrenCacheProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

PathChildrenCacheProjection::PathChildrenCacheProjection(const PathChildrenCacheProjection& other34) {
  id = other34.id;
  __isset = other34.__isset;
}
PathChildrenCacheProjection& PathChildrenCacheProjection::operator=(const PathChildrenCacheProjection& other35) {
  id = other35.id;
  __isset = other35.__isset;
  return *this;
}
void PathChildrenCacheProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PathChildrenCacheProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


PersistentEphemeralNodeProjection::~PersistentEphemeralNodeProjection() throw() {
}


void PersistentEphemeralNodeProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t PersistentEphemeralNodeProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PersistentEphemeralNodeProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PersistentEphemeralNodeProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PersistentEphemeralNodeProjection &a, PersistentEphemeralNodeProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

PersistentEphemeralNodeProjection::PersistentEphemeralNodeProjection(const PersistentEphemeralNodeProjection& other36) {
  id = other36.id;
  __isset = other36.__isset;
}
PersistentEphemeralNodeProjection& PersistentEphemeralNodeProjection::operator=(const PersistentEphemeralNodeProjection& other37) {
  id = other37.id;
  __isset = other37.__isset;
  return *this;
}
void PersistentEphemeralNodeProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PersistentEphemeralNodeProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


Id::~Id() throw() {
}


void Id::__set_scheme(const std::string& val) {
  this->scheme = val;
}

void Id::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t Id::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scheme);
          this->__isset.scheme = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Id::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Id");

  xfer += oprot->writeFieldBegin("scheme", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->scheme);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Id &a, Id &b) {
  using ::std::swap;
  swap(a.scheme, b.scheme);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

Id::Id(const Id& other38) {
  scheme = other38.scheme;
  id = other38.id;
  __isset = other38.__isset;
}
Id& Id::operator=(const Id& other39) {
  scheme = other39.scheme;
  id = other39.id;
  __isset = other39.__isset;
  return *this;
}
void Id::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Id(";
  out << "scheme=" << to_string(scheme);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


Participant::~Participant() throw() {
}


void Participant::__set_id(const std::string& val) {
  this->id = val;
}

void Participant::__set_isLeader(const bool val) {
  this->isLeader = val;
}

uint32_t Participant::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isLeader);
          this->__isset.isLeader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Participant::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Participant");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isLeader", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isLeader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Participant &a, Participant &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.isLeader, b.isLeader);
  swap(a.__isset, b.__isset);
}

Participant::Participant(const Participant& other40) {
  id = other40.id;
  isLeader = other40.isLeader;
  __isset = other40.__isset;
}
Participant& Participant::operator=(const Participant& other41) {
  id = other41.id;
  isLeader = other41.isLeader;
  __isset = other41.__isset;
  return *this;
}
void Participant::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Participant(";
  out << "id=" << to_string(id);
  out << ", " << "isLeader=" << to_string(isLeader);
  out << ")";
}


Stat::~Stat() throw() {
}


void Stat::__set_czxid(const int64_t val) {
  this->czxid = val;
}

void Stat::__set_mzxid(const int64_t val) {
  this->mzxid = val;
}

void Stat::__set_ctime(const int64_t val) {
  this->ctime = val;
}

void Stat::__set_mtime(const int64_t val) {
  this->mtime = val;
}

void Stat::__set_version(const int32_t val) {
  this->version = val;
}

void Stat::__set_cversion(const int32_t val) {
  this->cversion = val;
}

void Stat::__set_aversion(const int32_t val) {
  this->aversion = val;
}

void Stat::__set_ephemeralOwner(const int64_t val) {
  this->ephemeralOwner = val;
}

void Stat::__set_dataLength(const int32_t val) {
  this->dataLength = val;
}

void Stat::__set_numChildren(const int32_t val) {
  this->numChildren = val;
}

void Stat::__set_pzxid(const int64_t val) {
  this->pzxid = val;
}

uint32_t Stat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->czxid);
          this->__isset.czxid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mzxid);
          this->__isset.mzxid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ctime);
          this->__isset.ctime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mtime);
          this->__isset.mtime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cversion);
          this->__isset.cversion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->aversion);
          this->__isset.aversion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ephemeralOwner);
          this->__isset.ephemeralOwner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dataLength);
          this->__isset.dataLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numChildren);
          this->__isset.numChildren = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pzxid);
          this->__isset.pzxid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Stat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Stat");

  xfer += oprot->writeFieldBegin("czxid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->czxid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mzxid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->mzxid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ctime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ctime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mtime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->mtime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cversion", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->cversion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aversion", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->aversion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ephemeralOwner", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->ephemeralOwner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataLength", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->dataLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numChildren", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->numChildren);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pzxid", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->pzxid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Stat &a, Stat &b) {
  using ::std::swap;
  swap(a.czxid, b.czxid);
  swap(a.mzxid, b.mzxid);
  swap(a.ctime, b.ctime);
  swap(a.mtime, b.mtime);
  swap(a.version, b.version);
  swap(a.cversion, b.cversion);
  swap(a.aversion, b.aversion);
  swap(a.ephemeralOwner, b.ephemeralOwner);
  swap(a.dataLength, b.dataLength);
  swap(a.numChildren, b.numChildren);
  swap(a.pzxid, b.pzxid);
  swap(a.__isset, b.__isset);
}

Stat::Stat(const Stat& other42) {
  czxid = other42.czxid;
  mzxid = other42.mzxid;
  ctime = other42.ctime;
  mtime = other42.mtime;
  version = other42.version;
  cversion = other42.cversion;
  aversion = other42.aversion;
  ephemeralOwner = other42.ephemeralOwner;
  dataLength = other42.dataLength;
  numChildren = other42.numChildren;
  pzxid = other42.pzxid;
  __isset = other42.__isset;
}
Stat& Stat::operator=(const Stat& other43) {
  czxid = other43.czxid;
  mzxid = other43.mzxid;
  ctime = other43.ctime;
  mtime = other43.mtime;
  version = other43.version;
  cversion = other43.cversion;
  aversion = other43.aversion;
  ephemeralOwner = other43.ephemeralOwner;
  dataLength = other43.dataLength;
  numChildren = other43.numChildren;
  pzxid = other43.pzxid;
  __isset = other43.__isset;
  return *this;
}
void Stat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Stat(";
  out << "czxid=" << to_string(czxid);
  out << ", " << "mzxid=" << to_string(mzxid);
  out << ", " << "ctime=" << to_string(ctime);
  out << ", " << "mtime=" << to_string(mtime);
  out << ", " << "version=" << to_string(version);
  out << ", " << "cversion=" << to_string(cversion);
  out << ", " << "aversion=" << to_string(aversion);
  out << ", " << "ephemeralOwner=" << to_string(ephemeralOwner);
  out << ", " << "dataLength=" << to_string(dataLength);
  out << ", " << "numChildren=" << to_string(numChildren);
  out << ", " << "pzxid=" << to_string(pzxid);
  out << ")";
}


WatchedEvent::~WatchedEvent() throw() {
}


void WatchedEvent::__set_keeperState(const KeeperState::type val) {
  this->keeperState = val;
}

void WatchedEvent::__set_eventType(const EventType::type val) {
  this->eventType = val;
}

void WatchedEvent::__set_path(const std::string& val) {
  this->path = val;
}

uint32_t WatchedEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast44;
          xfer += iprot->readI32(ecast44);
          this->keeperState = (KeeperState::type)ecast44;
          this->__isset.keeperState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast45;
          xfer += iprot->readI32(ecast45);
          this->eventType = (EventType::type)ecast45;
          this->__isset.eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WatchedEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WatchedEvent");

  xfer += oprot->writeFieldBegin("keeperState", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->keeperState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->eventType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WatchedEvent &a, WatchedEvent &b) {
  using ::std::swap;
  swap(a.keeperState, b.keeperState);
  swap(a.eventType, b.eventType);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

WatchedEvent::WatchedEvent(const WatchedEvent& other46) {
  keeperState = other46.keeperState;
  eventType = other46.eventType;
  path = other46.path;
  __isset = other46.__isset;
}
WatchedEvent& WatchedEvent::operator=(const WatchedEvent& other47) {
  keeperState = other47.keeperState;
  eventType = other47.eventType;
  path = other47.path;
  __isset = other47.__isset;
  return *this;
}
void WatchedEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WatchedEvent(";
  out << "keeperState=" << to_string(keeperState);
  out << ", " << "eventType=" << to_string(eventType);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


Version::~Version() throw() {
}


void Version::__set_version(const int32_t val) {
  this->version = val;
}

uint32_t Version::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Version::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Version");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Version &a, Version &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

Version::Version(const Version& other48) {
  version = other48.version;
  __isset = other48.__isset;
}
Version& Version::operator=(const Version& other49) {
  version = other49.version;
  __isset = other49.__isset;
  return *this;
}
void Version::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Version(";
  out << "version=" << to_string(version);
  out << ")";
}


DiscoveryProjection::~DiscoveryProjection() throw() {
}


void DiscoveryProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t DiscoveryProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiscoveryProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiscoveryProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiscoveryProjection &a, DiscoveryProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

DiscoveryProjection::DiscoveryProjection(const DiscoveryProjection& other50) {
  id = other50.id;
  __isset = other50.__isset;
}
DiscoveryProjection& DiscoveryProjection::operator=(const DiscoveryProjection& other51) {
  id = other51.id;
  __isset = other51.__isset;
  return *this;
}
void DiscoveryProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiscoveryProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


DiscoveryProviderProjection::~DiscoveryProviderProjection() throw() {
}


void DiscoveryProviderProjection::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t DiscoveryProviderProjection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiscoveryProviderProjection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiscoveryProviderProjection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiscoveryProviderProjection &a, DiscoveryProviderProjection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

DiscoveryProviderProjection::DiscoveryProviderProjection(const DiscoveryProviderProjection& other52) {
  id = other52.id;
  __isset = other52.__isset;
}
DiscoveryProviderProjection& DiscoveryProviderProjection::operator=(const DiscoveryProviderProjection& other53) {
  id = other53.id;
  __isset = other53.__isset;
  return *this;
}
void DiscoveryProviderProjection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiscoveryProviderProjection(";
  out << "id=" << to_string(id);
  out << ")";
}


CreateSpec::~CreateSpec() throw() {
}


void CreateSpec::__set_path(const std::string& val) {
  this->path = val;
}

void CreateSpec::__set_data(const std::string& val) {
  this->data = val;
}

void CreateSpec::__set_mode(const CreateMode::type val) {
  this->mode = val;
}

void CreateSpec::__set_asyncContext(const std::string& val) {
  this->asyncContext = val;
}

void CreateSpec::__set_compressed(const bool val) {
  this->compressed = val;
}

void CreateSpec::__set_creatingParentsIfNeeded(const bool val) {
  this->creatingParentsIfNeeded = val;
}

void CreateSpec::__set_withProtection(const bool val) {
  this->withProtection = val;
}

void CreateSpec::__set_creatingParentContainersIfNeeded(const bool val) {
  this->creatingParentContainersIfNeeded = val;
}

uint32_t CreateSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->mode = (CreateMode::type)ecast54;
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asyncContext);
          this->__isset.asyncContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->creatingParentsIfNeeded);
          this->__isset.creatingParentsIfNeeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->withProtection);
          this->__isset.withProtection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->creatingParentContainersIfNeeded);
          this->__isset.creatingParentContainersIfNeeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateSpec");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asyncContext", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->asyncContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->compressed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("creatingParentsIfNeeded", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->creatingParentsIfNeeded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("withProtection", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->withProtection);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("creatingParentContainersIfNeeded", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->creatingParentContainersIfNeeded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateSpec &a, CreateSpec &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.data, b.data);
  swap(a.mode, b.mode);
  swap(a.asyncContext, b.asyncContext);
  swap(a.compressed, b.compressed);
  swap(a.creatingParentsIfNeeded, b.creatingParentsIfNeeded);
  swap(a.withProtection, b.withProtection);
  swap(a.creatingParentContainersIfNeeded, b.creatingParentContainersIfNeeded);
  swap(a.__isset, b.__isset);
}

CreateSpec::CreateSpec(const CreateSpec& other55) {
  path = other55.path;
  data = other55.data;
  mode = other55.mode;
  asyncContext = other55.asyncContext;
  compressed = other55.compressed;
  creatingParentsIfNeeded = other55.creatingParentsIfNeeded;
  withProtection = other55.withProtection;
  creatingParentContainersIfNeeded = other55.creatingParentContainersIfNeeded;
  __isset = other55.__isset;
}
CreateSpec& CreateSpec::operator=(const CreateSpec& other56) {
  path = other56.path;
  data = other56.data;
  mode = other56.mode;
  asyncContext = other56.asyncContext;
  compressed = other56.compressed;
  creatingParentsIfNeeded = other56.creatingParentsIfNeeded;
  withProtection = other56.withProtection;
  creatingParentContainersIfNeeded = other56.creatingParentContainersIfNeeded;
  __isset = other56.__isset;
  return *this;
}
void CreateSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateSpec(";
  out << "path=" << to_string(path);
  out << ", " << "data=" << to_string(data);
  out << ", " << "mode=" << to_string(mode);
  out << ", " << "asyncContext=" << to_string(asyncContext);
  out << ", " << "compressed=" << to_string(compressed);
  out << ", " << "creatingParentsIfNeeded=" << to_string(creatingParentsIfNeeded);
  out << ", " << "withProtection=" << to_string(withProtection);
  out << ", " << "creatingParentContainersIfNeeded=" << to_string(creatingParentContainersIfNeeded);
  out << ")";
}


DeleteSpec::~DeleteSpec() throw() {
}


void DeleteSpec::__set_path(const std::string& val) {
  this->path = val;
}

void DeleteSpec::__set_guaranteed(const bool val) {
  this->guaranteed = val;
}

void DeleteSpec::__set_asyncContext(const std::string& val) {
  this->asyncContext = val;
}

void DeleteSpec::__set_version(const Version& val) {
  this->version = val;
}

uint32_t DeleteSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->guaranteed);
          this->__isset.guaranteed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asyncContext);
          this->__isset.asyncContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->version.read(iprot);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeleteSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeleteSpec");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guaranteed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->guaranteed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asyncContext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->asyncContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->version.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeleteSpec &a, DeleteSpec &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.guaranteed, b.guaranteed);
  swap(a.asyncContext, b.asyncContext);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

DeleteSpec::DeleteSpec(const DeleteSpec& other57) {
  path = other57.path;
  guaranteed = other57.guaranteed;
  asyncContext = other57.asyncContext;
  version = other57.version;
  __isset = other57.__isset;
}
DeleteSpec& DeleteSpec::operator=(const DeleteSpec& other58) {
  path = other58.path;
  guaranteed = other58.guaranteed;
  asyncContext = other58.asyncContext;
  version = other58.version;
  __isset = other58.__isset;
  return *this;
}
void DeleteSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeleteSpec(";
  out << "path=" << to_string(path);
  out << ", " << "guaranteed=" << to_string(guaranteed);
  out << ", " << "asyncContext=" << to_string(asyncContext);
  out << ", " << "version=" << to_string(version);
  out << ")";
}


OptionalStat::~OptionalStat() throw() {
}


void OptionalStat::__set_stat(const Stat& val) {
  this->stat = val;
}

uint32_t OptionalStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stat.read(iprot);
          this->__isset.stat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptionalStat");

  xfer += oprot->writeFieldBegin("stat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalStat &a, OptionalStat &b) {
  using ::std::swap;
  swap(a.stat, b.stat);
  swap(a.__isset, b.__isset);
}

OptionalStat::OptionalStat(const OptionalStat& other59) {
  stat = other59.stat;
  __isset = other59.__isset;
}
OptionalStat& OptionalStat::operator=(const OptionalStat& other60) {
  stat = other60.stat;
  __isset = other60.__isset;
  return *this;
}
void OptionalStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptionalStat(";
  out << "stat=" << to_string(stat);
  out << ")";
}


Acl::~Acl() throw() {
}


void Acl::__set_perms(const int32_t val) {
  this->perms = val;
}

void Acl::__set_id(const Id& val) {
  this->id = val;
}

uint32_t Acl::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->perms);
          this->__isset.perms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Acl::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Acl");

  xfer += oprot->writeFieldBegin("perms", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->perms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Acl &a, Acl &b) {
  using ::std::swap;
  swap(a.perms, b.perms);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

Acl::Acl(const Acl& other61) {
  perms = other61.perms;
  id = other61.id;
  __isset = other61.__isset;
}
Acl& Acl::operator=(const Acl& other62) {
  perms = other62.perms;
  id = other62.id;
  __isset = other62.__isset;
  return *this;
}
void Acl::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Acl(";
  out << "perms=" << to_string(perms);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


ChildData::~ChildData() throw() {
}


void ChildData::__set_path(const std::string& val) {
  this->path = val;
}

void ChildData::__set_stat(const Stat& val) {
  this->stat = val;
}

void ChildData::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t ChildData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stat.read(iprot);
          this->__isset.stat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChildData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChildData");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stat", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChildData &a, ChildData &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.stat, b.stat);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

ChildData::ChildData(const ChildData& other63) {
  path = other63.path;
  stat = other63.stat;
  data = other63.data;
  __isset = other63.__isset;
}
ChildData& ChildData::operator=(const ChildData& other64) {
  path = other64.path;
  stat = other64.stat;
  data = other64.data;
  __isset = other64.__isset;
  return *this;
}
void ChildData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChildData(";
  out << "path=" << to_string(path);
  out << ", " << "stat=" << to_string(stat);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


PathChildrenCacheEvent::~PathChildrenCacheEvent() throw() {
}


void PathChildrenCacheEvent::__set_cachedPath(const std::string& val) {
  this->cachedPath = val;
}

void PathChildrenCacheEvent::__set_type(const PathChildrenCacheEventType::type val) {
  this->type = val;
}

void PathChildrenCacheEvent::__set_data(const ChildData& val) {
  this->data = val;
}

uint32_t PathChildrenCacheEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cachedPath);
          this->__isset.cachedPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->type = (PathChildrenCacheEventType::type)ecast65;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PathChildrenCacheEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PathChildrenCacheEvent");

  xfer += oprot->writeFieldBegin("cachedPath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->cachedPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PathChildrenCacheEvent &a, PathChildrenCacheEvent &b) {
  using ::std::swap;
  swap(a.cachedPath, b.cachedPath);
  swap(a.type, b.type);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

PathChildrenCacheEvent::PathChildrenCacheEvent(const PathChildrenCacheEvent& other66) {
  cachedPath = other66.cachedPath;
  type = other66.type;
  data = other66.data;
  __isset = other66.__isset;
}
PathChildrenCacheEvent& PathChildrenCacheEvent::operator=(const PathChildrenCacheEvent& other67) {
  cachedPath = other67.cachedPath;
  type = other67.type;
  data = other67.data;
  __isset = other67.__isset;
  return *this;
}
void PathChildrenCacheEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PathChildrenCacheEvent(";
  out << "cachedPath=" << to_string(cachedPath);
  out << ", " << "type=" << to_string(type);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


SetDataSpec::~SetDataSpec() throw() {
}


void SetDataSpec::__set_path(const std::string& val) {
  this->path = val;
}

void SetDataSpec::__set_watched(const bool val) {
  this->watched = val;
}

void SetDataSpec::__set_asyncContext(const std::string& val) {
  this->asyncContext = val;
}

void SetDataSpec::__set_compressed(const bool val) {
  this->compressed = val;
}

void SetDataSpec::__set_version(const Version& val) {
  this->version = val;
}

void SetDataSpec::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t SetDataSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->watched);
          this->__isset.watched = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->asyncContext);
          this->__isset.asyncContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->version.read(iprot);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetDataSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetDataSpec");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("watched", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->watched);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asyncContext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->asyncContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->compressed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->version.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetDataSpec &a, SetDataSpec &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.watched, b.watched);
  swap(a.asyncContext, b.asyncContext);
  swap(a.compressed, b.compressed);
  swap(a.version, b.version);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

SetDataSpec::SetDataSpec(const SetDataSpec& other68) {
  path = other68.path;
  watched = other68.watched;
  asyncContext = other68.asyncContext;
  compressed = other68.compressed;
  version = other68.version;
  data = other68.data;
  __isset = other68.__isset;
}
SetDataSpec& SetDataSpec::operator=(const SetDataSpec& other69) {
  path = other69.path;
  watched = other69.watched;
  asyncContext = other69.asyncContext;
  compressed = other69.compressed;
  version = other69.version;
  data = other69.data;
  __isset = other69.__isset;
  return *this;
}
void SetDataSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetDataSpec(";
  out << "path=" << to_string(path);
  out << ", " << "watched=" << to_string(watched);
  out << ", " << "asyncContext=" << to_string(asyncContext);
  out << ", " << "compressed=" << to_string(compressed);
  out << ", " << "version=" << to_string(version);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CuratorException::~CuratorException() throw() {
}


void CuratorException::__set_type(const ExceptionType::type val) {
  this->type = val;
}

void CuratorException::__set_zooKeeperException(const ZooKeeperExceptionType::type val) {
  this->zooKeeperException = val;
}

void CuratorException::__set_nodeException(const NodeExceptionType::type val) {
  this->nodeException = val;
}

void CuratorException::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t CuratorException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast70;
          xfer += iprot->readI32(ecast70);
          this->type = (ExceptionType::type)ecast70;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast71;
          xfer += iprot->readI32(ecast71);
          this->zooKeeperException = (ZooKeeperExceptionType::type)ecast71;
          this->__isset.zooKeeperException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->nodeException = (NodeExceptionType::type)ecast72;
          this->__isset.nodeException = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CuratorException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CuratorException");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zooKeeperException", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->zooKeeperException);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeException", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->nodeException);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CuratorException &a, CuratorException &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.zooKeeperException, b.zooKeeperException);
  swap(a.nodeException, b.nodeException);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

CuratorException::CuratorException(const CuratorException& other73) : TException() {
  type = other73.type;
  zooKeeperException = other73.zooKeeperException;
  nodeException = other73.nodeException;
  message = other73.message;
  __isset = other73.__isset;
}
CuratorException& CuratorException::operator=(const CuratorException& other74) {
  type = other74.type;
  zooKeeperException = other74.zooKeeperException;
  nodeException = other74.nodeException;
  message = other74.message;
  __isset = other74.__isset;
  return *this;
}
void CuratorException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CuratorException(";
  out << "type=" << to_string(type);
  out << ", " << "zooKeeperException=" << to_string(zooKeeperException);
  out << ", " << "nodeException=" << to_string(nodeException);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* CuratorException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: CuratorException";
  }
}


DiscoveryInstance::~DiscoveryInstance() throw() {
}


void DiscoveryInstance::__set_name(const std::string& val) {
  this->name = val;
}

void DiscoveryInstance::__set_id(const std::string& val) {
  this->id = val;
}

void DiscoveryInstance::__set_address(const std::string& val) {
  this->address = val;
}

void DiscoveryInstance::__set_port(const int32_t val) {
  this->port = val;
}

void DiscoveryInstance::__set_sslPort(const int32_t val) {
  this->sslPort = val;
}

void DiscoveryInstance::__set_payload(const std::string& val) {
  this->payload = val;
}

void DiscoveryInstance::__set_registrationTimeUTC(const int64_t val) {
  this->registrationTimeUTC = val;
}

void DiscoveryInstance::__set_serviceType(const DiscoveryInstanceType::type val) {
  this->serviceType = val;
}

void DiscoveryInstance::__set_uriSpec(const std::string& val) {
  this->uriSpec = val;
}

uint32_t DiscoveryInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->address);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sslPort);
          this->__isset.sslPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->registrationTimeUTC);
          this->__isset.registrationTimeUTC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast75;
          xfer += iprot->readI32(ecast75);
          this->serviceType = (DiscoveryInstanceType::type)ecast75;
          this->__isset.serviceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uriSpec);
          this->__isset.uriSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiscoveryInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiscoveryInstance");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sslPort", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sslPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("registrationTimeUTC", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->registrationTimeUTC);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serviceType", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->serviceType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uriSpec", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->uriSpec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiscoveryInstance &a, DiscoveryInstance &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.id, b.id);
  swap(a.address, b.address);
  swap(a.port, b.port);
  swap(a.sslPort, b.sslPort);
  swap(a.payload, b.payload);
  swap(a.registrationTimeUTC, b.registrationTimeUTC);
  swap(a.serviceType, b.serviceType);
  swap(a.uriSpec, b.uriSpec);
  swap(a.__isset, b.__isset);
}

DiscoveryInstance::DiscoveryInstance(const DiscoveryInstance& other76) {
  name = other76.name;
  id = other76.id;
  address = other76.address;
  port = other76.port;
  sslPort = other76.sslPort;
  payload = other76.payload;
  registrationTimeUTC = other76.registrationTimeUTC;
  serviceType = other76.serviceType;
  uriSpec = other76.uriSpec;
  __isset = other76.__isset;
}
DiscoveryInstance& DiscoveryInstance::operator=(const DiscoveryInstance& other77) {
  name = other77.name;
  id = other77.id;
  address = other77.address;
  port = other77.port;
  sslPort = other77.sslPort;
  payload = other77.payload;
  registrationTimeUTC = other77.registrationTimeUTC;
  serviceType = other77.serviceType;
  uriSpec = other77.uriSpec;
  __isset = other77.__isset;
  return *this;
}
void DiscoveryInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiscoveryInstance(";
  out << "name=" << to_string(name);
  out << ", " << "id=" << to_string(id);
  out << ", " << "address=" << to_string(address);
  out << ", " << "port=" << to_string(port);
  out << ", " << "sslPort=" << to_string(sslPort);
  out << ", " << "payload=" << to_string(payload);
  out << ", " << "registrationTimeUTC=" << to_string(registrationTimeUTC);
  out << ", " << "serviceType=" << to_string(serviceType);
  out << ", " << "uriSpec=" << to_string(uriSpec);
  out << ")";
}


CuratorEvent::~CuratorEvent() throw() {
}


void CuratorEvent::__set_type(const CuratorEventType::type val) {
  this->type = val;
}

void CuratorEvent::__set_resultCode(const int32_t val) {
  this->resultCode = val;
}

void CuratorEvent::__set_path(const std::string& val) {
  this->path = val;
}

void CuratorEvent::__set_context(const std::string& val) {
  this->context = val;
}

void CuratorEvent::__set_stat(const Stat& val) {
  this->stat = val;
}

void CuratorEvent::__set_data(const std::string& val) {
  this->data = val;
}

void CuratorEvent::__set_name(const std::string& val) {
  this->name = val;
}

void CuratorEvent::__set_children(const std::vector<std::string> & val) {
  this->children = val;
}

void CuratorEvent::__set_aclList(const std::vector<Acl> & val) {
  this->aclList = val;
}

void CuratorEvent::__set_watchedEvent(const WatchedEvent& val) {
  this->watchedEvent = val;
}

void CuratorEvent::__set_leaderEvent(const LeaderEvent& val) {
  this->leaderEvent = val;
}

void CuratorEvent::__set_childrenCacheEvent(const PathChildrenCacheEvent& val) {
  this->childrenCacheEvent = val;
}

uint32_t CuratorEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast78;
          xfer += iprot->readI32(ecast78);
          this->type = (CuratorEventType::type)ecast78;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->resultCode);
          this->__isset.resultCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->context);
          this->__isset.context = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stat.read(iprot);
          this->__isset.stat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->children.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->children.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += iprot->readString(this->children[_i83]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aclList.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->aclList.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->aclList[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aclList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->watchedEvent.read(iprot);
          this->__isset.watchedEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->leaderEvent.read(iprot);
          this->__isset.leaderEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->childrenCacheEvent.read(iprot);
          this->__isset.childrenCacheEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CuratorEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CuratorEvent");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultCode", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->resultCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("context", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->context);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stat", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->stat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("children", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->children.size()));
    std::vector<std::string> ::const_iterator _iter89;
    for (_iter89 = this->children.begin(); _iter89 != this->children.end(); ++_iter89)
    {
      xfer += oprot->writeString((*_iter89));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aclList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aclList.size()));
    std::vector<Acl> ::const_iterator _iter90;
    for (_iter90 = this->aclList.begin(); _iter90 != this->aclList.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("watchedEvent", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->watchedEvent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leaderEvent", ::apache::thrift::protocol::T_STRUCT, 12);
  xfer += this->leaderEvent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("childrenCacheEvent", ::apache::thrift::protocol::T_STRUCT, 13);
  xfer += this->childrenCacheEvent.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CuratorEvent &a, CuratorEvent &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.resultCode, b.resultCode);
  swap(a.path, b.path);
  swap(a.context, b.context);
  swap(a.stat, b.stat);
  swap(a.data, b.data);
  swap(a.name, b.name);
  swap(a.children, b.children);
  swap(a.aclList, b.aclList);
  swap(a.watchedEvent, b.watchedEvent);
  swap(a.leaderEvent, b.leaderEvent);
  swap(a.childrenCacheEvent, b.childrenCacheEvent);
  swap(a.__isset, b.__isset);
}

CuratorEvent::CuratorEvent(const CuratorEvent& other91) {
  type = other91.type;
  resultCode = other91.resultCode;
  path = other91.path;
  context = other91.context;
  stat = other91.stat;
  data = other91.data;
  name = other91.name;
  children = other91.children;
  aclList = other91.aclList;
  watchedEvent = other91.watchedEvent;
  leaderEvent = other91.leaderEvent;
  childrenCacheEvent = other91.childrenCacheEvent;
  __isset = other91.__isset;
}
CuratorEvent& CuratorEvent::operator=(const CuratorEvent& other92) {
  type = other92.type;
  resultCode = other92.resultCode;
  path = other92.path;
  context = other92.context;
  stat = other92.stat;
  data = other92.data;
  name = other92.name;
  children = other92.children;
  aclList = other92.aclList;
  watchedEvent = other92.watchedEvent;
  leaderEvent = other92.leaderEvent;
  childrenCacheEvent = other92.childrenCacheEvent;
  __isset = other92.__isset;
  return *this;
}
void CuratorEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CuratorEvent(";
  out << "type=" << to_string(type);
  out << ", " << "resultCode=" << to_string(resultCode);
  out << ", " << "path=" << to_string(path);
  out << ", " << "context=" << to_string(context);
  out << ", " << "stat=" << to_string(stat);
  out << ", " << "data=" << to_string(data);
  out << ", " << "name=" << to_string(name);
  out << ", " << "children=" << to_string(children);
  out << ", " << "aclList=" << to_string(aclList);
  out << ", " << "watchedEvent=" << to_string(watchedEvent);
  out << ", " << "leaderEvent=" << to_string(leaderEvent);
  out << ", " << "childrenCacheEvent=" << to_string(childrenCacheEvent);
  out << ")";
}

} // namespace
