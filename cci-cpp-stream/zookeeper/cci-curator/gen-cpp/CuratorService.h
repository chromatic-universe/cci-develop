/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CuratorService_H
#define CuratorService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "curator_types.h"

namespace shared {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance
#endif

class CuratorServiceIf {
 public:
  virtual ~CuratorServiceIf() {}
  virtual void acquireLock(OptionalLockProjection& _return, const CuratorProjection& projection, const std::string& path, const int32_t maxWaitMs) = 0;
  virtual void acquireSemaphore(std::vector<LeaseProjection> & _return, const CuratorProjection& projection, const std::string& path, const int32_t acquireQty, const int32_t maxWaitMs, const int32_t maxLeases) = 0;
  virtual void closeCuratorProjection(const CuratorProjection& projection) = 0;
  virtual bool closeGenericProjection(const CuratorProjection& projection, const std::string& id) = 0;
  virtual void createNode(OptionalPath& _return, const CuratorProjection& projection, const CreateSpec& spec) = 0;
  virtual void deleteNode(const CuratorProjection& projection, const DeleteSpec& spec) = 0;
  virtual void exists(OptionalStat& _return, const CuratorProjection& projection, const ExistsSpec& spec) = 0;
  virtual void getChildren(OptionalChildrenList& _return, const CuratorProjection& projection, const GetChildrenSpec& spec) = 0;
  virtual void getData(OptionalData& _return, const CuratorProjection& projection, const GetDataSpec& spec) = 0;
  virtual void getLeaderParticipants(std::vector<Participant> & _return, const CuratorProjection& projection, const LeaderProjection& leaderProjection) = 0;
  virtual void getNodeCacheData(ChildData& _return, const CuratorProjection& projection, const NodeCacheProjection& cacheProjection) = 0;
  virtual void getPathChildrenCacheData(std::vector<ChildData> & _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection) = 0;
  virtual void getPathChildrenCacheDataForPath(ChildData& _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection, const std::string& path) = 0;
  virtual bool isLeader(const CuratorProjection& projection, const LeaderProjection& leaderProjection) = 0;
  virtual void newCuratorProjection(CuratorProjection& _return, const std::string& connectionName) = 0;
  virtual void pingCuratorProjection(const CuratorProjection& projection) = 0;
  virtual void setData(OptionalStat& _return, const CuratorProjection& projection, const SetDataSpec& spec) = 0;
  virtual void startLeaderSelector(LeaderResult& _return, const CuratorProjection& projection, const std::string& path, const std::string& participantId, const int32_t waitForLeadershipMs) = 0;
  virtual void startNodeCache(NodeCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool dataIsCompressed, const bool buildInitial) = 0;
  virtual void startPathChildrenCache(PathChildrenCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool cacheData, const bool dataIsCompressed, const PathChildrenCacheStartMode::type startMode) = 0;
  virtual void startPersistentEphemeralNode(PersistentEphemeralNodeProjection& _return, const CuratorProjection& projection, const std::string& path, const std::string& data, const PersistentEphemeralNodeMode::type mode) = 0;
  virtual void sync(const CuratorProjection& projection, const std::string& path, const std::string& asyncContext) = 0;
};

class CuratorServiceIfFactory {
 public:
  typedef CuratorServiceIf Handler;

  virtual ~CuratorServiceIfFactory() {}

  virtual CuratorServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(CuratorServiceIf* /* handler */) = 0;
};

class CuratorServiceIfSingletonFactory : virtual public CuratorServiceIfFactory {
 public:
  CuratorServiceIfSingletonFactory(const boost::shared_ptr<CuratorServiceIf>& iface) : iface_(iface) {}
  virtual ~CuratorServiceIfSingletonFactory() {}

  virtual CuratorServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(CuratorServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<CuratorServiceIf> iface_;
};

class CuratorServiceNull : virtual public CuratorServiceIf {
 public:
  virtual ~CuratorServiceNull() {}
  void acquireLock(OptionalLockProjection& /* _return */, const CuratorProjection& /* projection */, const std::string& /* path */, const int32_t /* maxWaitMs */) {
    return;
  }
  void acquireSemaphore(std::vector<LeaseProjection> & /* _return */, const CuratorProjection& /* projection */, const std::string& /* path */, const int32_t /* acquireQty */, const int32_t /* maxWaitMs */, const int32_t /* maxLeases */) {
    return;
  }
  void closeCuratorProjection(const CuratorProjection& /* projection */) {
    return;
  }
  bool closeGenericProjection(const CuratorProjection& /* projection */, const std::string& /* id */) {
    bool _return = false;
    return _return;
  }
  void createNode(OptionalPath& /* _return */, const CuratorProjection& /* projection */, const CreateSpec& /* spec */) {
    return;
  }
  void deleteNode(const CuratorProjection& /* projection */, const DeleteSpec& /* spec */) {
    return;
  }
  void exists(OptionalStat& /* _return */, const CuratorProjection& /* projection */, const ExistsSpec& /* spec */) {
    return;
  }
  void getChildren(OptionalChildrenList& /* _return */, const CuratorProjection& /* projection */, const GetChildrenSpec& /* spec */) {
    return;
  }
  void getData(OptionalData& /* _return */, const CuratorProjection& /* projection */, const GetDataSpec& /* spec */) {
    return;
  }
  void getLeaderParticipants(std::vector<Participant> & /* _return */, const CuratorProjection& /* projection */, const LeaderProjection& /* leaderProjection */) {
    return;
  }
  void getNodeCacheData(ChildData& /* _return */, const CuratorProjection& /* projection */, const NodeCacheProjection& /* cacheProjection */) {
    return;
  }
  void getPathChildrenCacheData(std::vector<ChildData> & /* _return */, const CuratorProjection& /* projection */, const PathChildrenCacheProjection& /* cacheProjection */) {
    return;
  }
  void getPathChildrenCacheDataForPath(ChildData& /* _return */, const CuratorProjection& /* projection */, const PathChildrenCacheProjection& /* cacheProjection */, const std::string& /* path */) {
    return;
  }
  bool isLeader(const CuratorProjection& /* projection */, const LeaderProjection& /* leaderProjection */) {
    bool _return = false;
    return _return;
  }
  void newCuratorProjection(CuratorProjection& /* _return */, const std::string& /* connectionName */) {
    return;
  }
  void pingCuratorProjection(const CuratorProjection& /* projection */) {
    return;
  }
  void setData(OptionalStat& /* _return */, const CuratorProjection& /* projection */, const SetDataSpec& /* spec */) {
    return;
  }
  void startLeaderSelector(LeaderResult& /* _return */, const CuratorProjection& /* projection */, const std::string& /* path */, const std::string& /* participantId */, const int32_t /* waitForLeadershipMs */) {
    return;
  }
  void startNodeCache(NodeCacheProjection& /* _return */, const CuratorProjection& /* projection */, const std::string& /* path */, const bool /* dataIsCompressed */, const bool /* buildInitial */) {
    return;
  }
  void startPathChildrenCache(PathChildrenCacheProjection& /* _return */, const CuratorProjection& /* projection */, const std::string& /* path */, const bool /* cacheData */, const bool /* dataIsCompressed */, const PathChildrenCacheStartMode::type /* startMode */) {
    return;
  }
  void startPersistentEphemeralNode(PersistentEphemeralNodeProjection& /* _return */, const CuratorProjection& /* projection */, const std::string& /* path */, const std::string& /* data */, const PersistentEphemeralNodeMode::type /* mode */) {
    return;
  }
  void sync(const CuratorProjection& /* projection */, const std::string& /* path */, const std::string& /* asyncContext */) {
    return;
  }
};

typedef struct _CuratorService_acquireLock_args__isset {
  _CuratorService_acquireLock_args__isset() : projection(false), path(false), maxWaitMs(false) {}
  bool projection :1;
  bool path :1;
  bool maxWaitMs :1;
} _CuratorService_acquireLock_args__isset;

class CuratorService_acquireLock_args {
 public:

  CuratorService_acquireLock_args(const CuratorService_acquireLock_args&);
  CuratorService_acquireLock_args& operator=(const CuratorService_acquireLock_args&);
  CuratorService_acquireLock_args() : path(), maxWaitMs(0) {
  }

  virtual ~CuratorService_acquireLock_args() throw();
  CuratorProjection projection;
  std::string path;
  int32_t maxWaitMs;

  _CuratorService_acquireLock_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_path(const std::string& val);

  void __set_maxWaitMs(const int32_t val);

  bool operator == (const CuratorService_acquireLock_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(maxWaitMs == rhs.maxWaitMs))
      return false;
    return true;
  }
  bool operator != (const CuratorService_acquireLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_acquireLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_acquireLock_pargs {
 public:


  virtual ~CuratorService_acquireLock_pargs() throw();
  const CuratorProjection* projection;
  const std::string* path;
  const int32_t* maxWaitMs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_acquireLock_result__isset {
  _CuratorService_acquireLock_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_acquireLock_result__isset;

class CuratorService_acquireLock_result {
 public:

  CuratorService_acquireLock_result(const CuratorService_acquireLock_result&);
  CuratorService_acquireLock_result& operator=(const CuratorService_acquireLock_result&);
  CuratorService_acquireLock_result() {
  }

  virtual ~CuratorService_acquireLock_result() throw();
  OptionalLockProjection success;
  CuratorException ex1;

  _CuratorService_acquireLock_result__isset __isset;

  void __set_success(const OptionalLockProjection& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_acquireLock_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_acquireLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_acquireLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_acquireLock_presult__isset {
  _CuratorService_acquireLock_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_acquireLock_presult__isset;

class CuratorService_acquireLock_presult {
 public:


  virtual ~CuratorService_acquireLock_presult() throw();
  OptionalLockProjection* success;
  CuratorException ex1;

  _CuratorService_acquireLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_acquireSemaphore_args__isset {
  _CuratorService_acquireSemaphore_args__isset() : projection(false), path(false), acquireQty(false), maxWaitMs(false), maxLeases(false) {}
  bool projection :1;
  bool path :1;
  bool acquireQty :1;
  bool maxWaitMs :1;
  bool maxLeases :1;
} _CuratorService_acquireSemaphore_args__isset;

class CuratorService_acquireSemaphore_args {
 public:

  CuratorService_acquireSemaphore_args(const CuratorService_acquireSemaphore_args&);
  CuratorService_acquireSemaphore_args& operator=(const CuratorService_acquireSemaphore_args&);
  CuratorService_acquireSemaphore_args() : path(), acquireQty(0), maxWaitMs(0), maxLeases(0) {
  }

  virtual ~CuratorService_acquireSemaphore_args() throw();
  CuratorProjection projection;
  std::string path;
  int32_t acquireQty;
  int32_t maxWaitMs;
  int32_t maxLeases;

  _CuratorService_acquireSemaphore_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_path(const std::string& val);

  void __set_acquireQty(const int32_t val);

  void __set_maxWaitMs(const int32_t val);

  void __set_maxLeases(const int32_t val);

  bool operator == (const CuratorService_acquireSemaphore_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(acquireQty == rhs.acquireQty))
      return false;
    if (!(maxWaitMs == rhs.maxWaitMs))
      return false;
    if (!(maxLeases == rhs.maxLeases))
      return false;
    return true;
  }
  bool operator != (const CuratorService_acquireSemaphore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_acquireSemaphore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_acquireSemaphore_pargs {
 public:


  virtual ~CuratorService_acquireSemaphore_pargs() throw();
  const CuratorProjection* projection;
  const std::string* path;
  const int32_t* acquireQty;
  const int32_t* maxWaitMs;
  const int32_t* maxLeases;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_acquireSemaphore_result__isset {
  _CuratorService_acquireSemaphore_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_acquireSemaphore_result__isset;

class CuratorService_acquireSemaphore_result {
 public:

  CuratorService_acquireSemaphore_result(const CuratorService_acquireSemaphore_result&);
  CuratorService_acquireSemaphore_result& operator=(const CuratorService_acquireSemaphore_result&);
  CuratorService_acquireSemaphore_result() {
  }

  virtual ~CuratorService_acquireSemaphore_result() throw();
  std::vector<LeaseProjection>  success;
  CuratorException ex1;

  _CuratorService_acquireSemaphore_result__isset __isset;

  void __set_success(const std::vector<LeaseProjection> & val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_acquireSemaphore_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_acquireSemaphore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_acquireSemaphore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_acquireSemaphore_presult__isset {
  _CuratorService_acquireSemaphore_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_acquireSemaphore_presult__isset;

class CuratorService_acquireSemaphore_presult {
 public:


  virtual ~CuratorService_acquireSemaphore_presult() throw();
  std::vector<LeaseProjection> * success;
  CuratorException ex1;

  _CuratorService_acquireSemaphore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_closeCuratorProjection_args__isset {
  _CuratorService_closeCuratorProjection_args__isset() : projection(false) {}
  bool projection :1;
} _CuratorService_closeCuratorProjection_args__isset;

class CuratorService_closeCuratorProjection_args {
 public:

  CuratorService_closeCuratorProjection_args(const CuratorService_closeCuratorProjection_args&);
  CuratorService_closeCuratorProjection_args& operator=(const CuratorService_closeCuratorProjection_args&);
  CuratorService_closeCuratorProjection_args() {
  }

  virtual ~CuratorService_closeCuratorProjection_args() throw();
  CuratorProjection projection;

  _CuratorService_closeCuratorProjection_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  bool operator == (const CuratorService_closeCuratorProjection_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    return true;
  }
  bool operator != (const CuratorService_closeCuratorProjection_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_closeCuratorProjection_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_closeCuratorProjection_pargs {
 public:


  virtual ~CuratorService_closeCuratorProjection_pargs() throw();
  const CuratorProjection* projection;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_closeCuratorProjection_result {
 public:

  CuratorService_closeCuratorProjection_result(const CuratorService_closeCuratorProjection_result&);
  CuratorService_closeCuratorProjection_result& operator=(const CuratorService_closeCuratorProjection_result&);
  CuratorService_closeCuratorProjection_result() {
  }

  virtual ~CuratorService_closeCuratorProjection_result() throw();

  bool operator == (const CuratorService_closeCuratorProjection_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const CuratorService_closeCuratorProjection_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_closeCuratorProjection_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_closeCuratorProjection_presult {
 public:


  virtual ~CuratorService_closeCuratorProjection_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_closeGenericProjection_args__isset {
  _CuratorService_closeGenericProjection_args__isset() : projection(false), id(false) {}
  bool projection :1;
  bool id :1;
} _CuratorService_closeGenericProjection_args__isset;

class CuratorService_closeGenericProjection_args {
 public:

  CuratorService_closeGenericProjection_args(const CuratorService_closeGenericProjection_args&);
  CuratorService_closeGenericProjection_args& operator=(const CuratorService_closeGenericProjection_args&);
  CuratorService_closeGenericProjection_args() : id() {
  }

  virtual ~CuratorService_closeGenericProjection_args() throw();
  CuratorProjection projection;
  std::string id;

  _CuratorService_closeGenericProjection_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_id(const std::string& val);

  bool operator == (const CuratorService_closeGenericProjection_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const CuratorService_closeGenericProjection_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_closeGenericProjection_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_closeGenericProjection_pargs {
 public:


  virtual ~CuratorService_closeGenericProjection_pargs() throw();
  const CuratorProjection* projection;
  const std::string* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_closeGenericProjection_result__isset {
  _CuratorService_closeGenericProjection_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_closeGenericProjection_result__isset;

class CuratorService_closeGenericProjection_result {
 public:

  CuratorService_closeGenericProjection_result(const CuratorService_closeGenericProjection_result&);
  CuratorService_closeGenericProjection_result& operator=(const CuratorService_closeGenericProjection_result&);
  CuratorService_closeGenericProjection_result() : success(0) {
  }

  virtual ~CuratorService_closeGenericProjection_result() throw();
  bool success;
  CuratorException ex1;

  _CuratorService_closeGenericProjection_result__isset __isset;

  void __set_success(const bool val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_closeGenericProjection_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_closeGenericProjection_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_closeGenericProjection_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_closeGenericProjection_presult__isset {
  _CuratorService_closeGenericProjection_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_closeGenericProjection_presult__isset;

class CuratorService_closeGenericProjection_presult {
 public:


  virtual ~CuratorService_closeGenericProjection_presult() throw();
  bool* success;
  CuratorException ex1;

  _CuratorService_closeGenericProjection_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_createNode_args__isset {
  _CuratorService_createNode_args__isset() : projection(false), spec(false) {}
  bool projection :1;
  bool spec :1;
} _CuratorService_createNode_args__isset;

class CuratorService_createNode_args {
 public:

  CuratorService_createNode_args(const CuratorService_createNode_args&);
  CuratorService_createNode_args& operator=(const CuratorService_createNode_args&);
  CuratorService_createNode_args() {
  }

  virtual ~CuratorService_createNode_args() throw();
  CuratorProjection projection;
  CreateSpec spec;

  _CuratorService_createNode_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_spec(const CreateSpec& val);

  bool operator == (const CuratorService_createNode_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(spec == rhs.spec))
      return false;
    return true;
  }
  bool operator != (const CuratorService_createNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_createNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_createNode_pargs {
 public:


  virtual ~CuratorService_createNode_pargs() throw();
  const CuratorProjection* projection;
  const CreateSpec* spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_createNode_result__isset {
  _CuratorService_createNode_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_createNode_result__isset;

class CuratorService_createNode_result {
 public:

  CuratorService_createNode_result(const CuratorService_createNode_result&);
  CuratorService_createNode_result& operator=(const CuratorService_createNode_result&);
  CuratorService_createNode_result() {
  }

  virtual ~CuratorService_createNode_result() throw();
  OptionalPath success;
  CuratorException ex1;

  _CuratorService_createNode_result__isset __isset;

  void __set_success(const OptionalPath& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_createNode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_createNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_createNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_createNode_presult__isset {
  _CuratorService_createNode_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_createNode_presult__isset;

class CuratorService_createNode_presult {
 public:


  virtual ~CuratorService_createNode_presult() throw();
  OptionalPath* success;
  CuratorException ex1;

  _CuratorService_createNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_deleteNode_args__isset {
  _CuratorService_deleteNode_args__isset() : projection(false), spec(false) {}
  bool projection :1;
  bool spec :1;
} _CuratorService_deleteNode_args__isset;

class CuratorService_deleteNode_args {
 public:

  CuratorService_deleteNode_args(const CuratorService_deleteNode_args&);
  CuratorService_deleteNode_args& operator=(const CuratorService_deleteNode_args&);
  CuratorService_deleteNode_args() {
  }

  virtual ~CuratorService_deleteNode_args() throw();
  CuratorProjection projection;
  DeleteSpec spec;

  _CuratorService_deleteNode_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_spec(const DeleteSpec& val);

  bool operator == (const CuratorService_deleteNode_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(spec == rhs.spec))
      return false;
    return true;
  }
  bool operator != (const CuratorService_deleteNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_deleteNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_deleteNode_pargs {
 public:


  virtual ~CuratorService_deleteNode_pargs() throw();
  const CuratorProjection* projection;
  const DeleteSpec* spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_deleteNode_result__isset {
  _CuratorService_deleteNode_result__isset() : ex1(false) {}
  bool ex1 :1;
} _CuratorService_deleteNode_result__isset;

class CuratorService_deleteNode_result {
 public:

  CuratorService_deleteNode_result(const CuratorService_deleteNode_result&);
  CuratorService_deleteNode_result& operator=(const CuratorService_deleteNode_result&);
  CuratorService_deleteNode_result() {
  }

  virtual ~CuratorService_deleteNode_result() throw();
  CuratorException ex1;

  _CuratorService_deleteNode_result__isset __isset;

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_deleteNode_result & rhs) const
  {
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_deleteNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_deleteNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_deleteNode_presult__isset {
  _CuratorService_deleteNode_presult__isset() : ex1(false) {}
  bool ex1 :1;
} _CuratorService_deleteNode_presult__isset;

class CuratorService_deleteNode_presult {
 public:


  virtual ~CuratorService_deleteNode_presult() throw();
  CuratorException ex1;

  _CuratorService_deleteNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_exists_args__isset {
  _CuratorService_exists_args__isset() : projection(false), spec(false) {}
  bool projection :1;
  bool spec :1;
} _CuratorService_exists_args__isset;

class CuratorService_exists_args {
 public:

  CuratorService_exists_args(const CuratorService_exists_args&);
  CuratorService_exists_args& operator=(const CuratorService_exists_args&);
  CuratorService_exists_args() {
  }

  virtual ~CuratorService_exists_args() throw();
  CuratorProjection projection;
  ExistsSpec spec;

  _CuratorService_exists_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_spec(const ExistsSpec& val);

  bool operator == (const CuratorService_exists_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(spec == rhs.spec))
      return false;
    return true;
  }
  bool operator != (const CuratorService_exists_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_exists_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_exists_pargs {
 public:


  virtual ~CuratorService_exists_pargs() throw();
  const CuratorProjection* projection;
  const ExistsSpec* spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_exists_result__isset {
  _CuratorService_exists_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_exists_result__isset;

class CuratorService_exists_result {
 public:

  CuratorService_exists_result(const CuratorService_exists_result&);
  CuratorService_exists_result& operator=(const CuratorService_exists_result&);
  CuratorService_exists_result() {
  }

  virtual ~CuratorService_exists_result() throw();
  OptionalStat success;
  CuratorException ex1;

  _CuratorService_exists_result__isset __isset;

  void __set_success(const OptionalStat& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_exists_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_exists_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_exists_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_exists_presult__isset {
  _CuratorService_exists_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_exists_presult__isset;

class CuratorService_exists_presult {
 public:


  virtual ~CuratorService_exists_presult() throw();
  OptionalStat* success;
  CuratorException ex1;

  _CuratorService_exists_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_getChildren_args__isset {
  _CuratorService_getChildren_args__isset() : projection(false), spec(false) {}
  bool projection :1;
  bool spec :1;
} _CuratorService_getChildren_args__isset;

class CuratorService_getChildren_args {
 public:

  CuratorService_getChildren_args(const CuratorService_getChildren_args&);
  CuratorService_getChildren_args& operator=(const CuratorService_getChildren_args&);
  CuratorService_getChildren_args() {
  }

  virtual ~CuratorService_getChildren_args() throw();
  CuratorProjection projection;
  GetChildrenSpec spec;

  _CuratorService_getChildren_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_spec(const GetChildrenSpec& val);

  bool operator == (const CuratorService_getChildren_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(spec == rhs.spec))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getChildren_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getChildren_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_getChildren_pargs {
 public:


  virtual ~CuratorService_getChildren_pargs() throw();
  const CuratorProjection* projection;
  const GetChildrenSpec* spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getChildren_result__isset {
  _CuratorService_getChildren_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getChildren_result__isset;

class CuratorService_getChildren_result {
 public:

  CuratorService_getChildren_result(const CuratorService_getChildren_result&);
  CuratorService_getChildren_result& operator=(const CuratorService_getChildren_result&);
  CuratorService_getChildren_result() {
  }

  virtual ~CuratorService_getChildren_result() throw();
  OptionalChildrenList success;
  CuratorException ex1;

  _CuratorService_getChildren_result__isset __isset;

  void __set_success(const OptionalChildrenList& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_getChildren_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getChildren_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getChildren_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getChildren_presult__isset {
  _CuratorService_getChildren_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getChildren_presult__isset;

class CuratorService_getChildren_presult {
 public:


  virtual ~CuratorService_getChildren_presult() throw();
  OptionalChildrenList* success;
  CuratorException ex1;

  _CuratorService_getChildren_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_getData_args__isset {
  _CuratorService_getData_args__isset() : projection(false), spec(false) {}
  bool projection :1;
  bool spec :1;
} _CuratorService_getData_args__isset;

class CuratorService_getData_args {
 public:

  CuratorService_getData_args(const CuratorService_getData_args&);
  CuratorService_getData_args& operator=(const CuratorService_getData_args&);
  CuratorService_getData_args() {
  }

  virtual ~CuratorService_getData_args() throw();
  CuratorProjection projection;
  GetDataSpec spec;

  _CuratorService_getData_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_spec(const GetDataSpec& val);

  bool operator == (const CuratorService_getData_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(spec == rhs.spec))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_getData_pargs {
 public:


  virtual ~CuratorService_getData_pargs() throw();
  const CuratorProjection* projection;
  const GetDataSpec* spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getData_result__isset {
  _CuratorService_getData_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getData_result__isset;

class CuratorService_getData_result {
 public:

  CuratorService_getData_result(const CuratorService_getData_result&);
  CuratorService_getData_result& operator=(const CuratorService_getData_result&);
  CuratorService_getData_result() {
  }

  virtual ~CuratorService_getData_result() throw();
  OptionalData success;
  CuratorException ex1;

  _CuratorService_getData_result__isset __isset;

  void __set_success(const OptionalData& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_getData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getData_presult__isset {
  _CuratorService_getData_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getData_presult__isset;

class CuratorService_getData_presult {
 public:


  virtual ~CuratorService_getData_presult() throw();
  OptionalData* success;
  CuratorException ex1;

  _CuratorService_getData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_getLeaderParticipants_args__isset {
  _CuratorService_getLeaderParticipants_args__isset() : projection(false), leaderProjection(false) {}
  bool projection :1;
  bool leaderProjection :1;
} _CuratorService_getLeaderParticipants_args__isset;

class CuratorService_getLeaderParticipants_args {
 public:

  CuratorService_getLeaderParticipants_args(const CuratorService_getLeaderParticipants_args&);
  CuratorService_getLeaderParticipants_args& operator=(const CuratorService_getLeaderParticipants_args&);
  CuratorService_getLeaderParticipants_args() {
  }

  virtual ~CuratorService_getLeaderParticipants_args() throw();
  CuratorProjection projection;
  LeaderProjection leaderProjection;

  _CuratorService_getLeaderParticipants_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_leaderProjection(const LeaderProjection& val);

  bool operator == (const CuratorService_getLeaderParticipants_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(leaderProjection == rhs.leaderProjection))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getLeaderParticipants_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getLeaderParticipants_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_getLeaderParticipants_pargs {
 public:


  virtual ~CuratorService_getLeaderParticipants_pargs() throw();
  const CuratorProjection* projection;
  const LeaderProjection* leaderProjection;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getLeaderParticipants_result__isset {
  _CuratorService_getLeaderParticipants_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getLeaderParticipants_result__isset;

class CuratorService_getLeaderParticipants_result {
 public:

  CuratorService_getLeaderParticipants_result(const CuratorService_getLeaderParticipants_result&);
  CuratorService_getLeaderParticipants_result& operator=(const CuratorService_getLeaderParticipants_result&);
  CuratorService_getLeaderParticipants_result() {
  }

  virtual ~CuratorService_getLeaderParticipants_result() throw();
  std::vector<Participant>  success;
  CuratorException ex1;

  _CuratorService_getLeaderParticipants_result__isset __isset;

  void __set_success(const std::vector<Participant> & val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_getLeaderParticipants_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getLeaderParticipants_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getLeaderParticipants_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getLeaderParticipants_presult__isset {
  _CuratorService_getLeaderParticipants_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getLeaderParticipants_presult__isset;

class CuratorService_getLeaderParticipants_presult {
 public:


  virtual ~CuratorService_getLeaderParticipants_presult() throw();
  std::vector<Participant> * success;
  CuratorException ex1;

  _CuratorService_getLeaderParticipants_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_getNodeCacheData_args__isset {
  _CuratorService_getNodeCacheData_args__isset() : projection(false), cacheProjection(false) {}
  bool projection :1;
  bool cacheProjection :1;
} _CuratorService_getNodeCacheData_args__isset;

class CuratorService_getNodeCacheData_args {
 public:

  CuratorService_getNodeCacheData_args(const CuratorService_getNodeCacheData_args&);
  CuratorService_getNodeCacheData_args& operator=(const CuratorService_getNodeCacheData_args&);
  CuratorService_getNodeCacheData_args() {
  }

  virtual ~CuratorService_getNodeCacheData_args() throw();
  CuratorProjection projection;
  NodeCacheProjection cacheProjection;

  _CuratorService_getNodeCacheData_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_cacheProjection(const NodeCacheProjection& val);

  bool operator == (const CuratorService_getNodeCacheData_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(cacheProjection == rhs.cacheProjection))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getNodeCacheData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getNodeCacheData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_getNodeCacheData_pargs {
 public:


  virtual ~CuratorService_getNodeCacheData_pargs() throw();
  const CuratorProjection* projection;
  const NodeCacheProjection* cacheProjection;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getNodeCacheData_result__isset {
  _CuratorService_getNodeCacheData_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getNodeCacheData_result__isset;

class CuratorService_getNodeCacheData_result {
 public:

  CuratorService_getNodeCacheData_result(const CuratorService_getNodeCacheData_result&);
  CuratorService_getNodeCacheData_result& operator=(const CuratorService_getNodeCacheData_result&);
  CuratorService_getNodeCacheData_result() {
  }

  virtual ~CuratorService_getNodeCacheData_result() throw();
  ChildData success;
  CuratorException ex1;

  _CuratorService_getNodeCacheData_result__isset __isset;

  void __set_success(const ChildData& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_getNodeCacheData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getNodeCacheData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getNodeCacheData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getNodeCacheData_presult__isset {
  _CuratorService_getNodeCacheData_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getNodeCacheData_presult__isset;

class CuratorService_getNodeCacheData_presult {
 public:


  virtual ~CuratorService_getNodeCacheData_presult() throw();
  ChildData* success;
  CuratorException ex1;

  _CuratorService_getNodeCacheData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_getPathChildrenCacheData_args__isset {
  _CuratorService_getPathChildrenCacheData_args__isset() : projection(false), cacheProjection(false) {}
  bool projection :1;
  bool cacheProjection :1;
} _CuratorService_getPathChildrenCacheData_args__isset;

class CuratorService_getPathChildrenCacheData_args {
 public:

  CuratorService_getPathChildrenCacheData_args(const CuratorService_getPathChildrenCacheData_args&);
  CuratorService_getPathChildrenCacheData_args& operator=(const CuratorService_getPathChildrenCacheData_args&);
  CuratorService_getPathChildrenCacheData_args() {
  }

  virtual ~CuratorService_getPathChildrenCacheData_args() throw();
  CuratorProjection projection;
  PathChildrenCacheProjection cacheProjection;

  _CuratorService_getPathChildrenCacheData_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_cacheProjection(const PathChildrenCacheProjection& val);

  bool operator == (const CuratorService_getPathChildrenCacheData_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(cacheProjection == rhs.cacheProjection))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getPathChildrenCacheData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getPathChildrenCacheData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_getPathChildrenCacheData_pargs {
 public:


  virtual ~CuratorService_getPathChildrenCacheData_pargs() throw();
  const CuratorProjection* projection;
  const PathChildrenCacheProjection* cacheProjection;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getPathChildrenCacheData_result__isset {
  _CuratorService_getPathChildrenCacheData_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getPathChildrenCacheData_result__isset;

class CuratorService_getPathChildrenCacheData_result {
 public:

  CuratorService_getPathChildrenCacheData_result(const CuratorService_getPathChildrenCacheData_result&);
  CuratorService_getPathChildrenCacheData_result& operator=(const CuratorService_getPathChildrenCacheData_result&);
  CuratorService_getPathChildrenCacheData_result() {
  }

  virtual ~CuratorService_getPathChildrenCacheData_result() throw();
  std::vector<ChildData>  success;
  CuratorException ex1;

  _CuratorService_getPathChildrenCacheData_result__isset __isset;

  void __set_success(const std::vector<ChildData> & val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_getPathChildrenCacheData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getPathChildrenCacheData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getPathChildrenCacheData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getPathChildrenCacheData_presult__isset {
  _CuratorService_getPathChildrenCacheData_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getPathChildrenCacheData_presult__isset;

class CuratorService_getPathChildrenCacheData_presult {
 public:


  virtual ~CuratorService_getPathChildrenCacheData_presult() throw();
  std::vector<ChildData> * success;
  CuratorException ex1;

  _CuratorService_getPathChildrenCacheData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_getPathChildrenCacheDataForPath_args__isset {
  _CuratorService_getPathChildrenCacheDataForPath_args__isset() : projection(false), cacheProjection(false), path(false) {}
  bool projection :1;
  bool cacheProjection :1;
  bool path :1;
} _CuratorService_getPathChildrenCacheDataForPath_args__isset;

class CuratorService_getPathChildrenCacheDataForPath_args {
 public:

  CuratorService_getPathChildrenCacheDataForPath_args(const CuratorService_getPathChildrenCacheDataForPath_args&);
  CuratorService_getPathChildrenCacheDataForPath_args& operator=(const CuratorService_getPathChildrenCacheDataForPath_args&);
  CuratorService_getPathChildrenCacheDataForPath_args() : path() {
  }

  virtual ~CuratorService_getPathChildrenCacheDataForPath_args() throw();
  CuratorProjection projection;
  PathChildrenCacheProjection cacheProjection;
  std::string path;

  _CuratorService_getPathChildrenCacheDataForPath_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_cacheProjection(const PathChildrenCacheProjection& val);

  void __set_path(const std::string& val);

  bool operator == (const CuratorService_getPathChildrenCacheDataForPath_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(cacheProjection == rhs.cacheProjection))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getPathChildrenCacheDataForPath_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getPathChildrenCacheDataForPath_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_getPathChildrenCacheDataForPath_pargs {
 public:


  virtual ~CuratorService_getPathChildrenCacheDataForPath_pargs() throw();
  const CuratorProjection* projection;
  const PathChildrenCacheProjection* cacheProjection;
  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getPathChildrenCacheDataForPath_result__isset {
  _CuratorService_getPathChildrenCacheDataForPath_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getPathChildrenCacheDataForPath_result__isset;

class CuratorService_getPathChildrenCacheDataForPath_result {
 public:

  CuratorService_getPathChildrenCacheDataForPath_result(const CuratorService_getPathChildrenCacheDataForPath_result&);
  CuratorService_getPathChildrenCacheDataForPath_result& operator=(const CuratorService_getPathChildrenCacheDataForPath_result&);
  CuratorService_getPathChildrenCacheDataForPath_result() {
  }

  virtual ~CuratorService_getPathChildrenCacheDataForPath_result() throw();
  ChildData success;
  CuratorException ex1;

  _CuratorService_getPathChildrenCacheDataForPath_result__isset __isset;

  void __set_success(const ChildData& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_getPathChildrenCacheDataForPath_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_getPathChildrenCacheDataForPath_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_getPathChildrenCacheDataForPath_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_getPathChildrenCacheDataForPath_presult__isset {
  _CuratorService_getPathChildrenCacheDataForPath_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_getPathChildrenCacheDataForPath_presult__isset;

class CuratorService_getPathChildrenCacheDataForPath_presult {
 public:


  virtual ~CuratorService_getPathChildrenCacheDataForPath_presult() throw();
  ChildData* success;
  CuratorException ex1;

  _CuratorService_getPathChildrenCacheDataForPath_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_isLeader_args__isset {
  _CuratorService_isLeader_args__isset() : projection(false), leaderProjection(false) {}
  bool projection :1;
  bool leaderProjection :1;
} _CuratorService_isLeader_args__isset;

class CuratorService_isLeader_args {
 public:

  CuratorService_isLeader_args(const CuratorService_isLeader_args&);
  CuratorService_isLeader_args& operator=(const CuratorService_isLeader_args&);
  CuratorService_isLeader_args() {
  }

  virtual ~CuratorService_isLeader_args() throw();
  CuratorProjection projection;
  LeaderProjection leaderProjection;

  _CuratorService_isLeader_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_leaderProjection(const LeaderProjection& val);

  bool operator == (const CuratorService_isLeader_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(leaderProjection == rhs.leaderProjection))
      return false;
    return true;
  }
  bool operator != (const CuratorService_isLeader_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_isLeader_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_isLeader_pargs {
 public:


  virtual ~CuratorService_isLeader_pargs() throw();
  const CuratorProjection* projection;
  const LeaderProjection* leaderProjection;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_isLeader_result__isset {
  _CuratorService_isLeader_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_isLeader_result__isset;

class CuratorService_isLeader_result {
 public:

  CuratorService_isLeader_result(const CuratorService_isLeader_result&);
  CuratorService_isLeader_result& operator=(const CuratorService_isLeader_result&);
  CuratorService_isLeader_result() : success(0) {
  }

  virtual ~CuratorService_isLeader_result() throw();
  bool success;
  CuratorException ex1;

  _CuratorService_isLeader_result__isset __isset;

  void __set_success(const bool val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_isLeader_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_isLeader_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_isLeader_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_isLeader_presult__isset {
  _CuratorService_isLeader_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_isLeader_presult__isset;

class CuratorService_isLeader_presult {
 public:


  virtual ~CuratorService_isLeader_presult() throw();
  bool* success;
  CuratorException ex1;

  _CuratorService_isLeader_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_newCuratorProjection_args__isset {
  _CuratorService_newCuratorProjection_args__isset() : connectionName(false) {}
  bool connectionName :1;
} _CuratorService_newCuratorProjection_args__isset;

class CuratorService_newCuratorProjection_args {
 public:

  CuratorService_newCuratorProjection_args(const CuratorService_newCuratorProjection_args&);
  CuratorService_newCuratorProjection_args& operator=(const CuratorService_newCuratorProjection_args&);
  CuratorService_newCuratorProjection_args() : connectionName() {
  }

  virtual ~CuratorService_newCuratorProjection_args() throw();
  std::string connectionName;

  _CuratorService_newCuratorProjection_args__isset __isset;

  void __set_connectionName(const std::string& val);

  bool operator == (const CuratorService_newCuratorProjection_args & rhs) const
  {
    if (!(connectionName == rhs.connectionName))
      return false;
    return true;
  }
  bool operator != (const CuratorService_newCuratorProjection_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_newCuratorProjection_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_newCuratorProjection_pargs {
 public:


  virtual ~CuratorService_newCuratorProjection_pargs() throw();
  const std::string* connectionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_newCuratorProjection_result__isset {
  _CuratorService_newCuratorProjection_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_newCuratorProjection_result__isset;

class CuratorService_newCuratorProjection_result {
 public:

  CuratorService_newCuratorProjection_result(const CuratorService_newCuratorProjection_result&);
  CuratorService_newCuratorProjection_result& operator=(const CuratorService_newCuratorProjection_result&);
  CuratorService_newCuratorProjection_result() {
  }

  virtual ~CuratorService_newCuratorProjection_result() throw();
  CuratorProjection success;
  CuratorException ex1;

  _CuratorService_newCuratorProjection_result__isset __isset;

  void __set_success(const CuratorProjection& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_newCuratorProjection_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_newCuratorProjection_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_newCuratorProjection_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_newCuratorProjection_presult__isset {
  _CuratorService_newCuratorProjection_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_newCuratorProjection_presult__isset;

class CuratorService_newCuratorProjection_presult {
 public:


  virtual ~CuratorService_newCuratorProjection_presult() throw();
  CuratorProjection* success;
  CuratorException ex1;

  _CuratorService_newCuratorProjection_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_pingCuratorProjection_args__isset {
  _CuratorService_pingCuratorProjection_args__isset() : projection(false) {}
  bool projection :1;
} _CuratorService_pingCuratorProjection_args__isset;

class CuratorService_pingCuratorProjection_args {
 public:

  CuratorService_pingCuratorProjection_args(const CuratorService_pingCuratorProjection_args&);
  CuratorService_pingCuratorProjection_args& operator=(const CuratorService_pingCuratorProjection_args&);
  CuratorService_pingCuratorProjection_args() {
  }

  virtual ~CuratorService_pingCuratorProjection_args() throw();
  CuratorProjection projection;

  _CuratorService_pingCuratorProjection_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  bool operator == (const CuratorService_pingCuratorProjection_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    return true;
  }
  bool operator != (const CuratorService_pingCuratorProjection_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_pingCuratorProjection_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_pingCuratorProjection_pargs {
 public:


  virtual ~CuratorService_pingCuratorProjection_pargs() throw();
  const CuratorProjection* projection;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_setData_args__isset {
  _CuratorService_setData_args__isset() : projection(false), spec(false) {}
  bool projection :1;
  bool spec :1;
} _CuratorService_setData_args__isset;

class CuratorService_setData_args {
 public:

  CuratorService_setData_args(const CuratorService_setData_args&);
  CuratorService_setData_args& operator=(const CuratorService_setData_args&);
  CuratorService_setData_args() {
  }

  virtual ~CuratorService_setData_args() throw();
  CuratorProjection projection;
  SetDataSpec spec;

  _CuratorService_setData_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_spec(const SetDataSpec& val);

  bool operator == (const CuratorService_setData_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(spec == rhs.spec))
      return false;
    return true;
  }
  bool operator != (const CuratorService_setData_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_setData_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_setData_pargs {
 public:


  virtual ~CuratorService_setData_pargs() throw();
  const CuratorProjection* projection;
  const SetDataSpec* spec;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_setData_result__isset {
  _CuratorService_setData_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_setData_result__isset;

class CuratorService_setData_result {
 public:

  CuratorService_setData_result(const CuratorService_setData_result&);
  CuratorService_setData_result& operator=(const CuratorService_setData_result&);
  CuratorService_setData_result() {
  }

  virtual ~CuratorService_setData_result() throw();
  OptionalStat success;
  CuratorException ex1;

  _CuratorService_setData_result__isset __isset;

  void __set_success(const OptionalStat& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_setData_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_setData_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_setData_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_setData_presult__isset {
  _CuratorService_setData_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_setData_presult__isset;

class CuratorService_setData_presult {
 public:


  virtual ~CuratorService_setData_presult() throw();
  OptionalStat* success;
  CuratorException ex1;

  _CuratorService_setData_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_startLeaderSelector_args__isset {
  _CuratorService_startLeaderSelector_args__isset() : projection(false), path(false), participantId(false), waitForLeadershipMs(false) {}
  bool projection :1;
  bool path :1;
  bool participantId :1;
  bool waitForLeadershipMs :1;
} _CuratorService_startLeaderSelector_args__isset;

class CuratorService_startLeaderSelector_args {
 public:

  CuratorService_startLeaderSelector_args(const CuratorService_startLeaderSelector_args&);
  CuratorService_startLeaderSelector_args& operator=(const CuratorService_startLeaderSelector_args&);
  CuratorService_startLeaderSelector_args() : path(), participantId(), waitForLeadershipMs(0) {
  }

  virtual ~CuratorService_startLeaderSelector_args() throw();
  CuratorProjection projection;
  std::string path;
  std::string participantId;
  int32_t waitForLeadershipMs;

  _CuratorService_startLeaderSelector_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_path(const std::string& val);

  void __set_participantId(const std::string& val);

  void __set_waitForLeadershipMs(const int32_t val);

  bool operator == (const CuratorService_startLeaderSelector_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(participantId == rhs.participantId))
      return false;
    if (!(waitForLeadershipMs == rhs.waitForLeadershipMs))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startLeaderSelector_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startLeaderSelector_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_startLeaderSelector_pargs {
 public:


  virtual ~CuratorService_startLeaderSelector_pargs() throw();
  const CuratorProjection* projection;
  const std::string* path;
  const std::string* participantId;
  const int32_t* waitForLeadershipMs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startLeaderSelector_result__isset {
  _CuratorService_startLeaderSelector_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startLeaderSelector_result__isset;

class CuratorService_startLeaderSelector_result {
 public:

  CuratorService_startLeaderSelector_result(const CuratorService_startLeaderSelector_result&);
  CuratorService_startLeaderSelector_result& operator=(const CuratorService_startLeaderSelector_result&);
  CuratorService_startLeaderSelector_result() {
  }

  virtual ~CuratorService_startLeaderSelector_result() throw();
  LeaderResult success;
  CuratorException ex1;

  _CuratorService_startLeaderSelector_result__isset __isset;

  void __set_success(const LeaderResult& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_startLeaderSelector_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startLeaderSelector_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startLeaderSelector_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startLeaderSelector_presult__isset {
  _CuratorService_startLeaderSelector_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startLeaderSelector_presult__isset;

class CuratorService_startLeaderSelector_presult {
 public:


  virtual ~CuratorService_startLeaderSelector_presult() throw();
  LeaderResult* success;
  CuratorException ex1;

  _CuratorService_startLeaderSelector_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_startNodeCache_args__isset {
  _CuratorService_startNodeCache_args__isset() : projection(false), path(false), dataIsCompressed(false), buildInitial(false) {}
  bool projection :1;
  bool path :1;
  bool dataIsCompressed :1;
  bool buildInitial :1;
} _CuratorService_startNodeCache_args__isset;

class CuratorService_startNodeCache_args {
 public:

  CuratorService_startNodeCache_args(const CuratorService_startNodeCache_args&);
  CuratorService_startNodeCache_args& operator=(const CuratorService_startNodeCache_args&);
  CuratorService_startNodeCache_args() : path(), dataIsCompressed(0), buildInitial(0) {
  }

  virtual ~CuratorService_startNodeCache_args() throw();
  CuratorProjection projection;
  std::string path;
  bool dataIsCompressed;
  bool buildInitial;

  _CuratorService_startNodeCache_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_path(const std::string& val);

  void __set_dataIsCompressed(const bool val);

  void __set_buildInitial(const bool val);

  bool operator == (const CuratorService_startNodeCache_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(dataIsCompressed == rhs.dataIsCompressed))
      return false;
    if (!(buildInitial == rhs.buildInitial))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startNodeCache_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startNodeCache_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_startNodeCache_pargs {
 public:


  virtual ~CuratorService_startNodeCache_pargs() throw();
  const CuratorProjection* projection;
  const std::string* path;
  const bool* dataIsCompressed;
  const bool* buildInitial;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startNodeCache_result__isset {
  _CuratorService_startNodeCache_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startNodeCache_result__isset;

class CuratorService_startNodeCache_result {
 public:

  CuratorService_startNodeCache_result(const CuratorService_startNodeCache_result&);
  CuratorService_startNodeCache_result& operator=(const CuratorService_startNodeCache_result&);
  CuratorService_startNodeCache_result() {
  }

  virtual ~CuratorService_startNodeCache_result() throw();
  NodeCacheProjection success;
  CuratorException ex1;

  _CuratorService_startNodeCache_result__isset __isset;

  void __set_success(const NodeCacheProjection& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_startNodeCache_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startNodeCache_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startNodeCache_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startNodeCache_presult__isset {
  _CuratorService_startNodeCache_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startNodeCache_presult__isset;

class CuratorService_startNodeCache_presult {
 public:


  virtual ~CuratorService_startNodeCache_presult() throw();
  NodeCacheProjection* success;
  CuratorException ex1;

  _CuratorService_startNodeCache_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_startPathChildrenCache_args__isset {
  _CuratorService_startPathChildrenCache_args__isset() : projection(false), path(false), cacheData(false), dataIsCompressed(false), startMode(false) {}
  bool projection :1;
  bool path :1;
  bool cacheData :1;
  bool dataIsCompressed :1;
  bool startMode :1;
} _CuratorService_startPathChildrenCache_args__isset;

class CuratorService_startPathChildrenCache_args {
 public:

  CuratorService_startPathChildrenCache_args(const CuratorService_startPathChildrenCache_args&);
  CuratorService_startPathChildrenCache_args& operator=(const CuratorService_startPathChildrenCache_args&);
  CuratorService_startPathChildrenCache_args() : path(), cacheData(0), dataIsCompressed(0), startMode((PathChildrenCacheStartMode::type)0) {
  }

  virtual ~CuratorService_startPathChildrenCache_args() throw();
  CuratorProjection projection;
  std::string path;
  bool cacheData;
  bool dataIsCompressed;
  PathChildrenCacheStartMode::type startMode;

  _CuratorService_startPathChildrenCache_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_path(const std::string& val);

  void __set_cacheData(const bool val);

  void __set_dataIsCompressed(const bool val);

  void __set_startMode(const PathChildrenCacheStartMode::type val);

  bool operator == (const CuratorService_startPathChildrenCache_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(cacheData == rhs.cacheData))
      return false;
    if (!(dataIsCompressed == rhs.dataIsCompressed))
      return false;
    if (!(startMode == rhs.startMode))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startPathChildrenCache_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startPathChildrenCache_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_startPathChildrenCache_pargs {
 public:


  virtual ~CuratorService_startPathChildrenCache_pargs() throw();
  const CuratorProjection* projection;
  const std::string* path;
  const bool* cacheData;
  const bool* dataIsCompressed;
  const PathChildrenCacheStartMode::type* startMode;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startPathChildrenCache_result__isset {
  _CuratorService_startPathChildrenCache_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startPathChildrenCache_result__isset;

class CuratorService_startPathChildrenCache_result {
 public:

  CuratorService_startPathChildrenCache_result(const CuratorService_startPathChildrenCache_result&);
  CuratorService_startPathChildrenCache_result& operator=(const CuratorService_startPathChildrenCache_result&);
  CuratorService_startPathChildrenCache_result() {
  }

  virtual ~CuratorService_startPathChildrenCache_result() throw();
  PathChildrenCacheProjection success;
  CuratorException ex1;

  _CuratorService_startPathChildrenCache_result__isset __isset;

  void __set_success(const PathChildrenCacheProjection& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_startPathChildrenCache_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startPathChildrenCache_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startPathChildrenCache_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startPathChildrenCache_presult__isset {
  _CuratorService_startPathChildrenCache_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startPathChildrenCache_presult__isset;

class CuratorService_startPathChildrenCache_presult {
 public:


  virtual ~CuratorService_startPathChildrenCache_presult() throw();
  PathChildrenCacheProjection* success;
  CuratorException ex1;

  _CuratorService_startPathChildrenCache_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_startPersistentEphemeralNode_args__isset {
  _CuratorService_startPersistentEphemeralNode_args__isset() : projection(false), path(false), data(false), mode(false) {}
  bool projection :1;
  bool path :1;
  bool data :1;
  bool mode :1;
} _CuratorService_startPersistentEphemeralNode_args__isset;

class CuratorService_startPersistentEphemeralNode_args {
 public:

  CuratorService_startPersistentEphemeralNode_args(const CuratorService_startPersistentEphemeralNode_args&);
  CuratorService_startPersistentEphemeralNode_args& operator=(const CuratorService_startPersistentEphemeralNode_args&);
  CuratorService_startPersistentEphemeralNode_args() : path(), data(), mode((PersistentEphemeralNodeMode::type)0) {
  }

  virtual ~CuratorService_startPersistentEphemeralNode_args() throw();
  CuratorProjection projection;
  std::string path;
  std::string data;
  PersistentEphemeralNodeMode::type mode;

  _CuratorService_startPersistentEphemeralNode_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_path(const std::string& val);

  void __set_data(const std::string& val);

  void __set_mode(const PersistentEphemeralNodeMode::type val);

  bool operator == (const CuratorService_startPersistentEphemeralNode_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(mode == rhs.mode))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startPersistentEphemeralNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startPersistentEphemeralNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_startPersistentEphemeralNode_pargs {
 public:


  virtual ~CuratorService_startPersistentEphemeralNode_pargs() throw();
  const CuratorProjection* projection;
  const std::string* path;
  const std::string* data;
  const PersistentEphemeralNodeMode::type* mode;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startPersistentEphemeralNode_result__isset {
  _CuratorService_startPersistentEphemeralNode_result__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startPersistentEphemeralNode_result__isset;

class CuratorService_startPersistentEphemeralNode_result {
 public:

  CuratorService_startPersistentEphemeralNode_result(const CuratorService_startPersistentEphemeralNode_result&);
  CuratorService_startPersistentEphemeralNode_result& operator=(const CuratorService_startPersistentEphemeralNode_result&);
  CuratorService_startPersistentEphemeralNode_result() {
  }

  virtual ~CuratorService_startPersistentEphemeralNode_result() throw();
  PersistentEphemeralNodeProjection success;
  CuratorException ex1;

  _CuratorService_startPersistentEphemeralNode_result__isset __isset;

  void __set_success(const PersistentEphemeralNodeProjection& val);

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_startPersistentEphemeralNode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_startPersistentEphemeralNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_startPersistentEphemeralNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_startPersistentEphemeralNode_presult__isset {
  _CuratorService_startPersistentEphemeralNode_presult__isset() : success(false), ex1(false) {}
  bool success :1;
  bool ex1 :1;
} _CuratorService_startPersistentEphemeralNode_presult__isset;

class CuratorService_startPersistentEphemeralNode_presult {
 public:


  virtual ~CuratorService_startPersistentEphemeralNode_presult() throw();
  PersistentEphemeralNodeProjection* success;
  CuratorException ex1;

  _CuratorService_startPersistentEphemeralNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CuratorService_sync_args__isset {
  _CuratorService_sync_args__isset() : projection(false), path(false), asyncContext(false) {}
  bool projection :1;
  bool path :1;
  bool asyncContext :1;
} _CuratorService_sync_args__isset;

class CuratorService_sync_args {
 public:

  CuratorService_sync_args(const CuratorService_sync_args&);
  CuratorService_sync_args& operator=(const CuratorService_sync_args&);
  CuratorService_sync_args() : path(), asyncContext() {
  }

  virtual ~CuratorService_sync_args() throw();
  CuratorProjection projection;
  std::string path;
  std::string asyncContext;

  _CuratorService_sync_args__isset __isset;

  void __set_projection(const CuratorProjection& val);

  void __set_path(const std::string& val);

  void __set_asyncContext(const std::string& val);

  bool operator == (const CuratorService_sync_args & rhs) const
  {
    if (!(projection == rhs.projection))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(asyncContext == rhs.asyncContext))
      return false;
    return true;
  }
  bool operator != (const CuratorService_sync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_sync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CuratorService_sync_pargs {
 public:


  virtual ~CuratorService_sync_pargs() throw();
  const CuratorProjection* projection;
  const std::string* path;
  const std::string* asyncContext;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_sync_result__isset {
  _CuratorService_sync_result__isset() : ex1(false) {}
  bool ex1 :1;
} _CuratorService_sync_result__isset;

class CuratorService_sync_result {
 public:

  CuratorService_sync_result(const CuratorService_sync_result&);
  CuratorService_sync_result& operator=(const CuratorService_sync_result&);
  CuratorService_sync_result() {
  }

  virtual ~CuratorService_sync_result() throw();
  CuratorException ex1;

  _CuratorService_sync_result__isset __isset;

  void __set_ex1(const CuratorException& val);

  bool operator == (const CuratorService_sync_result & rhs) const
  {
    if (!(ex1 == rhs.ex1))
      return false;
    return true;
  }
  bool operator != (const CuratorService_sync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CuratorService_sync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CuratorService_sync_presult__isset {
  _CuratorService_sync_presult__isset() : ex1(false) {}
  bool ex1 :1;
} _CuratorService_sync_presult__isset;

class CuratorService_sync_presult {
 public:


  virtual ~CuratorService_sync_presult() throw();
  CuratorException ex1;

  _CuratorService_sync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class CuratorServiceClient : virtual public CuratorServiceIf {
 public:
  CuratorServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  CuratorServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void acquireLock(OptionalLockProjection& _return, const CuratorProjection& projection, const std::string& path, const int32_t maxWaitMs);
  void send_acquireLock(const CuratorProjection& projection, const std::string& path, const int32_t maxWaitMs);
  void recv_acquireLock(OptionalLockProjection& _return);
  void acquireSemaphore(std::vector<LeaseProjection> & _return, const CuratorProjection& projection, const std::string& path, const int32_t acquireQty, const int32_t maxWaitMs, const int32_t maxLeases);
  void send_acquireSemaphore(const CuratorProjection& projection, const std::string& path, const int32_t acquireQty, const int32_t maxWaitMs, const int32_t maxLeases);
  void recv_acquireSemaphore(std::vector<LeaseProjection> & _return);
  void closeCuratorProjection(const CuratorProjection& projection);
  void send_closeCuratorProjection(const CuratorProjection& projection);
  void recv_closeCuratorProjection();
  bool closeGenericProjection(const CuratorProjection& projection, const std::string& id);
  void send_closeGenericProjection(const CuratorProjection& projection, const std::string& id);
  bool recv_closeGenericProjection();
  void createNode(OptionalPath& _return, const CuratorProjection& projection, const CreateSpec& spec);
  void send_createNode(const CuratorProjection& projection, const CreateSpec& spec);
  void recv_createNode(OptionalPath& _return);
  void deleteNode(const CuratorProjection& projection, const DeleteSpec& spec);
  void send_deleteNode(const CuratorProjection& projection, const DeleteSpec& spec);
  void recv_deleteNode();
  void exists(OptionalStat& _return, const CuratorProjection& projection, const ExistsSpec& spec);
  void send_exists(const CuratorProjection& projection, const ExistsSpec& spec);
  void recv_exists(OptionalStat& _return);
  void getChildren(OptionalChildrenList& _return, const CuratorProjection& projection, const GetChildrenSpec& spec);
  void send_getChildren(const CuratorProjection& projection, const GetChildrenSpec& spec);
  void recv_getChildren(OptionalChildrenList& _return);
  void getData(OptionalData& _return, const CuratorProjection& projection, const GetDataSpec& spec);
  void send_getData(const CuratorProjection& projection, const GetDataSpec& spec);
  void recv_getData(OptionalData& _return);
  void getLeaderParticipants(std::vector<Participant> & _return, const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  void send_getLeaderParticipants(const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  void recv_getLeaderParticipants(std::vector<Participant> & _return);
  void getNodeCacheData(ChildData& _return, const CuratorProjection& projection, const NodeCacheProjection& cacheProjection);
  void send_getNodeCacheData(const CuratorProjection& projection, const NodeCacheProjection& cacheProjection);
  void recv_getNodeCacheData(ChildData& _return);
  void getPathChildrenCacheData(std::vector<ChildData> & _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection);
  void send_getPathChildrenCacheData(const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection);
  void recv_getPathChildrenCacheData(std::vector<ChildData> & _return);
  void getPathChildrenCacheDataForPath(ChildData& _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection, const std::string& path);
  void send_getPathChildrenCacheDataForPath(const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection, const std::string& path);
  void recv_getPathChildrenCacheDataForPath(ChildData& _return);
  bool isLeader(const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  void send_isLeader(const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  bool recv_isLeader();
  void newCuratorProjection(CuratorProjection& _return, const std::string& connectionName);
  void send_newCuratorProjection(const std::string& connectionName);
  void recv_newCuratorProjection(CuratorProjection& _return);
  void pingCuratorProjection(const CuratorProjection& projection);
  void send_pingCuratorProjection(const CuratorProjection& projection);
  void setData(OptionalStat& _return, const CuratorProjection& projection, const SetDataSpec& spec);
  void send_setData(const CuratorProjection& projection, const SetDataSpec& spec);
  void recv_setData(OptionalStat& _return);
  void startLeaderSelector(LeaderResult& _return, const CuratorProjection& projection, const std::string& path, const std::string& participantId, const int32_t waitForLeadershipMs);
  void send_startLeaderSelector(const CuratorProjection& projection, const std::string& path, const std::string& participantId, const int32_t waitForLeadershipMs);
  void recv_startLeaderSelector(LeaderResult& _return);
  void startNodeCache(NodeCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool dataIsCompressed, const bool buildInitial);
  void send_startNodeCache(const CuratorProjection& projection, const std::string& path, const bool dataIsCompressed, const bool buildInitial);
  void recv_startNodeCache(NodeCacheProjection& _return);
  void startPathChildrenCache(PathChildrenCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool cacheData, const bool dataIsCompressed, const PathChildrenCacheStartMode::type startMode);
  void send_startPathChildrenCache(const CuratorProjection& projection, const std::string& path, const bool cacheData, const bool dataIsCompressed, const PathChildrenCacheStartMode::type startMode);
  void recv_startPathChildrenCache(PathChildrenCacheProjection& _return);
  void startPersistentEphemeralNode(PersistentEphemeralNodeProjection& _return, const CuratorProjection& projection, const std::string& path, const std::string& data, const PersistentEphemeralNodeMode::type mode);
  void send_startPersistentEphemeralNode(const CuratorProjection& projection, const std::string& path, const std::string& data, const PersistentEphemeralNodeMode::type mode);
  void recv_startPersistentEphemeralNode(PersistentEphemeralNodeProjection& _return);
  void sync(const CuratorProjection& projection, const std::string& path, const std::string& asyncContext);
  void send_sync(const CuratorProjection& projection, const std::string& path, const std::string& asyncContext);
  void recv_sync();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class CuratorServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<CuratorServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (CuratorServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_acquireLock(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_acquireSemaphore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeCuratorProjection(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeGenericProjection(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exists(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getChildren(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getLeaderParticipants(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNodeCacheData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPathChildrenCacheData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPathChildrenCacheDataForPath(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isLeader(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newCuratorProjection(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pingCuratorProjection(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_startLeaderSelector(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_startNodeCache(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_startPathChildrenCache(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_startPersistentEphemeralNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_sync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  CuratorServiceProcessor(boost::shared_ptr<CuratorServiceIf> iface) :
    iface_(iface) {
    processMap_["acquireLock"] = &CuratorServiceProcessor::process_acquireLock;
    processMap_["acquireSemaphore"] = &CuratorServiceProcessor::process_acquireSemaphore;
    processMap_["closeCuratorProjection"] = &CuratorServiceProcessor::process_closeCuratorProjection;
    processMap_["closeGenericProjection"] = &CuratorServiceProcessor::process_closeGenericProjection;
    processMap_["createNode"] = &CuratorServiceProcessor::process_createNode;
    processMap_["deleteNode"] = &CuratorServiceProcessor::process_deleteNode;
    processMap_["exists"] = &CuratorServiceProcessor::process_exists;
    processMap_["getChildren"] = &CuratorServiceProcessor::process_getChildren;
    processMap_["getData"] = &CuratorServiceProcessor::process_getData;
    processMap_["getLeaderParticipants"] = &CuratorServiceProcessor::process_getLeaderParticipants;
    processMap_["getNodeCacheData"] = &CuratorServiceProcessor::process_getNodeCacheData;
    processMap_["getPathChildrenCacheData"] = &CuratorServiceProcessor::process_getPathChildrenCacheData;
    processMap_["getPathChildrenCacheDataForPath"] = &CuratorServiceProcessor::process_getPathChildrenCacheDataForPath;
    processMap_["isLeader"] = &CuratorServiceProcessor::process_isLeader;
    processMap_["newCuratorProjection"] = &CuratorServiceProcessor::process_newCuratorProjection;
    processMap_["pingCuratorProjection"] = &CuratorServiceProcessor::process_pingCuratorProjection;
    processMap_["setData"] = &CuratorServiceProcessor::process_setData;
    processMap_["startLeaderSelector"] = &CuratorServiceProcessor::process_startLeaderSelector;
    processMap_["startNodeCache"] = &CuratorServiceProcessor::process_startNodeCache;
    processMap_["startPathChildrenCache"] = &CuratorServiceProcessor::process_startPathChildrenCache;
    processMap_["startPersistentEphemeralNode"] = &CuratorServiceProcessor::process_startPersistentEphemeralNode;
    processMap_["sync"] = &CuratorServiceProcessor::process_sync;
  }

  virtual ~CuratorServiceProcessor() {}
};

class CuratorServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  CuratorServiceProcessorFactory(const ::boost::shared_ptr< CuratorServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< CuratorServiceIfFactory > handlerFactory_;
};

class CuratorServiceMultiface : virtual public CuratorServiceIf {
 public:
  CuratorServiceMultiface(std::vector<boost::shared_ptr<CuratorServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~CuratorServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<CuratorServiceIf> > ifaces_;
  CuratorServiceMultiface() {}
  void add(boost::shared_ptr<CuratorServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void acquireLock(OptionalLockProjection& _return, const CuratorProjection& projection, const std::string& path, const int32_t maxWaitMs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->acquireLock(_return, projection, path, maxWaitMs);
    }
    ifaces_[i]->acquireLock(_return, projection, path, maxWaitMs);
    return;
  }

  void acquireSemaphore(std::vector<LeaseProjection> & _return, const CuratorProjection& projection, const std::string& path, const int32_t acquireQty, const int32_t maxWaitMs, const int32_t maxLeases) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->acquireSemaphore(_return, projection, path, acquireQty, maxWaitMs, maxLeases);
    }
    ifaces_[i]->acquireSemaphore(_return, projection, path, acquireQty, maxWaitMs, maxLeases);
    return;
  }

  void closeCuratorProjection(const CuratorProjection& projection) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeCuratorProjection(projection);
    }
    ifaces_[i]->closeCuratorProjection(projection);
  }

  bool closeGenericProjection(const CuratorProjection& projection, const std::string& id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeGenericProjection(projection, id);
    }
    return ifaces_[i]->closeGenericProjection(projection, id);
  }

  void createNode(OptionalPath& _return, const CuratorProjection& projection, const CreateSpec& spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createNode(_return, projection, spec);
    }
    ifaces_[i]->createNode(_return, projection, spec);
    return;
  }

  void deleteNode(const CuratorProjection& projection, const DeleteSpec& spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteNode(projection, spec);
    }
    ifaces_[i]->deleteNode(projection, spec);
  }

  void exists(OptionalStat& _return, const CuratorProjection& projection, const ExistsSpec& spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exists(_return, projection, spec);
    }
    ifaces_[i]->exists(_return, projection, spec);
    return;
  }

  void getChildren(OptionalChildrenList& _return, const CuratorProjection& projection, const GetChildrenSpec& spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getChildren(_return, projection, spec);
    }
    ifaces_[i]->getChildren(_return, projection, spec);
    return;
  }

  void getData(OptionalData& _return, const CuratorProjection& projection, const GetDataSpec& spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getData(_return, projection, spec);
    }
    ifaces_[i]->getData(_return, projection, spec);
    return;
  }

  void getLeaderParticipants(std::vector<Participant> & _return, const CuratorProjection& projection, const LeaderProjection& leaderProjection) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getLeaderParticipants(_return, projection, leaderProjection);
    }
    ifaces_[i]->getLeaderParticipants(_return, projection, leaderProjection);
    return;
  }

  void getNodeCacheData(ChildData& _return, const CuratorProjection& projection, const NodeCacheProjection& cacheProjection) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNodeCacheData(_return, projection, cacheProjection);
    }
    ifaces_[i]->getNodeCacheData(_return, projection, cacheProjection);
    return;
  }

  void getPathChildrenCacheData(std::vector<ChildData> & _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getPathChildrenCacheData(_return, projection, cacheProjection);
    }
    ifaces_[i]->getPathChildrenCacheData(_return, projection, cacheProjection);
    return;
  }

  void getPathChildrenCacheDataForPath(ChildData& _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getPathChildrenCacheDataForPath(_return, projection, cacheProjection, path);
    }
    ifaces_[i]->getPathChildrenCacheDataForPath(_return, projection, cacheProjection, path);
    return;
  }

  bool isLeader(const CuratorProjection& projection, const LeaderProjection& leaderProjection) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->isLeader(projection, leaderProjection);
    }
    return ifaces_[i]->isLeader(projection, leaderProjection);
  }

  void newCuratorProjection(CuratorProjection& _return, const std::string& connectionName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newCuratorProjection(_return, connectionName);
    }
    ifaces_[i]->newCuratorProjection(_return, connectionName);
    return;
  }

  void pingCuratorProjection(const CuratorProjection& projection) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pingCuratorProjection(projection);
    }
    ifaces_[i]->pingCuratorProjection(projection);
  }

  void setData(OptionalStat& _return, const CuratorProjection& projection, const SetDataSpec& spec) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setData(_return, projection, spec);
    }
    ifaces_[i]->setData(_return, projection, spec);
    return;
  }

  void startLeaderSelector(LeaderResult& _return, const CuratorProjection& projection, const std::string& path, const std::string& participantId, const int32_t waitForLeadershipMs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->startLeaderSelector(_return, projection, path, participantId, waitForLeadershipMs);
    }
    ifaces_[i]->startLeaderSelector(_return, projection, path, participantId, waitForLeadershipMs);
    return;
  }

  void startNodeCache(NodeCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool dataIsCompressed, const bool buildInitial) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->startNodeCache(_return, projection, path, dataIsCompressed, buildInitial);
    }
    ifaces_[i]->startNodeCache(_return, projection, path, dataIsCompressed, buildInitial);
    return;
  }

  void startPathChildrenCache(PathChildrenCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool cacheData, const bool dataIsCompressed, const PathChildrenCacheStartMode::type startMode) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->startPathChildrenCache(_return, projection, path, cacheData, dataIsCompressed, startMode);
    }
    ifaces_[i]->startPathChildrenCache(_return, projection, path, cacheData, dataIsCompressed, startMode);
    return;
  }

  void startPersistentEphemeralNode(PersistentEphemeralNodeProjection& _return, const CuratorProjection& projection, const std::string& path, const std::string& data, const PersistentEphemeralNodeMode::type mode) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->startPersistentEphemeralNode(_return, projection, path, data, mode);
    }
    ifaces_[i]->startPersistentEphemeralNode(_return, projection, path, data, mode);
    return;
  }

  void sync(const CuratorProjection& projection, const std::string& path, const std::string& asyncContext) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->sync(projection, path, asyncContext);
    }
    ifaces_[i]->sync(projection, path, asyncContext);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class CuratorServiceConcurrentClient : virtual public CuratorServiceIf {
 public:
  CuratorServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  CuratorServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void acquireLock(OptionalLockProjection& _return, const CuratorProjection& projection, const std::string& path, const int32_t maxWaitMs);
  int32_t send_acquireLock(const CuratorProjection& projection, const std::string& path, const int32_t maxWaitMs);
  void recv_acquireLock(OptionalLockProjection& _return, const int32_t seqid);
  void acquireSemaphore(std::vector<LeaseProjection> & _return, const CuratorProjection& projection, const std::string& path, const int32_t acquireQty, const int32_t maxWaitMs, const int32_t maxLeases);
  int32_t send_acquireSemaphore(const CuratorProjection& projection, const std::string& path, const int32_t acquireQty, const int32_t maxWaitMs, const int32_t maxLeases);
  void recv_acquireSemaphore(std::vector<LeaseProjection> & _return, const int32_t seqid);
  void closeCuratorProjection(const CuratorProjection& projection);
  int32_t send_closeCuratorProjection(const CuratorProjection& projection);
  void recv_closeCuratorProjection(const int32_t seqid);
  bool closeGenericProjection(const CuratorProjection& projection, const std::string& id);
  int32_t send_closeGenericProjection(const CuratorProjection& projection, const std::string& id);
  bool recv_closeGenericProjection(const int32_t seqid);
  void createNode(OptionalPath& _return, const CuratorProjection& projection, const CreateSpec& spec);
  int32_t send_createNode(const CuratorProjection& projection, const CreateSpec& spec);
  void recv_createNode(OptionalPath& _return, const int32_t seqid);
  void deleteNode(const CuratorProjection& projection, const DeleteSpec& spec);
  int32_t send_deleteNode(const CuratorProjection& projection, const DeleteSpec& spec);
  void recv_deleteNode(const int32_t seqid);
  void exists(OptionalStat& _return, const CuratorProjection& projection, const ExistsSpec& spec);
  int32_t send_exists(const CuratorProjection& projection, const ExistsSpec& spec);
  void recv_exists(OptionalStat& _return, const int32_t seqid);
  void getChildren(OptionalChildrenList& _return, const CuratorProjection& projection, const GetChildrenSpec& spec);
  int32_t send_getChildren(const CuratorProjection& projection, const GetChildrenSpec& spec);
  void recv_getChildren(OptionalChildrenList& _return, const int32_t seqid);
  void getData(OptionalData& _return, const CuratorProjection& projection, const GetDataSpec& spec);
  int32_t send_getData(const CuratorProjection& projection, const GetDataSpec& spec);
  void recv_getData(OptionalData& _return, const int32_t seqid);
  void getLeaderParticipants(std::vector<Participant> & _return, const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  int32_t send_getLeaderParticipants(const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  void recv_getLeaderParticipants(std::vector<Participant> & _return, const int32_t seqid);
  void getNodeCacheData(ChildData& _return, const CuratorProjection& projection, const NodeCacheProjection& cacheProjection);
  int32_t send_getNodeCacheData(const CuratorProjection& projection, const NodeCacheProjection& cacheProjection);
  void recv_getNodeCacheData(ChildData& _return, const int32_t seqid);
  void getPathChildrenCacheData(std::vector<ChildData> & _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection);
  int32_t send_getPathChildrenCacheData(const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection);
  void recv_getPathChildrenCacheData(std::vector<ChildData> & _return, const int32_t seqid);
  void getPathChildrenCacheDataForPath(ChildData& _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection, const std::string& path);
  int32_t send_getPathChildrenCacheDataForPath(const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection, const std::string& path);
  void recv_getPathChildrenCacheDataForPath(ChildData& _return, const int32_t seqid);
  bool isLeader(const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  int32_t send_isLeader(const CuratorProjection& projection, const LeaderProjection& leaderProjection);
  bool recv_isLeader(const int32_t seqid);
  void newCuratorProjection(CuratorProjection& _return, const std::string& connectionName);
  int32_t send_newCuratorProjection(const std::string& connectionName);
  void recv_newCuratorProjection(CuratorProjection& _return, const int32_t seqid);
  void pingCuratorProjection(const CuratorProjection& projection);
  void send_pingCuratorProjection(const CuratorProjection& projection);
  void setData(OptionalStat& _return, const CuratorProjection& projection, const SetDataSpec& spec);
  int32_t send_setData(const CuratorProjection& projection, const SetDataSpec& spec);
  void recv_setData(OptionalStat& _return, const int32_t seqid);
  void startLeaderSelector(LeaderResult& _return, const CuratorProjection& projection, const std::string& path, const std::string& participantId, const int32_t waitForLeadershipMs);
  int32_t send_startLeaderSelector(const CuratorProjection& projection, const std::string& path, const std::string& participantId, const int32_t waitForLeadershipMs);
  void recv_startLeaderSelector(LeaderResult& _return, const int32_t seqid);
  void startNodeCache(NodeCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool dataIsCompressed, const bool buildInitial);
  int32_t send_startNodeCache(const CuratorProjection& projection, const std::string& path, const bool dataIsCompressed, const bool buildInitial);
  void recv_startNodeCache(NodeCacheProjection& _return, const int32_t seqid);
  void startPathChildrenCache(PathChildrenCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool cacheData, const bool dataIsCompressed, const PathChildrenCacheStartMode::type startMode);
  int32_t send_startPathChildrenCache(const CuratorProjection& projection, const std::string& path, const bool cacheData, const bool dataIsCompressed, const PathChildrenCacheStartMode::type startMode);
  void recv_startPathChildrenCache(PathChildrenCacheProjection& _return, const int32_t seqid);
  void startPersistentEphemeralNode(PersistentEphemeralNodeProjection& _return, const CuratorProjection& projection, const std::string& path, const std::string& data, const PersistentEphemeralNodeMode::type mode);
  int32_t send_startPersistentEphemeralNode(const CuratorProjection& projection, const std::string& path, const std::string& data, const PersistentEphemeralNodeMode::type mode);
  void recv_startPersistentEphemeralNode(PersistentEphemeralNodeProjection& _return, const int32_t seqid);
  void sync(const CuratorProjection& projection, const std::string& path, const std::string& asyncContext);
  int32_t send_sync(const CuratorProjection& projection, const std::string& path, const std::string& asyncContext);
  void recv_sync(const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

} // namespace

#endif
