// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "CuratorService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::shared;

class CuratorServiceHandler : virtual public CuratorServiceIf {
 public:
  CuratorServiceHandler() {
    // Your initialization goes here
  }

  void acquireLock(OptionalLockProjection& _return, const CuratorProjection& projection, const std::string& path, const int32_t maxWaitMs) {
    // Your implementation goes here
    printf("acquireLock\n");
  }

  void acquireSemaphore(std::vector<LeaseProjection> & _return, const CuratorProjection& projection, const std::string& path, const int32_t acquireQty, const int32_t maxWaitMs, const int32_t maxLeases) {
    // Your implementation goes here
    printf("acquireSemaphore\n");
  }

  void closeCuratorProjection(const CuratorProjection& projection) {
    // Your implementation goes here
    printf("closeCuratorProjection\n");
  }

  bool closeGenericProjection(const CuratorProjection& projection, const std::string& id) {
    // Your implementation goes here
    printf("closeGenericProjection\n");
  }

  void createNode(OptionalPath& _return, const CuratorProjection& projection, const CreateSpec& spec) {
    // Your implementation goes here
    printf("createNode\n");
  }

  void deleteNode(const CuratorProjection& projection, const DeleteSpec& spec) {
    // Your implementation goes here
    printf("deleteNode\n");
  }

  void exists(OptionalStat& _return, const CuratorProjection& projection, const ExistsSpec& spec) {
    // Your implementation goes here
    printf("exists\n");
  }

  void getChildren(OptionalChildrenList& _return, const CuratorProjection& projection, const GetChildrenSpec& spec) {
    // Your implementation goes here
    printf("getChildren\n");
  }

  void getData(OptionalData& _return, const CuratorProjection& projection, const GetDataSpec& spec) {
    // Your implementation goes here
    printf("getData\n");
  }

  void getLeaderParticipants(std::vector<Participant> & _return, const CuratorProjection& projection, const LeaderProjection& leaderProjection) {
    // Your implementation goes here
    printf("getLeaderParticipants\n");
  }

  void getNodeCacheData(ChildData& _return, const CuratorProjection& projection, const NodeCacheProjection& cacheProjection) {
    // Your implementation goes here
    printf("getNodeCacheData\n");
  }

  void getPathChildrenCacheData(std::vector<ChildData> & _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection) {
    // Your implementation goes here
    printf("getPathChildrenCacheData\n");
  }

  void getPathChildrenCacheDataForPath(ChildData& _return, const CuratorProjection& projection, const PathChildrenCacheProjection& cacheProjection, const std::string& path) {
    // Your implementation goes here
    printf("getPathChildrenCacheDataForPath\n");
  }

  bool isLeader(const CuratorProjection& projection, const LeaderProjection& leaderProjection) {
    // Your implementation goes here
    printf("isLeader\n");
  }

  void newCuratorProjection(CuratorProjection& _return, const std::string& connectionName) {
    // Your implementation goes here
    printf("newCuratorProjection\n");
  }

  void pingCuratorProjection(const CuratorProjection& projection) {
    // Your implementation goes here
    printf("pingCuratorProjection\n");
  }

  void setData(OptionalStat& _return, const CuratorProjection& projection, const SetDataSpec& spec) {
    // Your implementation goes here
    printf("setData\n");
  }

  void startLeaderSelector(LeaderResult& _return, const CuratorProjection& projection, const std::string& path, const std::string& participantId, const int32_t waitForLeadershipMs) {
    // Your implementation goes here
    printf("startLeaderSelector\n");
  }

  void startNodeCache(NodeCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool dataIsCompressed, const bool buildInitial) {
    // Your implementation goes here
    printf("startNodeCache\n");
  }

  void startPathChildrenCache(PathChildrenCacheProjection& _return, const CuratorProjection& projection, const std::string& path, const bool cacheData, const bool dataIsCompressed, const PathChildrenCacheStartMode::type startMode) {
    // Your implementation goes here
    printf("startPathChildrenCache\n");
  }

  void startPersistentEphemeralNode(PersistentEphemeralNodeProjection& _return, const CuratorProjection& projection, const std::string& path, const std::string& data, const PersistentEphemeralNodeMode::type mode) {
    // Your implementation goes here
    printf("startPersistentEphemeralNode\n");
  }

  void sync(const CuratorProjection& projection, const std::string& path, const std::string& asyncContext) {
    // Your implementation goes here
    printf("sync\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<CuratorServiceHandler> handler(new CuratorServiceHandler());
  shared_ptr<TProcessor> processor(new CuratorServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

